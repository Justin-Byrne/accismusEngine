// @program: 		devSuite 
// @brief: 			Developer tools for canvasLab drawing framework 
// @author: 		Justin D. Byrne 
// @email: 			justin@byrne-systems.com 
// @version: 		0.0.1 
// @license: 		GPL-2.0

"use strict";
 
/**
 * Converts string to title case
 * @public
 * @name toTitleCase
 * @function
 * @param           {string} string                     String to convert
 * @return          {string}                            Title case string
 */
String.prototype.toTitleCase = function ( )
{
    let _titleCase = ( string ) => string.split ( ' ' )
                                         .map   ( ( word ) => word.replace ( word [ 0 ], word [ 0 ].toUpperCase ( ) ) )
                                         .join  ( ' ' );


    if ( this )
    {
        let _string    = this.toString ( ).toLowerCase ( );


        switch ( _string )
        {
            case 'controlpoints':       return 'ControlPoints';

            case 'roundedrectangle':    return 'RoundedRectangle';

            case 'roundedrectangles':   return 'RoundedRectangles';

            default:                    return _titleCase ( _string );
        }
    }
};

/**
 * Converts a number into a multi-digit string
 * @public
 * @name to2Digits
 * @function
 * @param           {number} number                     Number
 * @return          {string}                            Multi-digit string
 */
String.prototype.to2Digits = function ( )
{
    return ( Number ( this ) < 10 ) ? '0' + this

                                    : this;
};

/**
 * Substitute a string within a range
 * @public
 * @name subStringRange
 * @function
 * @param           {number} start                      Substitution's starting point
 * @param           {number} end                        Substitution's ending point
 * @param           {string} substring                  Substitution
 * @return          {string}                            String with substitution
 */
String.prototype.subStringRange = function ( start, end, substring )
{
    return this.substring ( 0, start ) + substring + this.substring ( end );
};
 
/**
 * @class           {Object} Lab                        Lab with ace-editor
 * @property        {Object} editor                     Primary ace-editor object
 */
class Lab
{
    _editor = undefined;

    _clipboard =
    {
        coordinates:
        {
            display:   undefined,
            cartesian: undefined,
            center:    undefined
        },
        angle:
        {
            degree:   undefined,
            distance: undefined
        }
    }

    #mouse =
    {
        click: false,
        hold:  false,
        point: new Point
    }

    _script =
    {
        title:  undefined,
        timing: undefined
    }

    constructor ( ) { }

    ////    PROPERTIES    //////////////////////////////////////////////////////

        ////    [ EDITOR ]    //////////////////////////////

            /**
             * Sets editor
             * @public
             * @function
             * @param           {Object} editor                     Primary ace-editor object
             */
            set editor ( editor )
            {
                this._editor = ( typeof editor === 'object' ) ? editor : this._editor;
            }

            /**
             * Gets editor
             * @public
             * @function
             * @return          {Object}                            Primary ace-editor object
             */
            get editor ( )
            {
                return this._editor;
            }

    ////    UTILITIES    ///////////////////////////////////////////////////////

        ////    PRIVATE    /////////////////////////////////

            /**
             * Cleans code of enumerators for ace-editor
             * @private
             * @function
             * @param           {Function} script                   JavaScript function; for ace-editor only
             * @return          {string}                            Function as a string
             */
            _cleanCode ( script )
            {
                let _code   = UI.clean.script ( script ).split ( /\n/g );

                    _code   = _code.slice ( 1 );

                let _indent = 12;


                for ( let _line in _code )

                    _code [ _line ] = _code [ _line ].substring ( _indent, _code [ _line ].length );


                return _code.join ( '\n' );
            }

            /**
             * Clears existing animations
             * @private
             * @function
             */
            _clearExistingAnimations ( )
            {
                let _animation = canvaslab.application.animation;


                if ( _animation )

                    _animation.cancel
            }

            /**
             * Copy passed contents to clipboard
             * @public
             * @async
             * @function
             * @param           {string} contents                   Contents to copy to clipboard
             */
            async _copyToClipboard ( contents )
            {
                try
                {
                    await navigator.clipboard.writeText ( contents );

                    console.info ( 'Copied to clipboard' );
                }
                catch ( err )
                {
                    console.error ( 'Failed to copy: ', err );
                }
            }

            /**
             * Generates a downloadable file & initiates that download
             * @private
             * @function
             * @param           {File} file                         File to download
             */
            _download ( file )
            {
                let _link = document.createElement ( 'a' );

                let _url  = window.URL.createObjectURL ( file );

                    _link.href      = _url;

                    _link.download  = file.name


                document.body.appendChild  ( _link );


                    _link.click ( );


                document.body.removeChild  ( _link );

                window.URL.revokeObjectURL ( _url  );
            }

            /**
             * Get angle from two points
             * @private
             * @function
             * @param           {Point} start                       Starting point
             * @param           {Point} end                         Ending point
             * @return          {number}                            Degree of angle; 360째
             */
            _getAngle ( start, end )
            {
                let _x = end.x - start.x;

                let _y = end.y - start.y;


                let _radian = - ( Math.atan2 ( _y, _x ) );

                let _degree = _radian * ( 180 / Math.PI );


                if ( _degree < 0 )

                    _degree = _degree + 360;


                return _degree;
            }

            /**
             * Returns positions of bounding characters within the ace-editor
             * @private
             * @function
             * @param           {Array.<string>} characters         Bounding characters
             * @param           {string}        data                Data to parse
             * @return          {Object}                            Bounding character's starting & ending position(s)
             */
            _getBoundingCharactersPositions ( characters, data )
            {
                let _cursor = this.editor.selection.getCursor ( );


                let _start = data.indexOf ( characters [ 0 ] ) + 1;

                let _end   = data.indexOf ( characters [ 1 ], _start + 1 );


                while ( _cursor.column > _end )
                {
                    _start = data.indexOf ( characters [ 0 ], _end + 1 ) + 1;

                    _end   = data.indexOf ( characters [ 1 ], _start + 1 );
                }


                return new Object ( { start: _start, end: _end } );
            }

            /**
             * Returns a new color-picker object
             * @private
             * @function
             * @param           {string} id                         Element id
             * @return          {Object}                            Color-picker object
             */
            _getColorPicker ( id )
            {
                let _button  = document.getElementById ( id );

                let _options =
                {
                    parent:         _button,                    // Which element the picker should be attached to.
                    popup:          'top',                      // If the picker is used as a popup, where to place it relative to the parent. false to add the picker as a normal child element of the parent.
                    template:       undefined,                  // Custom HTML string from which to build the picker. See /src/picker.pug for required elements and class names.
                    layout:         undefined,                  // Suffix of a custom "layout_..." CSS class to handle the overall arrangement of the picker elements.
                    alpha:          true,                       // Whether to enable adjusting the alpha channel.
                    editor:         true,                       // Whether to show a text field for color value editing.
                    editorFormat:   'rgb',                      // How to display the selected color in the text field (the text field still supports input in any format).
                    cancelButton:   false,                      // Whether to have a "Cancel" button which closes the popup.
                    color:          undefined,                  // Initial color for the picker.
                    onChange:       undefined,                  // (callback) onChange
                    onDone:         undefined,                  // (callback) onDone
                    onOpen:         undefined,                  // (callback) onOpen
                    onClose:        undefined                   // (callback) onClose
                };


                return new Picker ( _options );
            }

            /**
             * Get distance between two points
             * @private
             * @function
             * @param           {Point} start                       Starting point
             * @param           {Point} end                         Ending point
             * @return          {number}                            Distance in pixels
             */
            _getDistance ( start, end )
            {
                return Math.sqrt ( ( Math.pow ( start.x - end.x, 2 ) ) + ( Math.pow ( start.y - end.y, 2 ) ) );
            }

            /**
             * Gets menu popup item with the passed 'element' param
             * @private
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            _getMenuPopup ( element )
            {
                let _scripts = devSuite.getScripts ( );

                let _title   = ( /\s/.test ( element.srcElement.innerHTML ) ) ? element.srcElement.innerHTML.replaceAll ( ' ', '' )

                                                                              : element.srcElement.innerHTML;

                let _script  = _scripts [ _title ];


                this.loadScript ( _script );

                this.runCode ( );


                UI.toggle.labPopup ( '#input-menu', '.menu_popup' );
            }

            /**
             * Increment the value passed up (+) or down (-)
             * @private
             * @function
             * @param           {string|number} value               Value to increment
             * @param           {boolean}       up                  True (+) || false (-)
             * @return          {number}                            Incremented value
             */
            _increment ( value, up )
            {
                return ( up ) ? Number ( value ) + 1 : Number ( value ) - 1;
            }

            /**
             * Increments a numeric selection from ace-editor up (+) or down (-)
             * @private
             * @function
             * @param           {string}  value                     Value from ace-editor
             * @param           {boolean} up                        True (+) || false (-)
             * @return          {string}                            Incremented value
             */
            _incrementValue ( value, up )
            {
                let _result = undefined;


                let [ _regexMatch, _regexReplace, _replaceValue ] = ( up ) ? [ new RegExp ( /[9]+/g ), new RegExp ( /[9]/g ), 0 ]

                                                                           : [ new RegExp ( /[0]+/g ), new RegExp ( /[0]/g ), 9 ];

                let _match      = value.match ( _regexMatch  );

                let _length     = value.length;

                let _regexAlpha = new RegExp ( /[^\d]/g );


                if ( _regexAlpha.test ( value ) )

                    console.warn ( '[ lab-station ]: non-digit characters within selection !' );

                else

                    _result = ( _match ) ? ( value.length === _match [ 0 ].length ) // Increment or Replace

                                               ? value.replace ( _regexReplace, _replaceValue )

                                               : this._increment ( value, up )

                                         : this._increment ( value, up );


                _result = ( String ( _result ).length < _length )                   // Pad: [0]+[1-9] using the original value's length

                              ? this._padZeros ( _result, _length )

                              : `${_result}`;


                return _result;
            }

            /**
             * Pad a string with a specified amount of zeros
             * @private
             * @function
             * @param           {string|number} value               Value to pad
             * @param           {number}        amount              Amount to pad
             * @return          {string}                            Padded amount
             */
            _padZeros ( value, amount )
            {
                return String ( value ).padStart ( amount, '0' );
            }

            /**
             * Rotates the origin point by the degree & distance passed
             * @public
             * @function
             * @param           {Point}  origin                             Origin point
             * @param           {number} degree                             Degree to rotate
             * @param           {number} distance                           Distance from origin
             */
            _rotatePoint ( origin = { x, y }, degree, distance )
            {
                let _point = new Point;

                let _angle = ( degree % 360 );


                    _point.x = origin.x + Math.cos ( _angle * Math.PI / 180 ) * distance;

                    _point.y = origin.y - Math.sin ( _angle * Math.PI / 180 ) * distance;


                return _point;
            }

            /**
             * Sets all event listeners for this object
             * @private
             * @function
             */
            _setEventListeners ( )
            {
                switch ( 'menu' )
                {
                    case 'menu':

                        this._setMenuPopup ( );


                        let _menu   = document.querySelector    ( '#input-menu' );

                        let _popups = document.querySelectorAll ( '.menu_popup > li' );


                        _menu.addEventListener ( 'click', ( ) => UI.toggle.labPopup ( '#input-menu', '.menu_popup' ) );


                        for ( let _popup of _popups )

                            _popup.addEventListener ( 'click', ( element ) => this._getMenuPopup ( element ) );

                    case 'grid':

                        let _grid = document.getElementById ( 'input-grid' );

                            _grid.addEventListener ( 'click', ( ) => UI.toggle.grid ( ) );

                    case 'coordinates':

                        let _coordinates = document.getElementById ( 'input-coordinates' );

                            _coordinates.addEventListener ( 'click', ( ) => UI.toggle.coordinates ( ) );

                    case 'angle':

                        let _angle = document.getElementById ( 'input-angle' );

                            _angle.addEventListener ( 'click', ( ) => UI.toggle.angle ( ) );

                    case 'sidebar':

                        let _sidebar = document.querySelector ( '#input-sidebar' );

                            _sidebar.addEventListener ( 'click', ( ) => UI.toggle.navigation ( ) );

                    case 'fullscreen':

                        let _fullscreen = document.querySelector ( '#input-full-screen' );

                            _fullscreen.addEventListener ( 'click', ( ) => UI.toggle.fullscreen ( ) );

                    case 'clearConsole':

                        let _clear = document.querySelector ( '#input-clear' );

                            _clear.addEventListener ( 'click', ( ) => UI.toggle.labButton ( _clear ) );

                    case 'timing':

                        this._setTimingPopup ( );


                        let _timing  = document.querySelector    ( '#input-timing' );

                        let _entries = document.querySelectorAll ( '.timing_popup > li' );


                        _timing.addEventListener ( 'click', ( ) => UI.toggle.labPopup ( '#input-timing', '.timing_popup' ) );


                        for ( let _entry of _entries )

                            _entry.addEventListener ( 'click', ( element ) => this._swapValue ( element, /ease(In|Out)\w+/, [ "'", "'" ] ) );

                    case 'fps':

                        let _fps = document.getElementById ( 'input-fps' );

                            _fps.addEventListener ( 'click', ( ) => UI.toggle.fps ( ) );

                    case 'gamepad':

                        let _gamepad = document.querySelector ( '#input-gamepad' );

                            _gamepad.addEventListener ( 'click', ( ) => UI.toggle.gamepad ( ) );

                    case 'boolean':

                        let _boolean = document.querySelector ( '#input-boolean' );

                            _boolean.addEventListener ( 'click', ( ) => UI.toggle.boolean ( ) );

                    case 'valuePlus':

                        let _valuePlus = document.querySelector ( '#input-value-plus' );

                            _valuePlus.addEventListener ( 'click', ( ) => this._setNumbericValue ( true ) );

                    case 'valueMinus':

                        let _minus = document.querySelector ( '#input-value-minus' );

                            _minus.addEventListener ( 'click', ( ) => this._setNumbericValue ( false ) );

                    case 'colorPicker':

                        let _colorPicker = this._getColorPicker ( 'input-color-picker' );

                            _colorPicker.onChange = ( element ) => this._swapValue ( element, /\d{1,3},\s\d{1,3},\s\d{1,3}(,\s\d)?/, [ "(", ")" ] )

                    case 'fontPlus':

                        let _fontPlus = document.querySelector ( '#input-font-plus' );

                            _fontPlus.addEventListener ( 'click', ( ) => this._setFontSize ( true ) );

                    case 'fontMinus':

                        let _fontMinus = document.querySelector ( '#input-font-minus' );

                            _fontMinus.addEventListener ( 'click', ( ) => this._setFontSize ( false ) );

                    case 'wordWrap':

                        let _wordWrap = document.querySelector ( '#input-word-wrap' );

                            _wordWrap.addEventListener ( 'click', ( ) =>
                                {
                                    let _wrapMode = this.editor.session.getUseWrapMode ( );


                                    ( _wrapMode ) ? this.editor.session.setUseWrapMode ( false )

                                                  : this.editor.session.setUseWrapMode ( true  );


                                    UI.toggle.labButton ( _wordWrap );
                                } );

                    case 'lock':

                        let _lock = document.querySelector ( '#input-lock' );

                        let _icon = _lock.querySelector    ( '.lock' );

                            _icon.addEventListener ( 'click', ( ) =>
                                {
                                    let _readOnly = this.editor.getReadOnly ( );


                                    ( _readOnly ) ? this.editor.setReadOnly ( false )

                                                  : this.editor.setReadOnly ( true  );


                                    ( _readOnly ) ? _icon.style.content = 'url("images/svg/General/unlock.svg")'

                                                  : _icon.style.content = 'url("images/svg/General/lock.svg")';


                                    UI.toggle.labButton ( _lock );
                                } );

                    case 'download':

                        let _download = document.querySelector ( '#input-download' );

                            _download.addEventListener ( 'click', ( ) => UI.toggle.download ( ) );

                    case 'output':

                        let _row    = document.querySelector ( '#output-row'    ).querySelector ( '.value' );

                        let _column = document.querySelector ( '#output-column' ).querySelector ( '.value' );

                        let _lines  = document.querySelector ( '#output-lines'  ).querySelector ( '.value' );


                        this.editor.session.selection.on ( 'changeCursor', ( event ) =>
                            {
                                let _cursor = this.editor.selection.getCursor ( );

                                    _row.innerHTML    = _cursor.row;

                                    _column.innerHTML = _cursor.column;

                                    _lines.innerHTML  = this.editor.session.getLength ( );
                            } );

                    case 'click':

                        let _mouseAngle       = document.querySelector ( '#input-angle' );

                        let _mouseCoordinates = document.querySelector ( '#input-coordinates' );


                        window.addEventListener ( 'mousedown', ( event ) =>
                        {
                            let _labColLeft = document.querySelector ( '#lab > div:nth-child(1)' );

                            let _navWidth   = ( UI._isNavOpen ( ) ) ? 225 : 0;


                            if ( _labColLeft.clientWidth + _navWidth > event.clientX  &&  _labColLeft.clientHeight > event.clientY )
                            {
                                if ( ! this.#mouse.click )
                                {
                                    this.#mouse.point = new Point ( event.clientX, event.clientY );

                                    this.#mouse.click = true;


                                    TOOL.delay ( 1000 ).then ( ( ) => this.#mouse.hold = true );
                                }
                            }
                        } );

                        window.addEventListener ( 'mouseup', ( event ) =>
                        {
                            let _labColLeft = document.querySelector ( '#lab > div:nth-child(1)' );

                            let _content    = '';


                            if ( _labColLeft.clientWidth + 225 > event.clientX  &&  _labColLeft.clientHeight > event.clientY )
                            {
                                if ( TOOL.isActive ( _mouseAngle ) )

                                    _content += JSON.stringify ( this._clipboard.angle );


                                if ( TOOL.isActive ( _mouseCoordinates ) )

                                    _content += '\n' + JSON.stringify ( this._clipboard.coordinates );


                                if ( this.#mouse.hold )
                                {
                                    let _degree   = this._getAngle ( this.#mouse.point, new Point ( event.clientX, event.clientY ) );

                                    let _distance = this._getDistance ( this.#mouse.point, new Point ( event.clientX, event.clientY ) );


                                    _content += '\n' + JSON.stringify ( this.#mouse.point );

                                    _content += '\n' + JSON.stringify ( { degree: _degree, distance: _distance } );


                                    this.#mouse.hold = false;
                                }


                                this._copyToClipboard ( _content );


                                this.#mouse.click = false;
                            }
                        } );

                    case 'keyboardCommands':

                        Mousetrap.bind ( 'space',     ( ) => this.runCode ( )          );

                        // Mousetrap.bind ( 'n',         ( ) => UI.toggle.navigation ( ) );

                        Mousetrap.bind ( ']',         ( ) => UI.toggle.fullscreen  ( ) );

                        Mousetrap.bind ( 'g',         ( ) => UI.toggle.grid ( ) );

                        Mousetrap.bind ( 'f',         ( ) => UI.toggle.fps ( ))

                        // Mousetrap.bind ( 'd',         ( ) => UI.toggle.download ( ) );

                        Mousetrap.bind ( 'c',         ( ) => UI.toggle.coordinates ( ) );

                        Mousetrap.bind ( 'n',         ( ) => UI.toggle.angle ( ) );

                        Mousetrap.bind ( 'g',         ( ) => UI.toggle.gamepad ( ) );
                }
            }

            /**
             * Sets the title of the current script being used within the lab environment
             * @private
             * @function
             * @param           {Function} script                   Script to identify
             */
            _setMenuScriptTitle ( script )
            {
                let _scripts = devSuite.getScripts ( );


                for ( let _script in _scripts )

                    if ( script === _scripts [ _script ] )

                        this._script.title = _script;
            }

            /**
             * Sets the font size within ace-editor up (+) or down (-)
             * @private
             * @function
             * @param           {boolean} up                        True (+) || false (-)
             */
            _setFontSize ( up = true )
            {
                let _size = document.getElementById ( this.editor.container.id ).style.fontSize;

                    _size = ( up ) ? Number ( _size.replace ( 'px', '' ) ) + 1

                                   : Number ( _size.replace ( 'px', '' ) ) - 1;


                document.getElementById ( this.editor.container.id ).style.fontSize = `${_size}px`;
            }

            /**
             * Sets numeric value within ace-editor up (+) or down (-)
             * @private
             * @function
             * @param           {boolean} up                        True (+) || false (-)
             */
            _setNumbericValue ( up = true )
            {
                let _cursor = this.editor.selection.getCursor ( );

                let _range  = this.editor.selection.getRange  ( );

                let _value  = this.editor.getSelectedText     ( );

                let _regex  = new RegExp ( /^\d+$/ );


                if ( _regex.test ( _value ) )
                {
                    _value = this._incrementValue ( _value, up );


                    this.editor.session.replace    ( _range, `${_value}` );

                    this.editor.selection.setRange ( _range );


                    this.runCode ( );
                }
            }

            /**
             * Sets the lab's menu items in relation to internal scripts
             * @private
             * @function
             */
            _setMenuPopup (  )
            {
                let _popup   = document.querySelector ( '.menu_popup' );

                let _scripts = devSuite.getScripts ( );

                let _show    = ( _popup.style.display === 'none' );


                if ( _show )

                    for ( let _script in _scripts )
                    {
                        let _title = _script.replace ( /([A-Z])/g, ' $1' ).trim ( );



                        let _li = document.createElement ( 'li' );

                            _li.innerHTML = _title;


                            _popup.appendChild ( _li );
                    }
            }

            /**
             * Sets the timing's menu items
             * @private
             * @function
             */
            _setTimingPopup (  )
            {
                let _popup   = document.querySelector ( '.timing_popup' );

                let _timings =
                [
                    'easeInSine',                     // IN
                    'easeInCubic',
                    'easeInQuint',
                    'easeInCirc',
                    'easeInElastic',
                    'easeInQuad',
                    'easeInQuart',
                    'easeInExpo',
                    'easeInBack',

                    'easeOutSine',                    // OUT
                    'easeOutCubic',
                    'easeOutQuint',
                    'easeOutCirc',
                    'easeOutElastic',
                    'easeOutQuad',
                    'easeOutQuart',
                    'easeOutExpo',
                    'easeOutBack',

                    'easeInOutSine',                  // INOUT
                    'easeInOutCubic',
                    'easeInOutQuint',
                    'easeInOutCirc',
                    'easeInOutElastic',
                    'easeInOutQuad',
                    'easeInOutQuart',
                    'easeInOutExpo',
                    'easeInOutBack',
                ]

                let _show    = ( _popup.style.display === 'none' );


                if ( _show )
                {
                    _popup.addEventListener ( 'mouseout', ( ) => UI.toggle.labPopup ( '#input-timing', '.timing_popup' ) );


                    for ( let _timing of _timings )
                    {
                        let _li = document.createElement ( 'li' );

                            _li.innerHTML = _timing;


                            _popup.appendChild ( _li );
                    }
                }
            }

            /**
             * Swap rgb values between color-picker and ace-editor
             * @private
             * @function
             * @param           {HTMLElement}    element            HTML DOM Element
             * @param           {regex}          regex              RegEx to match
             * @param           {Array.<string>} boundingCharacters Bounding characters around selection
             */
            _swapValue ( element, regex, boundingCharacters )
            {
                let _isColor = ( element.constructor.name === 'd' );

                let _value   = ( _isColor ) ? ` ${element._rgba [ 0 ]}, ${element._rgba [ 1 ]}, ${element._rgba [ 2 ]}, ${element._rgba [ 3 ]} `

                                            : element.srcElement.innerHTML;


                let _regex    = new RegExp ( regex );


                let _cursor   = this.editor.selection.getCursor ( );

                let _line     = this.editor.session.getLine ( _cursor.row );


                let _position = this._getBoundingCharactersPositions ( boundingCharacters, _line );

                let _range    = new ace.Range ( _cursor.row, _position.start, _cursor.row, _position.end );

                let _text     = this.editor.session.getTextRange ( _range ).trim ( );


                if ( _regex.test ( _text ) )
                {
                    _range = new ace.Range ( _cursor.row, 0, _cursor.row, _line.length );

                    _line  = _line.subStringRange ( _position.start, _position.end, _value );


                    this.editor.session.replace ( _range, _line );

                    this.editor.selection.moveCursorTo ( _cursor.row, _position.start + 1 );

                    this.runCode ( );
                }
                else

                    console.warn ( '[ lab-station ]: the appropriate value is not present within selection !' );
            }

        ////    PUBLIC    //////////////////////////////////

            /**
             * Returns most current time and updates FPS canvas chart
             * @public
             * @function
             * @param           {Date} timePast                     Date element for past time
             * @return          {Date}                              Date element for current time
             */
            getFps ( timePast )
            {
                let _timeCurrent = new Date ( );

                let _fps    = 1000 / ( _timeCurrent - timePast );

                let _green  = new Rgb ( 0, 255, 255 );

                let _blue   = new Rgb ( 0, 150, 255 );

                let _purple = new Rgb ( 255, 0, 255 );


                if ( VALIDATION.isInDom ( 'fps' ) )
                {
                    let _fpsCanvas  = document.getElementById ( 'fps' );

                    let _fpsContext = _fpsCanvas.getContext ( '2d', { willReadFrequently: true } );

                    // SHIFT EVERYTHING TO THE LEFT
                    let _imageData = _fpsContext.getImageData ( 1, 0, _fpsCanvas.width, _fpsCanvas.height );

                        _fpsContext.putImageData ( _imageData, 0, 0 );

                        _fpsContext.clearRect ( 0, 0, 1, _fpsCanvas.height );


                    // FPS Line
                    let _line = new Line ( new Point ( 0, 0 ), new Point ( 1, 0 ) );

                        _line.canvas = 'fps';

                        _line.stroke.color = _purple;


                        [ _line.x, _line.y ] = [ _fpsCanvas.width - 2, _fps ];


                        _line.draw ( );


                    // 30 & 60 Line metrics
                    let _line30 = new Line ( new Point ( 0, 0 ), new Point ( 1, 0 ) );

                    let _line60 = new Line ( new Point ( 0, 0 ), new Point ( 1, 0 ) );


                        _line30.canvas = _line60.canvas = 'fps';

                        _line30.x      = _line60.x      = _fpsCanvas.width;

                        [ _line30.y,            _line60.y            ] = [ 30,     60    ];

                        [ _line30.stroke.color, _line60.stroke.color ] = [ _green, _blue ];


                        _line30.draw ( );

                        _line60.draw ( );


                    return _timeCurrent;
                }
            }

            /**
             * Loads a script within ace-editor
             * @public
             * @function
             * @param           {function} script                   Arrow function containing script
             */
            loadScript ( script )
            {
                let _id = "ace-editor";

                ////    CONTROL PANEL    ///////////////////////////////////////////

                    let _controlPanel       = document.querySelector ( '#control-panel' );

                    let _controlPanelHeight = window.getComputedStyle ( _controlPanel ).height;

                        _controlPanelHeight = Number ( _controlPanelHeight.replace ( 'px', '' ) );

                ////    EDITOR ELEMENT    //////////////////////////////////////////

                    let _padding       = 23;

                    let _editorElement = document.getElementById ( _id );

                        _editorElement.style.height = `${window.innerHeight - _controlPanelHeight + _padding}px`;

                ////    EDITOR    //////////////////////////////////////////////////

                    this.editor = ace.edit ( _id );

                    this.editor.setValue ( this._cleanCode ( script ) );

                    this.editor.setTheme ( "ace/theme/tomorrow_night" );

                    this.editor.session.setMode ( "ace/mode/javascript" );

                    this.editor.session.setTabSize ( 4 );

                    this.editor.session.setUseSoftTabs ( true );

                    this.editor.session.setUseWrapMode ( false );

                ////    OPTIONS    /////////////////////////////////////////////////

                    this.editor.setOptions (
                        {
                            autoScrollEditorIntoView:   true,
                            copyWithEmptySelection:     true,
                            mergeUndoDeltas:            'always',
                            enableMultiselect:          true,
                            fadeFoldWidgets:            true
                        } );

                    this.editor.commands.addCommand (
                        {
                            name:    'run_on_save',
                            bindKey: { win: 'Ctrl-S', mac: 'Command-S' },
                            exec:    ( ) => devSuite.runLabStationCode ( )
                        } );

                    this.editor.commands.addCommand (
                        {
                            name:    'multi_select',
                            bindKey: { win: 'Ctrl-D', mac: 'Command-D' },
                            exec:    ( editor ) => editor.commands.byName.selectMoreAfter.exec ( editor )
                        } );

                    this.editor.commands.addCommand (
                        {
                            name:    'fold_code',
                            bindKey: { win: 'Ctrl-;', mac: 'Command-;' },
                            exec:    ( editor ) => editor.commands.byName.foldall.exec ( editor )
                        } );

                ////    ANCILLARY    ///////////////////////////////////////////////

                    this._setMenuScriptTitle ( script );
            }

            /**
             * Executes lab code from editor
             * @public
             * @function
             */
            runCode ( )
            {
                let _code    = this.editor.getValue ( );

                let _canvas  = document.querySelector ( '#canvas' );

                let _context = canvas.getContext ( '2d' );

                    _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                let _clear   = document.querySelector ( '#input-clear' );


                if ( TOOL.isActive ( _clear ) )

                    console.clear ( );


                this._clearExistingAnimations ( );

                eval ( _code );
            }

            /**
             * Returns an object of lab-station specific scripts
             * @public
             * @function
             */
            get scripts ( )
            {
                return this._scripts;
            }

            /**
             * Sets angle overlay
             * @public
             * @function
             */
            setAngle ( )
            {
                let _existing = document.getElementById ( 'angle' );


                if ( _existing )

                    _existing.remove ( );

                ////    INSERT ANGLE    ////////////////////////////////////////////

                    let _parent  = document.querySelector ( '#lab > div:nth-child(1)' );

                    let _canvas  = document.querySelector ( '#canvas' );

                    let _angle   = document.createElement ( 'canvas' );

                    let _context = _angle.getContext ( '2d' );


                    [ _angle.id, _angle.width, _angle.height ] = [ 'angle', _canvas.clientWidth, _canvas.clientHeight ];


                        _parent.insertBefore ( _angle, _canvas );

                ////    OUTPUT    //////////////////////////////////////////////////

                    let _mouseAngle    = document.querySelector ( '#mouse-angle > .cartesian > .angle' );

                    let _mouseDistance = document.querySelector ( '#mouse-angle > .cartesian > .distance' );

                ////    DISPLAY    /////////////////////////////////////////////////

                    let _id       = 'angle';

                    let _navWidth = 225;

                    let _color    = new Rgb ( 0, 175, 125, 1 );


                    let _line = new Line;

                    let _circle = new Circle;

                    let _dotCircle = new Circle;

                    let _centerCircle = new Circle;


                        _line.stroke.color = _circle.fill.color = _dotCircle.fill.color = _centerCircle.stroke.color = _color;


                        [ _line.stroke.type, _line.stroke.segments, _line.stroke.width ] = [ 'dashed', [ 3, 3 ], 1 ];


                        _circle.stroke.color.alpha = _dotCircle.stroke.color.alpha = 0;

                ////    EVENT LISTENER    //////////////////////////////////////////

                    window.addEventListener ( 'mousemove', ( event ) =>
                    {
                        let _x = ( UI._isNavOpen ( ) ) ? event.clientX - _navWidth : event.clientX;

                        let _y = event.clientY;


                        let _degree         = this._getAngle    ( canvaslab.center, new Point ( _x, _y ) );

                        let _distance       = this._getDistance ( canvaslab.center, new Point ( _x, _y ) );


                        let _circleDistance = this._getDistance ( canvaslab.center, new Point ( _x, _y ) ) / 3.3;

                        let _endPoint       = this._rotatePoint ( canvaslab.center, _degree, _circleDistance );


                        let _dotDistance    = this._getDistance ( canvaslab.center, new Point ( _x, _y ) ) / 3.05;

                        let _dotPoint       = this._rotatePoint ( canvaslab.center, _degree, _dotDistance );

                        ////    SET    /////////////////////////////////////////////

                        [ _line.start,         _line.end            ] = [ canvaslab.center, _endPoint            ];

                        [ _circle.point,       _circle.radius       ] = [ _endPoint,        _circleDistance / 30 ];

                        [ _dotCircle.point,    _dotCircle.radius    ] = [ _dotPoint,        _dotDistance    / 50 ];

                        [ _centerCircle.point, _centerCircle.radius ] = [ canvaslab.center, _circleDistance / 2  ];

                        ////    DRAW    ////////////////////////////////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );


                        _line.draw ( _id );

                        _circle.draw ( _id );

                        _dotCircle.draw ( _id );

                        _centerCircle.draw ( _id );

                        ////    MEASURING LINE    //////////////////////////////////

                        if ( this.#mouse.click )
                        {
                            let _point = ( UI._isNavOpen ( ) ) ? new Point ( this.#mouse.point.x - _navWidth, this.#mouse.point.y )

                                                               : this.#mouse.point;


                            let _lineDegree   = this._getAngle    ( _point, new Point ( _x, _y ) );

                            let _lineDistance = this._getDistance ( _point, new Point ( _x, _y ) );


                            let _circle = new Circle ( _point, 7 );

                            let _line   = new Line ( _point, new Point ( _x, _y ) );


                                _line.stroke.type = 'dashed';


                                _line.draw ( _id );

                                _circle.draw ( _id );


                            [ _mouseAngle.innerHTML, _mouseDistance.innerHTML ] = [ Math.round ( _lineDegree ) + '째', Math.round ( _lineDistance ) + ' <i>d</i>' ];
                        }
                        else

                            [ _mouseAngle.innerHTML, _mouseDistance.innerHTML ] = [ Math.round ( _degree ) + '째', Math.round ( _distance ) + ' <i>d</i>' ];


                        ////    CLIPBOARD    ///////////////////////////////////////

                        this._clipboard.angle.degree   = `${_degree}째`;

                        this._clipboard.angle.distance = `${_distance} d`;
                    } );
            }

            /**
             * Sets fps overlay
             * @public
             * @function
             */
            setFps ( )
            {
                let _existing = document.getElementById ( 'fps' );


                if ( _existing )

                    _existing.remove ( );

                ////    INSERT ANGLE    ////////////////////////////////////////////

                    let _parent  = document.querySelector ( '#lab > div:nth-child(1)' );

                    let _canvas  = document.querySelector ( '#canvas' );

                    let _fps     = document.createElement ( 'canvas' );

                    let _context = _fps.getContext ( '2d' );


                    [ _fps.id, _fps.width, _fps.height ] = [ 'fps', _canvas.clientWidth, 80 ];


                        _parent.insertBefore ( _fps, _canvas );
            }

            /**
             * Sets the lab's canvas
             * @private
             * @async
             * @function
             */
            async setCanvasSize ( )
            {
                let _canvas  = document.querySelector ( '#canvas' );

                let _wrapper = document.querySelector ( '#lab > div:nth-child(1)' );


                [ _canvas.width, _canvas.height ] = [ _wrapper.clientWidth, _wrapper.clientHeight ]
            }

            /**
             * Sets coordinates overlay
             * @public
             * @function
             */
            setCoordinates ( )
            {
                let _existing = document.getElementById ( 'coordinates' );


                if ( _existing )

                    _existing.remove ( );

                ////    INSERT COORDINATES    //////////////////////////////////////

                    let _parent      = document.querySelector ( '#lab > div:nth-child(1)' );

                    let _canvas      = document.querySelector ( '#canvas' );

                    let _coordinates = document.createElement ( 'canvas' );

                    let _context     = _coordinates.getContext ( '2d' );


                    [ _coordinates.id, _coordinates.width, _coordinates.height ] = [ 'coordinates', _canvas.clientWidth, _canvas.clientHeight ];


                        _parent.insertBefore ( _coordinates, _canvas );

                ////    OUTPUT    //////////////////////////////////////////////////

                    let _displayX   = document.querySelector ( '#mouse-coordinates > .display > .x' );

                    let _displayY   = document.querySelector ( '#mouse-coordinates > .display > .y' );

                    let _cartesianX = document.querySelector ( '#mouse-coordinates > .cartesian > .x' );

                    let _cartesianY = document.querySelector ( '#mouse-coordinates > .cartesian > .y' );

                    let _centerX    = document.querySelector ( '#mouse-coordinates > .center > .x' );

                    let _centerY    = document.querySelector ( '#mouse-coordinates > .center > .y' );

                ////    DISPLAY    /////////////////////////////////////////////////

                    let _id       = 'coordinates';

                    let _color    = new Rgb ( 255, 0, 0 );

                    let _navWidth = 225;

                    let _gap      = 15;


                    let _lineXOne = new Line;

                    let _lineYOne = new Line;

                    let _lineXTwo = new Line;

                    let _lineYTwo = new Line;


                        _lineXOne.stroke.color = _lineYOne.stroke.color = _lineXTwo.stroke.color = _lineYTwo.stroke.color = _color;

                ////    EVENT LISTENER    //////////////////////////////////////////

                    window.addEventListener ( 'mousemove', ( event ) =>
                    {
                        let _x = ( UI._isNavOpen ( ) ) ? event.clientX - _navWidth : event.clientX;

                        let _y = event.clientY;


                        let _display   = new Point ( _x, _y );

                        let _cartesian = new Point ( _x - canvaslab.center.x, canvaslab.center.y - _y );

                        let _center    = new Point ( canvaslab.center.x, canvaslab.center.y );

                        ////    SET    /////////////////////////////////////////////

                        [ _lineXOne.start, _lineXOne.end ] = [ new Point ( 0, _y ),         new Point ( _x - _gap, _y  )          ];

                        [ _lineXTwo.start, _lineXTwo.end ] = [ new Point ( _x + _gap, _y ), new Point ( _coordinates.width, _y  ) ];


                        [ _lineYOne.start, _lineYOne.end ] = [ new Point ( _x, 0 ),         new Point ( _x, _y - _gap )           ];

                        [ _lineYTwo.start, _lineYTwo.end ] = [ new Point ( _x, _y + _gap ), new Point ( _x, _coordinates.height ) ];

                        ////    DRAW    ////////////////////////////////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );


                        _lineXOne.draw ( _id );

                        _lineYOne.draw ( _id );

                        _lineXTwo.draw ( _id );

                        _lineYTwo.draw ( _id );

                        ////    DISPLAY    /////////////////////////////////////////

                        [ _displayX.innerHTML,   _displayY.innerHTML   ] = [ _x,                 _y                 ];

                        [ _cartesianX.innerHTML, _cartesianY.innerHTML ] = [ _cartesian.x,       _cartesian.y       ];

                        [ _centerX.innerHTML,    _centerY.innerHTML    ] = [ canvaslab.center.x, canvaslab.center.y ];

                        ////    CLIPBOARD    ///////////////////////////////////////

                        this._clipboard.coordinates =
                        {
                            display:   _display,
                            cartesian: _cartesian,
                            center:    _center
                        }
                    } );
            }

            /**
             * Sets grid overlay
             * @public
             * @function
             */
            setGrid ( )
            {
                let _existing = document.getElementById ( 'grid' );


                if ( _existing )

                    _existing.remove ( );

                ////    INSERT GRID    /////////////////////////////////////////////

                    let _parent      = document.querySelector ( '#lab > div:nth-child(1)' );

                    let _canvas      = document.querySelector ( '#canvas' );

                    let _grid        = document.createElement ( 'canvas' );


                    [ _grid.id, _grid.width, _grid.height ] = [ 'grid', _canvas.clientWidth, _canvas.clientHeight ];


                        _parent.insertBefore ( _grid, _canvas );

                ////    DRAW GRID    ///////////////////////////////////////////////

                    let _multiplier      = 20;

                    let _center          = { x: _grid.clientWidth / 2, y: _grid.clientHeight / 2 }

                    let _centerLines     = new Lines;

                    let _horizontalLines = new Lines;

                    let _verticalLines   = new Lines;

                ////    CENTER LINES    ////////////////////////////////////////////

                    _centerLines.push ( new Line ( { x: _center.x, y: 0         }, { x: _center.x,         y: _grid.clientHeight } ) );

                    _centerLines.push ( new Line ( { x: 0,         y: _center.y }, { x: _grid.clientWidth, y: _center.y          } ) );

                ////    HORIZONTAL LINES    ////////////////////////////////////////

                    let _y = _center.y - _multiplier;


                    while ( _y > 0 )
                    {
                        _horizontalLines.push ( new Line ( { x: 0, y: _y }, { x: _grid.clientWidth, y: _y } ) )

                        _y = _y - _multiplier;
                    }


                        _y = _center.y + _multiplier;

                    while ( _y < _grid.height )
                    {
                        _horizontalLines.push ( new Line ( { x: 0, y: _y }, { x: _grid.clientWidth, y: _y } ) );

                        _y = _y + _multiplier;
                    }

                ////    VERTICAL LINES    //////////////////////////////////////////

                    let _x = _center.x - _multiplier;


                    while ( _x > 0 )
                    {
                        _verticalLines.push ( new Line ( { x: _x, y: 0 }, { x: _x, y: _grid.clientHeight } ) );

                        _x = _x - _multiplier;
                    }


                        _x = _center.x + _multiplier;

                    while ( _x < _grid.width )
                    {
                        _verticalLines.push ( new Line ( { x: _x, y: 0 }, { x: _x, y: _grid.clientHeight } ) );

                        _x = _x + _multiplier;
                    }

                ////    DRAW    ////////////////////////////////////////////////////

                    _centerLines.stroke.color = new Rgb ( 255, 0, 0, 0.8 );

                    _centerLines.draw ( 'grid' );


                    _horizontalLines.stroke.color = new Rgb ( 0, 0, 0, 0.25 );

                    _horizontalLines.draw ( 'grid' );


                    _verticalLines.stroke.color = new Rgb ( 0, 0, 0, 0.25 );

                    _verticalLines.draw ( 'grid' );
            }

            /**
             * Sets lab default options
             * @public
             * @function
             * @param           {Array.<string>} defaults           Array of default options
             */
            setLabDefaults ( defaults )
            {
                let _defaults = ( defaults === undefined ) ? [ 'sidebar', /* 'grid', 'clear', 'coordinates', 'angle' */ ]

                                                           : defaults;


                for ( let _type of _defaults )
                {
                    let _input = document.getElementById ( `input-${_type}` );


                    if ( ! TOOL.isActive ( _input ) )

                        _input.click ( );

                    else

                        continue;

                }
            }

    ////    INITIALIZER    /////////////////////////////////////////////////////

        /**
         * Sets lab & ace-editor
         * @public
         * @function
         * @param           {function} script                   Arrow function containing script
         */
        init ( script )
        {
            if ( script )

                this.loadScript ( script );


            this._setEventListeners ( );
        }
}
 
/**
 * @class           {Object} Log                        Log class
 * @property        {string} entries                    Log entries
 */
class Log
{
    _entries = new Array;

    constructor ( )
    {
        this.entry ( 'CREATION' );
    }

    ////    PROPERTIES    //////////////////////////////////////////////////////

        ////    [ ENTRIES ]    /////////////////////////////

            /**
             * Gets entries
             * @public
             * @function
             * @return          {string}                            Page's entries
             */
            get entries ( )
            {
                return this._entries;
            }

    ////    [ UTILITIES ]    ///////////////////////////////////////////////////

        ////    PRIVATE    /////////////////////////////////

            /**
             * Returns a current timestamp
             * @private
             * @function
             * @return          {string}                            Timestamp
             */
            _timestamp ( )
            {
                let _date = new Date ( );

                let _time = ( _date.getMonth        ( ) + 1 ) + "/"
                            + _date.getDate         ( ) + "/"
                            + _date.getFullYear     ( ) + " @ "
                            + _date.getHours        ( ) + ":"
                            + _date.getMinutes      ( ) + ":"
                            + _date.getSeconds      ( ) + ":"
                            + _date.getMilliseconds ( );


                return _time;
            }

        ////    PUBLIC    //////////////////////////////////

            /**
             * Sets a single entry with the passed message param
             * @public
             * @function
             * @param           {string} message                    Message for log entry
             */
            entry ( message )
            {
                let _timestamp = `[ ${this._timestamp ( )} ]`;

                let _entry     = ( typeof message === 'string' ) ? `${_timestamp} => ${message}`

                                                                 : _timestamp;


                this._entries.push ( _entry );
            }

            /**
             * View all entries
             * @public
             * @function
             */
            view ( )
            {
                for ( let _entry of this.entries )

                    console.log ( _entry );
            }
}
 
/**
 * @class           {Object} Page                       Page for parsing page types
 * @property        {string} type                       Page's type
 * @property        {string} group                      Page's group
 * @property        {string} handler                    Page's handler
 */
class Page
{
    _type    = undefined;
    _group   = undefined;
    _handler = undefined;

    /**
     * Creates a page
     * @property        {HTMLElement} button                HTML DOM Element
     */
    constructor ( button )
    {
        if ( button ) this._setPropertiesBy ( button )
    }

    ////    PROPERTIES    //////////////////////////////////////////////////////

        ////    [ PAGE ]    ////////////////////////////////

            /**
             * Sets type
             * @public
             * @function
             * @param           {string} value                      Page's type
             */
            set type ( value )
            {
                this._type = ( typeof value === 'string' ) ? value : this._type;
            }

            /**
             * Gets type
             * @readOnly
             * @function
             * @return          {string}                            Page's type
             */
            get type ( )
            {
                return this._type;
            }

        ////    [ GROUP ]    ///////////////////////////////

            /**
             * Sets group
             * @public
             * @function
             * @param           {string} value                      Page's group
             */
            set group ( value )
            {
                this._group = ( typeof value === 'string' ) ? value : this._group;
            }

            /**
             * Gets group
             * @readOnly
             * @function
             * @return          {string}                            Page's group
             */
            get group ( )
            {
                return this._group;
            }

        ////    [ HANDLER ]    /////////////////////////////

            /**
             * Sets handler
             * @public
             * @function
             * @param           {string} value                      Page's handler
             */
            set handler ( value )
            {
                this._handler = ( typeof value === 'string' ) ? value : this._handler;
            }

            /**
             * Gets handler
             * @readOnly
             * @function
             * @return          {string}                            Page's handler
             */
            get handler ( )
            {
                return this._handler;
            }

    ////    UTILITIES    ///////////////////////////////////////////////////////

        /**
         * Sets all properties by the passed 'button' param
         * @private
         * @function
         * @param           {HTMLElement} button                HTML DOM Element
         */
        _setPropertiesBy ( button )
        {
            let _match = button.href.match ( /#(\w+)/g ) [ 0 ];

            let _regex =
            {
                group:   new RegExp ( /(Object|Subject|Template)/  ),

                handler: new RegExp ( /(Processing|Animation)/ )
            }


            if ( _match || typeof button === 'object' )
            {
                let _button  = _match.replace ( '#', '' );


                this.handler = ( _regex.handler.test ( _button ) ) ? _button.match ( _regex.handler ) [ 0 ].toLowerCase ( ) : this.handler;

                this.group   = _button.match ( _regex.group ) [ 0 ].toLowerCase ( );

                this.type    = ( this.handler ) ? _button.replace ( this.group.toTitleCase ( ), '' ).replace ( this.handler.toTitleCase ( ), '' ).toLowerCase ( ) : _button.replace ( this.group.toTitleCase ( ), '' ).toLowerCase ( );

                this.type    = ( this.type === 'cimage'            ) ? 'cImage'            : this.type;

                this.type    = ( this.type === 'roundedrectangle'  ) ? 'roundedRectangle'  : this.type;

                this.type    = ( this.type === 'roundedrectangles' ) ? 'roundedRectangles' : this.type;
            }
        }
}
 
/**
 * @class           {Object} Template                   HTML card template for UI
 * @property        {string} standard                   Standard HTML card template
 * @property        {string} blank                      Blank HTML card template
 */
class Template
{
    _types =
    {
        standard: `<div class="col">

                       <div class="card" id="view_{{index}}" suite-data-code="{{code}}" suite-data-title="{{title}}" onclick="devSuite.toggleCardButton ( event )">

                           <div class="card-header">

                               <div class="card-header-buttons">

                                   <div class="icons">

                                       <img src="images/svg/{{childGroup}}/{{childType}}.svg" class="card-icons" suite-button-type="documentation" suite-data-type="{{childType}}" onclick="devSuite.toggleCardButton ( event )">

                                       <img src="images/svg/{{childGroup}}/{{childType}}.svg" class="card-icons" suite-button-type="documentation" suite-data-type="{{childType}}" onclick="devSuite.toggleCardButton ( event )">

                                       <img src="images/svg/{{childGroup}}/{{childType}}.svg" class="card-icons" suite-button-type="documentation" suite-data-type="{{childType}}" onclick="devSuite.toggleCardButton ( event )">

                                       <img src="images/svg/{{childGroup}}/{{childType}}.svg" class="card-icons" suite-button-type="documentation" suite-data-type="{{childType}}" onclick="devSuite.toggleCardButton ( event )">

                                       <img src="images/svg/{{childGroup}}/{{childType}}.svg" class="card-icons" suite-button-type="documentation" suite-data-type="{{childType}}" onclick="devSuite.toggleCardButton ( event )">

                                       <img src="images/svg/{{childGroup}}/{{childType}}.svg" class="card-icons" suite-button-type="documentation" suite-data-type="{{childType}}" onclick="devSuite.toggleCardButton ( event )">

                                   </div>

                               </div>

                               <div class="card-number">

                                   <span class="close"></span>

                                   <span class="number">{{index}}</span>

                               </div>

                           </div> <!-- .card-header -->


                           <div class="card-body-lab">

                               <img src="images/svg/General/lab-bottle-black.svg" suite-data-code="{{code}}" class="lab-bottle" onclick="devSuite.toggleLab ( event )">

                           </div> <!-- .card-body-lab -->


                           <canvas id="canvas_{{index}}"></canvas>


                           <div class="card-body">

                               <div class="title">{{title}}</div>

                               <div class="card-body-buttons">

                                   <span class="icons">

                                       <img src="images/svg/{{easing}}.svg" class="card-icons easing" suite-button-type="easing" suite-data-index="{{index}}" onclick="devSuite.toggleCardButton ( event )">

                                       <span class="wall">&nbsp;</span>

                                       <img src="images/svg/Handler/{{handler}}.svg" class="card-icons" suite-button-type="documentation" suite-data-type="{{handler}}"  onclick="devSuite.toggleCardButton ( event )">

                                       <img src="images/svg/{{group}}/{{type}}.svg" class="card-icons" suite-button-type="documentation" suite-data-type="{{type}}" onclick="devSuite.toggleCardButton ( event )">

                                   </span>

                               </div>

                           </div> <!-- .card-body -->

                       </div>

                    </div>  <!-- .col -->`,

        blank:    `<div class="col blank">

                       <div class="card blank" onclick="devSuite.toggleCardButton ( event )">

                           <span class="plus">+</span>

                       </div>

                   </div>  <!-- .col -->`
    }

    _initializer =
    {
        object:
        {
            Line:              '{ x: 100, y: 50 }, { x: 200, y: 100 }',
            Lines:             '{ x: 0, y: 0 }',
            Circle:            '{ x: 154, y: 77 }',
            Circles:           '{ x: 50, y: 10 }',
            Ellipse:           '{ x: 154, y: 77 }',
            Ellipses:          '{ x: 50, y: 10 }',
            Rectangle:         '{ x: 154, y: 77 }',
            Rectangles:        '{ x: 50, y: 10 }',
            RoundedRectangle:  '{ x: 154, y: 77 }',
            RoundedRectangles: '{ x: 50, y: 10 }',
            Text:              '{ x: 154, y: 77 }, \'Text\'',
            Texts:             '{ x: 50, y: 10 }',
            Image:             '\'images/png/moon.png\', { point: new Point ( 154, 65 ), aspect: new Aspect }',
            Group:             '{ x: 20, y: 0 }',
        },
        subject:
        {
            Line:             '{ x: 100, y: 50 }, { x: 200, y: 100 }',
            Circle:           '{ x: 154, y: 77 }',
            Ellipse:          '{ x: 154, y: 77 }',
            Rectangle:        '{ x: 154, y: 77 }',
            RoundedRectangle: '{ x: 154, y: 77 }',
            Text:             '{ x: 154, y: 77 }, \'Text\'',
            Image:            '\'images/png/moon.png\', { point: new Point ( 154, 65 ), aspect: new Aspect }',
        },
        animation:
        {
            Line:             '{ x: 100, y: 50 }, { x: 200, y: 100 }',
            Circle:           '{ x: 154, y: 77 }',
            Ellipse:          '{ x: 154, y: 77 }',
            Rectangle:        '{ x: 154, y: 77 }',
            RoundedRectangle: '{ x: 154, y: 77 }',
            Text:             '{ x: 154, y: 77 }, \'Text\'',
            Image:            '\'images/png/moon.png\', { point: new Point ( 154, 65 ), aspect: new Aspect }',
        }
    }

    constructor ( ) { }

    ////    PROPERTIES    //////////////////////////////////////////////////////

        ////    [ STANDARD ]    ////////////////////////////

            /**
             * Returns a standard HTML card template
             * @readOnly
             * @function
             * @return          {string}                            HTML card standard template
             */
            get standard ( ) { return this._types.standard; }

        ////    [ BLANK ]    ///////////////////////////////

            /**
             * Returns a blank HTML card template
             * @readOnly
             * @function
             * @return          {string}                            HTML card blank template
             */
            get blank ( ) { return this._types.blank; }

    ////    UTILITIES    ///////////////////////////////////////////////////////

        ////    PRIVATE    /////////////////////////////////

            /**
             * Cleans count duplicates (i.e. _00_00... to _00)
             * @private
             * @function
             * @param           {string} code                       Card-object's function
             * @param           {string} count                      Number for unique variable identifiers
             */
            _cleanCountDuplicates ( code, count )
            {
                let _regex = new RegExp ( /_\d{2}_\d{2}/g );


                while ( code.match ( _regex ) )

                    code = code.replace ( _regex, `_${count}` );


                return code;
            }

            /**
             * Returns the amount of extra cards to embed
             * @private
             * @function
             * @param           {Array.<Object>} cardObjects        Array of card-objects
             * @return          {number}                            Amount of extra cards
             */
            _getBlankCount ( cardObjects )
            {
                let _count     = this._getColumnCount ( );

                let _remainder = cardObjects.length % _count;


                return _count - _remainder;
            }

            /**
             * Returns an Array of extra HTML templates; to align cards
             * @private
             * @function
             * @param           {Array.<Object>} cardObjects        Array of card-objects
             * @return          {Array}                             Array of extra HTML templates for each card-object
             */
            _getBlankTemplates ( cardObjects )
            {
                let _cards = [ ];


                let _columns = this._getColumnCount ( );

                let _blanks  = this._getBlankCount  ( cardObjects );


                if ( _columns != _blanks )                      // Blank templates to fill out row of standard templates

                    for ( let _i = 0; _i < _blanks; _i++ )

                        _cards.push ( TEMPLATE.blank );


                if ( _blanks % _columns === 0 )                 // Blank templates for next row, from adding new standard templates; @see UI._cardPlus ( )

                    for ( let _i = 0; _i < _columns; _i++ )

                        _cards.push ( TEMPLATE.blank );


                return _cards;
            }

            /**
             * Returns rendered HTML for a card-object
             * @private
             * @function
             * @param           {Object} cardObject                 Card-object
             * @param           {string} template                   HTML card template
             * @param           {string} count                      Card-object number
             * @return          {string}                            HTML card template
             */
            _getCodeTemplate ( cardObject, template, count )
            {
                for ( let _entry in cardObject )
                {
                    if ( _entry === 'code' )

                        cardObject [ _entry ] = ( PAGE.group === 'template' ) ? this._modifyTemplateCode ( cardObject [ _entry ], count )

                                                                              : this._modifyCode ( cardObject [ _entry ], count );


                    let _regex = new RegExp ( `{{${_entry}}}`, 'g' );


                    template = template.replace ( _regex, cardObject [ _entry ] );
                }


                return template;
            }

            /**
             * Returns the amount of columns available per the present resolution
             * @private
             * @function
             * @return          {number}                            Number of columns
             */
            _getColumnCount ( )
            {
                let _count       = 1;

                let _breakpoints = [ 600, 800, 1200, 1500, 1800, 2100, 2600 ];

                let _windowWidth = window.innerWidth;


                for ( let _breakpoint of _breakpoints )
                {
                    if ( _windowWidth < _breakpoint )

                        return _count;


                    _count++;
                }
            }

            /**
             * Return a template with the appropriate canvasLab images embedded
             * @private
             * @param           {Object} cardObject                 Card-object
             * @param           {string} template                   HTML card template
             */
            _getImages ( cardObject, template )
            {
                this._setImagePaths ( cardObject );


                if ( cardObject.images )

                    for ( let _entry in cardObject.images )
                    {
                        let _type = cardObject.images [ _entry ];

                            _type = ( _type === 'Cimage' ) ? 'cImage' : _type;


                        switch ( _entry )
                        {
                            case 'easing':      template = template.replace ( /{{easing}}/, _type );                                            break;

                            case 'handler':     template = template.replace ( /{{handler}}/, _type ).replace ( /{{handler}}/, _type );          break;

                            case 'children':

                                for ( let _childType of _type )
                                {
                                        _childType  = ( _childType === 'Cimage' ) ? 'cImage' : _childType;

                                    let _childGroup = TOOL.isCanvasLabObject ( _childType ) ? 'Object' : 'Subject';

                                    template        = template.replace ( /{{childGroup}}/, _childGroup ).replace ( /{{childType}}/, _childType ).replace ( /{{childType}}/, _childType );
                                }

                                break;

                            default:

                                let _group = ( PAGE.group === 'template' ) ? 'Template' : TOOL.isCanvasLabObject ( _type ) ? 'Object' : 'Subject';

                                template   = template.replace ( /{{group}}/, _group ).replace ( /{{type}}/, _type ).replace ( /{{type}}/, _type );
                        }
                    }


                // If no children, place slash-square symbol
                template = ( ! cardObject.images.children ) ? template.replace ( /{{childGroup}}/, 'General' ).replace ( /{{childType}}/, 'slash-square' ).replace ( /{{childType}}/, 'Base' ) : template;


                // Clean remaining unused image tags
                template = template.replaceAll ( new RegExp ( '<img src="images/svg(/Handler)?/{{[^>]+>', 'g' ), '' );


                return template;
            }

            /**
             * Returns an Array of standard HTML templates for each card-object
             * @private
             * @function
             * @param           {Array.<Object>} cardObjects        Array of card-objects
             * @return          {Array}                             Array of standard HTML templates for each card-object
             */
            _getStandardTemplates ( cardObjects )
            {
                let _cards = [ ];


                for ( let _iter in cardObjects )
                {
                    let _index      = _iter.to2Digits ( );

                    let _cardObject = cardObjects [ _iter ];


                    let _template = this.standard.replace ( /{{index}}/g, _index );

                        _template = this._getImages ( _cardObject, _template );


                    _cards.push ( this._getCodeTemplate ( _cardObject, _template, _index ) );
                }


                return _cards;
            }

            /**
             * Returns a code string with special variable formatting
             * @private
             * @function
             * @param           {string} code                       Code as a string
             * @param           {number} count                      Card-object number
             * @return          {string}                            Code string with special variable formatting
             */
            _getSpecialVariables ( code, count )
            {
                let _specials = [ '_transition' ];


                for ( let _special of _specials )
                {
                    let _regex = new RegExp ( _special, 'g' );


                    if ( _regex.test ( code ) )
                    {
                        switch ( _special )
                        {
                            case '_transition':

                                let _lineIndex = /let\s_transition[^=]+=/g.exec ( code ).index;

                                let _headCode  = code.substring ( 0, _lineIndex ).trim ( ) + '\n\n';

                                let _temp      = code.match ( /let\s_transition[^,]+,[^,]+[^}]+}[^}]+}[^\w]+canvaslab[^;]+;/g ) [ 0 ].split ( '\n' );


                                for ( let _index in _temp )

                                    _temp [ _index ] = ( _index > 0 ) ? _temp [ _index ].slice ( 4 )

                                                                      : _temp [ _index ]


                                code = _headCode + _temp.join ( '\n' );


                                break;
                        }


                        code = code.replace ( _regex, `${_special}_${count}` );
                    }
                }


                return code;
            }

            /**
             * Match variables via the passed lines & regex params
             * @private
             * @function
             * @param           {RegEx}          regex              Regex to match
             * @param           {Array.<string>} lines              Lines of code to match
             * @param           {string}         count              Number for unique variable identifiers
             */
            _matchVariables ( regex, lines, count )
            {
                for ( let _index in lines )
                {
                    let _line = lines [ _index ];

                    let _match = _line.match ( /_\w+/ );

                        _match = ( _match ) ? _match [ 0 ] : undefined;


                    if ( regex.test ( _line ) )
                    {
                        let _matches = _line.match ( /_\w+/g );


                        for ( let _match of _matches )

                            _line = this._modifyVariables ( _line, _match, count );

                    }
                    else if ( _match )

                        _line = this._modifyVariables ( _line, _match, count );


                    lines [ _index ] = _line.replace ( /\s{4}/, '' );
                }


                if ( ! lines [ 0 ] )              // Trim first line if nothing's present

                    lines.shift ( );


                return lines.join ( '\n' );
            }

            /**
             * Modifies code to include instantiation expressions & unique variable identifiers
             * @private
             * @function
             * @param           {function} code                     Card-object's function
             * @param           {string}   count                    Number for unique variable identifiers
             * @return          {string}                            Code string
             */
            _modifyCode ( code, count )
            {
                let _code     = UI.clean.code ( code );

                let _class    = UI.getClass ( _code );

                let _variable = ( _class === 'RoundedRectangle')  ? '_roundedRectangle'  : `_${_class.toLowerCase ( )}`;

                    _variable = ( _class === 'RoundedRectangles') ? '_roundedRectangles' : _variable;

                let _regex    = new RegExp ( _variable, 'g' );

                let _init     = ( PAGE.handler ) ? this._initializer [ PAGE.handler ] [ _class ] : this._initializer [ PAGE.group ] [ _class ];


                switch ( _class )
                {
                    case 'Lines':               _code = `let ${_variable} = new ${_class} ( ${_init} );\n\n    ${_variable}.push (\n        new Line ( { x:  60, y: 50 }, { x: 160, y: 100 } ),\n        new Line ( { x: 140, y: 50 }, { x: 240, y: 100 } )\n    );\n\n    ${_variable}.canvas = 'canvas_${count}';\n${_code}`;     break;

                    case 'Circles':             _code = `let ${_variable} = new ${_class} ( ${_init} );\n\n    ${_variable}.push (\n        new Circle ( { x:  60, y: 50 } ),\n        new Circle ( { x: 140, y: 50 } )\n    );\n\n    ${_variable}.canvas = 'canvas_${count}';\n${_code}`;                                         break;

                    case 'Ellipses':            _code = `let ${_variable} = new ${_class} ( ${_init} );\n\n    ${_variable}.push (\n        new Ellipse ( { x:  60, y: 50 } ),\n        new Ellipse ( { x: 140, y: 50 } )\n    );\n\n    ${_variable}.canvas = 'canvas_${count}';\n${_code}`;                                         break;

                    case 'Rectangles':          _code = `let ${_variable} = new ${_class} ( ${_init} );\n\n    ${_variable}.push (\n        new Rectangle ( { x:  60, y: 50 } ),\n        new Rectangle ( { x: 140, y: 50 } )\n    );\n\n    ${_variable}.canvas = 'canvas_${count}';\n${_code}`;                                   break;

                    case 'RoundedRectangles':   _code = `let ${_variable} = new ${_class} ( ${_init} );\n\n    ${_variable}.push (\n        new RoundedRectangle ( { x:  60, y: 50 } ),\n        new RoundedRectangle ( { x: 140, y: 50 } )\n    );\n\n    ${_variable}.canvas = 'canvas_${count}';\n${_code}`;                                   break;

                    case 'Texts':               _code = `let ${_variable} = new ${_class} ( ${_init} );\n\n    ${_variable}.push (\n        new Text ( { x:  60, y: 50 } ),\n        new Text ( { x: 140, y: 50 } )\n    );\n\n    ${_variable}.canvas = 'canvas_${count}';\n\n    ${_variable} [ 0 ].text = ${_variable} [ 1 ].text = 'Text';\n${_code}`;                                             break;

                    case 'Group':               _code = `let ${_variable} = new ${_class} ( ${_init} );\n\n    ${_variable}.lines.push (\n        new Line ( { x:  60, y: 50 }, { x: 120, y: 100 } ),\n        new Line ( { x: 140, y: 50 }, { x: 200, y: 100 } )\n    );\n\n     ${_variable}.circles.push (\n        new Circle ( { x:  60, y: 50 } ),\n        new Circle ( { x: 140, y: 50 } )\n    );\n\n    ${_variable}.rectangles.push (\n        new Rectangle ( { x:  120, y: 100 } ),\n        new Rectangle ( { x: 200, y: 100 } )\n    );\n\n    ${_variable}.texts.push (\n        new Text ( { x:  60, y: 120 } ),\n        new Text ( { x: 200, y: 50 } )\n    );\n\n    ${_variable}.texts [ 0 ].text = ${_variable}.texts [ 1 ].text = 'Text';\n\n    ${_variable}.canvas = 'canvas_${count}';\n${_code}`;     break;

                    case 'Image':               _code = `let ${_variable} = new cImage ( ${_init} );\n\n    ${_variable}.canvas = 'canvas_${count}';\n${_code}`;                     break

                    default:                    _code = `let ${_variable} = new ${_class} ( ${_init} );\n\n    ${_variable}.canvas = 'canvas_${count}';\n${_code}`;                     break
                }


                _code = _code.replace ( _regex, `${_variable}_${count}` );

                _code = this._getSpecialVariables ( _code, count );


                return _code;
            }

            /**
             * Modifies code to include instantiation expressions & unique variable identifiers; for Templates only
             * @private
             * @function
             * @param           {function} code                     Card-object's function
             * @param           {string}   count                    Number for unique variable identifiers
             * @return          {string}                            Code string
             */
            _modifyTemplateCode ( code, count )
            {
                let _code  = UI.clean.code ( code );

                let _lines = _code.split ( /\n/ );

                let _regex = ( PAGE.handler === 'animation' ) ? new RegExp ( /_\w+/g )

                                                              : new RegExp ( /_group.(template)\s*=\s*new\s*\w+\s\(\s*[^\)]+\)/g );

                    _lines = this._matchVariables ( _regex, _lines, count );

                    _code  = _lines.replace ( /'canvas';/, `'canvas_${count}';` );

                    _code  = this._cleanCountDuplicates ( _code, count );


                return _code;
            }

            /**
             * Modifies existing variable name with uniquely identified variable name
             * @private
             * @function
             * @param           {string} line                       Line of code to modify
             * @param           {string} variable                   Variable name to modify
             * @param           {string} count                      Number for unique variable identifier
             */
            _modifyVariables ( line, variable, count  )
            {
                let _variable = `${variable}`;

                let _regex = new RegExp ( _variable, 'g' );


                return line.replace ( _regex, `${_variable}_${count}` );
            }

            /**
             * Sets image paths for each card-object passed through the param
             * @private
             * @function
             * @param           {Object} cardObject                 Card-object
             */
            _setImagePaths ( cardObject )
            {
                if ( ! cardObject.images )

                    cardObject.images = new Object;


                // Type
                cardObject.images.type = PAGE.type.toTitleCase ( );


                // Handler
                switch ( PAGE.handler )
                {
                    case 'animation':

                        let _timing = cardObject.code.toString ( ).match ( /timing:\s*'([^']+)',/ );

                            _timing = ( ! _timing ) ? cardObject.code.toString ( ).match ( /_timing[^=]+=\s*'([^']+)'/ ) [ 1 ]

                                                    : _timing = _timing [ 1 ];

                        let _match  = _timing.match ( /(In|Out)/g );

                        let _path   = ( _match.length < 2 ) ? _match [ 0 ] : _match [ 0 ] + _match [ 1 ];


                        cardObject.images.easing  = `Handler/${PAGE.handler.toTitleCase ( )}/Ease/${_path}/${_timing}`;

                        cardObject.images.handler = PAGE.handler.toTitleCase ( );

                        break;
                }

                // Children
                if ( cardObject.children )
                {
                    cardObject.images.children = new Array;


                    for ( let _child of cardObject.children )

                        cardObject.images.children.push ( _child.toTitleCase ( ) );
                }
            }

        ////    PUBLIC    //////////////////////////////////

            /**
             * Returns an Array of standard & extra HTML templates for each card-object
             * @public
             * @function
             * @param           {Array.<Object>} cardObjects        Array of card-objects
             * @return          {Array}                             Array of HTML templates for each card-object
             */
            getCards ( cardObjects )
            {
                let _cards = this._getStandardTemplates ( cardObjects );

                let _extra = this._getBlankTemplates    ( cardObjects );


                return _cards.concat ( _extra );
            }
}
 
/**
 * @class           {Object} Tool                       General helper class
 * @property        {Object} copy                       Standard HTML card template
 */
class Tool
{
    constructor ( ) { }

    _config =
    {
        minFontSize:            undefined,
        maxDivisionHeight:      undefined,
        previousDivisionHeight: undefined,
    }

    _get =
    {
        /**
         * Returns CSS font size of HTML element
         * @private
         * @function
         * @param           {HTMLElement} element           HTML DOM Element
         * @return          {string}                        CSS font size
         */
        fontSize ( element )
        {
            return this.numberFromPx ( window.getComputedStyle ( element ).fontSize );
        },

        /**
         * Returns CSS pixel value as number
         * @private
         * @function
         * @param           {string} value                  CSS pixel value
         * @return          {number}                        Number
         */
        numberFromPx ( value )
        {
            return Number ( value.replace ( 'px', '' ) );
        },

        /**
         * Returns the minimum height of a text element
         * @private
         * @function
         * @param           {HTMLElement} element           HTML DOM element
         * @return          {number}                        Minimum height
         */
        textMinHeight ( element )
        {
            let _originalText = element.innerHTML.replaceAll ( '\n', '' ).replaceAll ( '\t', '' );


            element.innerHTML = 'A';


            let _height       = element.clientHeight


            element.innerHTML = _originalText;


            return _height;
        }
    }

    ////    VALIDATORS    //////////////////////////////////////////////////////

        /**
         * Determine whether the passed element is active
         * @public
         * @function
         * @param           {HTMLElement} element               HTML DOM Element
         * @return          {boolean}                           True || False
         */
        isActive ( element )
        {
            return ( element.getAttribute ( 'data-bs-active' ) === 'true' );
        }

        /**
         * Determine whether the passed value is an 'Object' canvasLab category
         * @public
         * @function
         * @param           {string} value                      Object, i.e.: 'Line', 'Circle', 'Rectangle', etc...
         * @return          {boolean}                           True || False
         */
        isCanvasLabObject ( value )
        {
            return [ 'Line', 'Lines', 'Circle', 'Circles', 'Ellipse', 'Ellipses', 'Rectangle', 'Rectangles', 'RoundedRectangle', 'RoundedRectangles', 'Text', 'Texts', 'cImage', 'Group' ].includes ( value );
        }

    ////    UTILITIES    ///////////////////////////////////////////////////////

        ////    PRIVATE    /////////////////////////////////

            /**
             * Increments font size by 1px
             * @private
             * @function
             * @param           {HTMLElement} element           HTML DOM Element
             * @param           {boolean}     up                Increment up or down; True || False
             */
            _incrementFontSize ( element, up = false )
            {
                this._config.minFontSize = this._get.fontSize ( element );

                this._config.minFontSize = ( up ) ? this._config.minFontSize + 1 : this._config.minFontSize - 1;


                element.style.fontSize = `${this._config.minFontSize}px`;
            }

        ////    PUBLIC    //////////////////////////////////

            /**
             * Copy code to clipboard
             * @public
             * @async
             * @function
             */
            async copyCode ( )
            {
                let _code = document.querySelector ( '#modal-code > div > div > div.modal-body > pre > code' ).innerHTML.replace ( /<[^>]+>/g, '' );


                try
                {
                    await navigator.clipboard.writeText ( _code );

                    console.info ( 'Content copied to clipboard' );
                }
                catch ( err )
                {
                    console.error ( 'Failed to copy: ', err );
                }


                UI.alert ( 'Copied code !', 'success' );

                TOOL.delay ( 1000 ).then ( ( ) => document.querySelector ( '#copiedAlert' ).children [ 0 ].remove ( ) );
            }

            /**
             * Returns a copied object
             * @public
             * @function
             * @param           {Object} object                     Object to copy
             * @return          {Object}                            Copied object
             */
            copyObjectWithKey ( object )
            {
                let _copyFunction = ( func ) => func;

                let _result       = ( PAGE.handler ) ? JSON.parse ( JSON.stringify ( object [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ] ) )

                                                     : JSON.parse ( JSON.stringify ( object [ PAGE.group ] [ PAGE.type ] ) );


                if ( PAGE.handler )

                    for ( let _entry in object [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ] )

                        _result [ _entry ].code = _copyFunction ( object [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ] [ _entry ].code );

                else

                    for ( let _entry in object [ PAGE.group ] [ PAGE.type ] )

                        _result [ _entry ].code = _copyFunction ( object [ PAGE.group ] [ PAGE.type ] [ _entry ].code );


                return _result;
            }

            /**
             * Simple programmatic delay
             * @public
             * @function
             * @param           {number} time                       Time to delay
             * @return          {Promise}                           An async promise
             */
            delay ( time )
            {
                return new Promise ( resolve => setTimeout ( resolve, time ) );
            }

            /**
             * Adjusts group of element font-sizes, with that groups min font-size
             * @private
             * @function
             * @param           {string} selector               CSS selector
             */
            scaleText ( selector )
            {
                let _textBoxes  = document.querySelectorAll ( selector );

                let _textBoxOne = _textBoxes [ 0 ];

                let _minHeight  = this._get.textMinHeight ( _textBoxOne );


                for ( let _textBox of _textBoxes )              // Check: for wrapped text boxes via element.clientHeight

                    while ( _textBox.clientHeight > _minHeight )

                        this._incrementFontSize ( _textBox );


                for ( let _textBox of _textBoxes )              // Resize: all text boxes to minimum font size

                    _textBox.style.fontSize = `${this._config.minFontSize}px`;


                for ( let _textBox of _textBoxes )              // Check: that all _textBox.clientHeights are equal
                {
                    if ( this._config.previousDivisionHeight === undefined )
                    {
                        this._config.previousDivisionHeight = _textBox.clientHeight;

                        continue;
                    }
                    else

                        if ( _textBox.clientHeight > this._config.previousDivisionHeight )

                            this.scaleText ( selector );


                    this._config.previousDivisionHeight = _textBox.clientHeight;
                }
            }
}
 
/**
 * @class           {Object} UserInterface              User Interface
 * @property        {Object} toggle                     Toggling functions
 * @property        {Object} clean                      Cleaning functions
 */
class Ui
{
    _toggle =
    {
        ////    PRIVATE    /////////////////////////////////

            /**
             * Adds an additional card to cardObjects; mirroring the last card present
             * @private
             * @function
             * @param           {HTMLEvent} event                   HTML DOM event
             */
            _cardPlus ( element )
            {
                let _card = cardObjects [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ].length - 1;

                    _card = cardObjects [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ] [ _card ];


                cardObjects [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ].push ( _card );


                UI._setAlbumCards ( );
            },

            /**
             * Subtracts the last card from cardObjects
             * @private
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            _cardClose ( element )
            {
                let _close = element.classList.contains ( 'close' );


                if ( _close )
                {
                    let _cardNumber = Number ( element.nextElementSibling.innerHTML );


                    if ( cardObjects [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ].length > 1 )

                         cardObjects [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ].splice ( _cardNumber, 1 );


                    UI._setAlbumCards ( );
                }
            },

            /**
             * Toggles collapsible nav-menu menu items
             * @private
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            _collapsibles ( elements )
            {
                for ( let _i = 0; _i < elements.length; _i++ )

                    elements [ _i ].addEventListener ( 'click', ( element ) =>
                        {
                            let _element = element.srcElement;


                            if ( UI._isButtonOpen ( _element ) )

                                UI._collapseButtonsExcept ( elements, _i );
                        } );
            },

            /**
             * Sets markdown content for the off canvas documentation element
             * @private
             * @function
             * @param           {HTMLElement} element               Object or Subject type
             */
            _documentation ( element )
            {
                let _isBaseIcon = ( element.getAttribute ( 'suite-data-type' ) === 'Base' );

                if ( ! _isBaseIcon )
                {
                    let _converter = new showdown.Converter;

                    _converter.setOption ( 'tables', true );


                    let _type = element.getAttribute ( 'suite-data-type' );

                    let _text = md2json [ _type ];

                        _text = _text.replace ( /&quot;&#x27;/g, '"' )
                                     .replace ( /&#x27;&quot;/g, '"' )
                                     .replace ( /&lt;/g,         '"' )
                                     .replace ( /&gt;/g,         '"' );


                    let _html = _converter.makeHtml ( _text );

                        _html = _html.replace ( /_new">new/,                      "_new\"><b>new</b>" )
                                     .replace ( /<strong>Access<[^:]+[^>]+>/g,    "" )
                                     .replace ( /<strong>Read only<[^:]+[^>]+>/g, "" )
                                     .replace ( /<strong>See<[^:]+[^>]+>[^>]+>/g, "" );


                    let _offcanvas     = document.querySelector ( '.offcanvas' );

                    let _offcanvasBody = _offcanvas.querySelector ( '.offcanvas-body' );

                        _offcanvasBody.innerHTML = _html;


                    let _bsOffcanvas   = new bootstrap.Offcanvas ( _offcanvas );

                        _bsOffcanvas.toggle ( );


                    let _offcanvasReset = document.getElementById ( 'offcanvas-reset' );


                        _offcanvasBody.addEventListener ( 'scroll', ( element ) =>
                            {
                                _offcanvasReset.style.opacity = ( _offcanvasBody.scrollTop > 1 ) ? '1' : '0';

                                // @TODO: optimize this
                                // This shouldn't have to run multiple times
                                // to get accuracy throughout all text-boxes
                                TOOL.scaleText ( 'h3' );

                                _offcanvasReset.addEventListener ( 'click', ( element ) => { _offcanvasBody.scrollTop = 0; } );
                            } );
                }
            },

            /**
             * Toggles visibility of easing functions
             * @private
             * @function
             * @param           {HTMLElement} element               Index of animation card
             */
            _easingFunctions ( element )
            {
                UI._embedEasingButtons ( );


                let _index     = Number ( element.getAttribute ( 'suite-data-index' ) );

                let _functions = document.querySelectorAll ( '.easing-functions' );


                ( _functions [ _index ].style.visibility === 'hidden' || _functions [ _index ].style.visibility === '' )

                    ? [ _functions [ _index ].style.opacity, _functions [ _index ].style.visibility ] = [ 1, 'visible' ]

                    : [ _functions [ _index ].style.opacity, _functions [ _index ].style.visibility ] = [ 0, 'hidden'  ];
            },

            /**
             * Toggles opacity from bottom links in navigation area
             * @private
             * @function
             * @param           {boolean} show                      True || False
             */
            _externalLinks ( show = true )
            {
                let _links = document.querySelector ( '.external-links' );


                ( show ) ? _links.classList.add    ( 'fade' )

                         : _links.classList.remove ( 'fade' );
            },

            /**
             * Returns the start & end positions of the regex matched; within the passed data
             * @private
             * @function
             * @param           {RegEx}  regex                      Regex to match
             * @param           {string} data                       Data to parse
             * @return          {Object}                            Bounding character's starting & ending position(s)
             */
            _getTextPositions ( regex, data )
            {
                let _cursor  = LAB.editor.selection.getCursor ( );

                let _indexes = new Array;

                let _match   = undefined;

                let _result  = undefined;

                let _count   = 0;


                while ( ( _match = regex.exec ( data ) ) != null )              // Set all found indexes

                    _indexes.push ( [ _match.index, regex.lastIndex ] );


                for ( let _index of _indexes )                                  // Get the accurate index in relation to the current cursor's position

                    if ( _cursor.column > _index [ 1 ] )

                        _count++;

                    else

                        _result = _count;


                return new Object ( { start: _indexes [ _result ] [ 0 ], end: _indexes [ _result ] [ 1 ] } );
            },

            /**
             * Toggles modal code element
             * @private
             * @function
             * @param           {HTMLElement} element               Main button element
             */
            _modalCode ( element )
            {
                let _element   = element.offsetParent;

                let _blankCard = ( _element.tagName === 'MAIN' );


                if ( ! _blankCard )
                {
                    let _card =
                    {
                        title: _element.getAttribute ( 'suite-data-title' ).toTitleCase ( ),

                        code:  _element.getAttribute ( 'suite-data-code' ).replace ( /_\d{1,3}/g, '' )
                    }

                    let _modal =
                    {
                        title:   document.querySelector ( '#modal-code-label' ),

                        code:    document.querySelector ( 'code' ),

                        element: document.querySelector ( '#modal-code' )
                    }

                    let _boostrapModal = bootstrap.Modal.getOrCreateInstance ( _modal.element );


                    [ _modal.title.innerHTML, _modal.code.innerHTML ] = [ _card.title, _card.code ]


                        _boostrapModal.toggle ( );

                        hljs.highlightAll ( );
                }
            },

            /**
             * Moves nav menu left or right
             * @private
             * @function
             * @param           {Boolean} left                      True || False
             */
            _navMove ( left )
            {
                let _openButtons = document.querySelectorAll ( '[data-button-open=true]' ).length;

                let _navLinks    = document.getElementById ( 'nav-links' );

                let _paddingLeft = TOOL._get.numberFromPx ( window.getComputedStyle ( _navLinks ).paddingLeft );

                let _menuDepth   = 3;

                let _increment   = 15;


                if ( left )

                    _navLinks.style.paddingLeft = `${_paddingLeft - _increment}px`;

                else

                    if ( _openButtons <= _menuDepth )

                        _navLinks.style.paddingLeft = `${_paddingLeft + _increment}px`;
            },

            /**
             * Toggles drop-down navigation menu
             * @private
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            _navDropdown ( element )
            {
                let _button = element.innerHTML.trim ( );

                let _ul     = ( element.parentNode.nextSibling.data ) ? element.parentNode.nextSibling.nextSibling : element.parentNode.nextSibling;

                let _isOpen = ( element.getAttribute ( 'data-button-open' ) === 'false' );

                let _isShow = ( _ul.classList.contains ( 'show' ) );


                ( _isShow ) ? _ul.classList.remove ( 'show' )

                            : _ul.classList.add    ( 'show' );


                element.setAttribute ( 'data-button-open', _isOpen );


                this._externalLinks ( _isOpen );


                if ( _button != 'Documents' )

                    this._navMove ( _isOpen );
            },

            /**
             * Reset nav button position when closed
             * @private
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            _navButtonReset ( element )
            {
                let _open = element.children [ 0 ].getAttribute ( 'data-button-open' );


                if ( _open === 'false' )

                    document.getElementById ( 'nav-links' ).style.paddingLeft = '3.5rem'
            },

            /**
             * Resets lab control by toggling off & on that control
             * @private
             * @function
             * @param           {string} control                    Lab control to toggle
             */
            _resetLabControl ( control )
            {
                let _element = document.querySelector ( `#input-${control}` );

                let _code    = `UI.toggle.${control}();`


                if ( TOOL.isActive ( _element ) )

                    for ( let _i = 0; _i < 2; _i++ )

                        eval ( _code );
            },

            /**
             * Toggles between two buttons in the navigation tree
             * @private
             * @function
             * @param           {HTMLElement} buttonOne             HTML DOM Element for button one
             * @param           {HTMLElement} buttonTwo             HTML DOM Element for button two
             * @param           {boolean}     closeOne              Whether to close button one
             */
            _twoButtons ( buttonOne, buttonTwo, closeOne )
            {
                if ( UI._isButtonOpen ( buttonOne )  &&  UI._isButtonOpen ( buttonTwo ) )

                    ( closeOne ) ? buttonOne.click ( )

                                 : buttonTwo.click ( );


                    this._navMove ( true );
            },

        ////    PUBLIC    //////////////////////////////////

            /**
             * Toggles angle in lab
             * @public
             * @function
             */
            angle ( )
            {
                LAB.setAngle ( );


                let _angle      = document.getElementById ( 'angle' );

                let _mouseAngle = document.getElementById ( 'mouse-angle' );

                let _button     = document.getElementById ( 'input-angle' );


                this.labButton ( _button );


                ( TOOL.isActive ( _button ) ) ? [ _angle.style.opacity, _mouseAngle.style.opacity, document.body.style.cursor ] = [ 1, 1, 'crosshair' ]

                                              : [ _angle.style.opacity, _mouseAngle.style.opacity, document.body.style.cursor ] = [ 0, 0, 'default'   ];
            },

            fps ( )
            {
                LAB.setFps ( );


                let _fps    = document.getElementById ( 'fps' );

                let _button = document.getElementById ( 'input-fps' );


                this.labButton ( _button );


                _fps.style.opacity = ( TOOL.isActive ( _button ) ) ? 1 : 0;
            },

            /**
             * Toggles boolean value in lab
             * @public
             * @function
             */
            boolean ( )
            {
                let _regex    = new RegExp ( /true|false/g );

                let _cursor   = LAB.editor.selection.getCursor ( );

                let _line     = LAB.editor.session.getLine ( _cursor.row );

                let _position = this._getTextPositions ( _regex, _line );

                let _range    = new ace.Range ( _cursor.row, _position.start, _cursor.row, _position.end );

                let _boolean  = LAB.editor.session.getTextRange ( _range ).trim ( );


                if ( _regex.test ( _boolean ) )

                    _boolean = ( _boolean === 'true' ) ? 'false' : 'true';


                LAB.editor.session.replace ( _range, _boolean );

                LAB.runCode ( );
            },

            /**
             * Toggles the card button associated with the passed 'element' param
             * @public
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            cardButton ( element )
            {
                let _element  = element.srcElement;

                let _cardPlus = _element.classList.contains ( 'plus' );


                if ( _cardPlus )

                    switch ( _element.tagName )
                    {
                        case 'DIV':
                        case 'SPAN':        this._cardPlus ( _element );        break;
                    }

                else

                    switch ( _element.tagName )
                    {
                        case 'IMG':

                            let _buttonType = _element.getAttribute ( 'suite-button-type' );


                            switch ( _buttonType )
                            {
                                case 'easing':          this._easingFunctions ( _element );     break;

                                case 'documentation':   this._documentation   ( _element );     break;
                            }

                            break;

                        case 'SPAN':                    this._cardClose       ( _element );     break;

                        case 'LI':                      this._easingFunctions ( _element );     break;

                        case 'DIV':
                        case 'CANVAS':                  this._modalCode       ( _element );     break;
                    }


                element.stopPropagation ( );
            },

            /**
             * Toggles coordinates in lab
             * @public
             * @function
             */
            coordinates ( )
            {
                LAB.setCoordinates ( );


                let _coordinates = document.getElementById ( 'coordinates' );

                let _mouseCoordinates = document.getElementById ( 'mouse-coordinates' );

                let _button      = document.getElementById ( 'input-coordinates' );


                this.labButton ( _button );


                ( TOOL.isActive ( _button ) ) ? [ _coordinates.style.opacity, _mouseCoordinates.style.opacity, document.body.style.cursor ] = [ 1, 1, 'crosshair' ]

                                              : [ _coordinates.style.opacity, _mouseCoordinates.style.opacity, document.body.style.cursor ] = [ 0, 0, 'default'   ];
            },

            download ( )
            {
                let _name    = 'canvasLab_file.js';

                let _content = LAB.editor.getValue ( );

                let _file    = new File ( [ _content ], _name, { type: 'text/javascript' } );


                LAB._download ( _file );
            },

            /**
             * Toggles fullscreen mode                              @TODO: fix this crap
             * @public
             * @function
             */
            fullscreen ( )
            {
                let _rightColumn      = document.querySelector ( '#lab > div:nth-child(2)' );

                let _leftColumn       = document.querySelector ( '#lab > div:nth-child(1)' );

                let _open             = document.querySelector ( '#lab-open' );

                let _grid             = document.querySelector ( '#input-grid' );

                let _mouseAngle       = document.querySelector ( '#input-angle' );

                let _mouseCoordinates = document.querySelector ( '#input-coordinates' );

                let _angle            = document.querySelector ( '#mouse-angle');

                let _coordinates      = document.querySelector ( '#mouse-coordinates' );

                let _styles           = window.getComputedStyle ( _rightColumn );

                let _fullscreen       = ( _styles.display === 'block' );

                ////    TOGGLE NAVIGATION    ///////////////////////////////////////

                if ( UI._isNavOpen ( ) )

                    this.navigation ( );

                ////    RESET STYLES    ////////////////////////////////////////////

                ( _fullscreen ) ? _rightColumn.style.display = 'none'

                                : _rightColumn.style.display = 'block';


                ( _fullscreen ) ? _leftColumn.style.width = '100%'

                                : _leftColumn.style.width = '50%';


                ( _fullscreen ) ? _open.style.display = 'block'

                                : _open.style.display = 'none';


                ( _fullscreen ) ? _angle.style.width = _coordinates.style.width = '100%'

                                : _angle.style.width = _coordinates.style.width = '50%';

                ////    RESET CANVAS & LAB OPTIONS    //////////////////////////////

                LAB.setCanvasSize ( );


                this._resetLabControl ( 'grid' );

                this._resetLabControl ( 'coordinates' );

                this._resetLabControl ( 'angle' );

                this._resetLabControl ( 'fps' );


                LAB.runCode ( );

                ////    EVENT LISTENER    //////////////////////////////////////////

                _open.addEventListener ( 'click', ( ) => this.fullscreen ( ) );
            },

            /**
             * Toggles gamepad data
             * @public
             * @function
             */
            gamepad ( )
            {
                if ( ! devSuite.config.boostrapOffcanvas )
                {
                    let _offcanvas = document.querySelector ( '.offcanvas' );

                    devSuite.config.boostrapOffcanvas = new bootstrap.Offcanvas ( _offcanvas );
                }


                devSuite.config.boostrapOffcanvas.toggle ( );
            },

            /**
             * Toggles grid in lab
             * @public
             * @function
             */
            grid ( )
            {
                LAB.setGrid ( );


                let _grid   = document.getElementById ( 'grid' );

                let _button = document.getElementById ( 'input-grid' );


                this.labButton ( _button );


                _grid.style.opacity = ( TOOL.isActive ( _button ) ) ? 1 : 0;
            },

            /**
             * Toggles lab from each card-object
             * @public
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            lab ( element )
            {
                let _element = element.srcElement;

                let _code    = _element.getAttribute ( 'suite-data-code' ).replaceAll ( /_\d{2}/g, '' );


                UI.clearScreen  ( false, true );

                LAB.editor.setValue ( _code );

                LAB.setCanvasSize ( );

                LAB.setLabDefaults ( );

                LAB.runCode ( );


                if ( PAGE.group === 'template' )

                    this.navigation ( );


                window.addEventListener ( 'resize', LAB.setCanvasSize );
            },

            /**
             * Toggles lab buttons active state
             * @public
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            labButton ( element )
            {
                let _active = TOOL.isActive ( element );


                ( _active ) ? element.classList.remove ( 'active' )

                            : element.classList.add    ( 'active' );


                ( _active ) ? element.setAttribute ( 'data-bs-active', false )

                            : element.setAttribute ( 'data-bs-active', true  );
            },

            labPopup ( buttonId, popupId )
            {
                let _button = document.querySelector ( buttonId );

                let _popup  = document.querySelector ( popupId );

                let _show   = ( _popup.style.display === 'none' );


                switch ( popupId )
                {
                    case '.menu_popup':

                        for ( let _child of _popup.children )
                        {
                            _child.className = "";              // clear class list


                            if ( LAB._script.title === _child.innerHTML )

                                _child.classList.add ( 'active' );
                        }

                        break;

                    case '.timing_popup':

                        console.log ( '_popup:', _popup );

                        break;
                }


                _popup.style.bottom  = ( window.screen.width < 1500 ) ? '78px' : '40px';

                _popup.style.display = ( _show ) ? 'block' : 'none';


                this.labButton ( _button );
            },

            /**
             * Toggles visibility of navigation menu
             * @public
             * @function
             */
            navigation ( )
            {
                let _lab         = document.querySelector ( 'div.lab-station' );

                let _nav         = document.querySelector ( 'nav' );

                let _main        = document.querySelector ( 'main' );

                let _open        = document.querySelector ( '#nav-open' );

                let _button      = document.querySelector ( '#input-sidebar' );

                let _angle       = document.querySelector ( '#mouse-angle');

                let _coordinates = document.querySelector ( '#mouse-coordinates' );

                let _grid        = document.querySelector ( '#input-grid' );

                let _navIcons    = _nav.querySelector ( '#nav-icon' ).children;

                let _navOpen     = UI._isNavOpen ( );


                this.labButton ( _button );

                ////    RESET STYLES   /////////////////////////////////////////////

                ( _navOpen ) ? [ _nav.style.left, _main.style.paddingLeft ] = [ '-225px',   '0px' ]

                             : [ _nav.style.left, _main.style.paddingLeft ] = [    '0px', '225px' ];


                ( _navOpen ) ? _angle.style.width = _coordinates.style.width = '50%'

                             : _angle.style.width = _coordinates.style.width = '42%';


                if ( _lab.style.display === 'block' )
                {
                    LAB.setCanvasSize ( );

                    LAB.runCode ( );
                }


                for ( let _navIcon of _navIcons )           // Blink eye

                    _navIcon.style.display = ( _navIcon.style.display === 'none' ) ? 'block' : 'none';


                _open.style.display = ( _open.style.display === 'none' ) ? 'block' : 'none';


                this._resetLabControl ( 'grid' );
            },
    }

    _clean =
    {
        /**
         * Cleans the remaining '.blank' cards while converting the first to a '.plus' card; @see Ui.toggle._cardPlus ( )
         * @public
         * @function
         */
        blankCards ( )
        {
            let _cards = document.querySelectorAll ( '.card' );

            let _first = true;

            let _count = 0;


            if ( PAGE.handler === 'animation' )

                for ( let _card of _cards )
                {
                    let _blank  = _card.classList.contains ( 'blank' );


                    if ( _blank && _first )
                    {
                        let _height = _cards [ _count - 1 ].clientHeight;


                        _card.classList.add ( 'plus' );

                        _card.style.height = `${_height}px`;


                        _first = false;
                    }


                    _count++;
                }
        },

        /**
         * Cleans code of enumerators for card-objects
         * @public
         * @function
         * @param           {Function} script                   JavaScript function; for card-objects only
         * @return          {string}                            Function as a string
         */
        code ( script )
        {
            let _code   = this.script ( script ).split ( /\n/g );

            let _length = _code.at ( -1 ).match ( /^\s+/ ) [ 0 ].length;


            for ( let _line in _code )

                _code [ _line ] = _code [ _line ].slice ( _length );


            return _code.join ( '\n' );
        },

        /**
         * Cleans script of it's function wrapper
         * @public
         * @function
         * @param           {Function} script                   JavaScript function
         * @return          {string}                            Function as a string
         */
        script ( script )
        {
            script = script.toString ( ).replace ( /\([^{]+{/, '' );

            return   script.substring ( 0, script.length - 1 );
        },
    }

    constructor ( ) { }

    ////    PROPERTIES    //////////////////////////////////////////////////////

        ////    [ TOGGLE ]    //////////////////////////////

            /**
             * Gets toggle object
             * @public
             * @function
             * @return          {Object}                            Toggle object
             */
            get toggle ( )
            {
                return this._toggle;
            }

        ////    [ CLEAN ]    ///////////////////////////////

            /**
             * Gets clean object
             * @public
             * @function
             * @return          {Object}                            Clean object
             */
            get clean ( )
            {
                return this._clean;
            }

    ////    VALIDATION    //////////////////////////////////////////////////////

        /**
         * Checks whether collapsible button is open
         * @private
         * @function
         * @param           {HTMLElement} button                Element to validate
         */
        _isButtonOpen ( button )
        {
            return ( button.getAttribute ( 'data-button-open' ) === 'true' );
        }

        /**
         * Returns whether the navigation bar is open
         * @private
         * @function
         * @return          {boolean}                           True || False
         */
        _isNavOpen ( )
        {
            return ( document.querySelector ( 'nav' ).style.left === '0px' );
        }

    ////    UTILITIES    ///////////////////////////////////////////////////////

        ////    PRIVATE    /////////////////////////////////

            /**
             * Collapses all passed buttons, outside of index passed
             * @private
             * @function
             * @param           {Array}  buttons                    Array of collapsible buttons
             * @param           {number} index                      Index of button to leave open
             */
            _collapseButtonsExcept ( buttons, index )
            {
                for ( let _i = 0; _i < buttons.length; _i++ )
                {
                    if ( _i === index )

                        continue;


                    if ( this._isButtonOpen ( buttons [ _i ] ) )

                        buttons [ _i ].click ( );
                }
            }

            /**
             * Creates easing links for animation cards
             * @private
             * @function
             * @return          {HTMLElement}                       UL element with all necessary nested elements
             */
            _createEasingButtons ( )
            {
                let _timings =
                [
                    'easeInSine',    'easeInCubic',    'easeInQuint',    'easeInCirc',    'easeInElastic',    'easeInQuad',    'easeInQuart',    'easeInExpo',    'easeInBack',
                    'easeOutSine',   'easeOutCubic',   'easeOutQuint',   'easeOutCirc',   'easeOutElastic',   'easeOutQuad',   'easeOutQuart',   'easeOutExpo',   'easeOutBack',
                    'easeInOutSine', 'easeInOutCubic', 'easeInOutQuint', 'easeInOutCirc', 'easeInOutElastic', 'easeInOutQuad', 'easeInOutQuart', 'easeInOutExpo', 'easeInOutBack'
                ]

                let _regex         = new RegExp ( /(In|Out)/, 'g' );

                let _div           = document.createElement ( 'div' );

                    _div.className = 'easing-wrapper';


                let _ul            = document.createElement ( 'ul' );

                    _ul.className  = 'easing-functions';


                for ( let _timing of _timings )
                {
                    let _match   = _timing.match ( _regex );

                    let _path    = ( _match.length < 2 ) ? _match [ 0 ] : _match [ 0 ] + _match [ 1 ];


                    let _img     = document.createElement ( 'img' );

                        _img.src = `images/svg/Handler/Animation/Ease/${_path}/${_timing}.svg`;


                    let _span           = document.createElement ( 'span' );

                        _span.innerHTML = _timing;


                    let _li = document.createElement ( 'li' );

                        _li.setAttribute ( 'onclick', `devSuite.runEasingAnimation ( '${_timing}', this.parentElement.id )` );

                        _li.appendChild ( _span );

                        _li.appendChild ( _img );


                    _ul.appendChild ( _li );
                }


                _div.appendChild ( _ul );


                return _div;
            }

            /**
             * Embeds easing buttons for each animation card
             * @private
             * @function
             */
            _embedEasingButtons ( )
            {
                let _easings = document.querySelectorAll ( '.easing' );

                let _div     = this._createEasingButtons ( );


                for ( let _i = 0; _i < _easings.length; _i++ )
                {
                    let _clonedDiv = _div.cloneNode ( true );

                    let _ul        = _clonedDiv.children [ 0 ];

                        _ul.id = _i;

                        _ul.setAttribute ( 'onmouseleave', `devSuite.toggleEasingFunctions ( ${_i} )` );


                    _easings [ _i ].parentNode.insertBefore ( _clonedDiv, _easings.nextSibling );

                    _easings [ _i ].setAttribute ( 'onclick', `devSuite.toggleEasingFunctions ( ${_i} )` );
                }
            }

            /**
             * Runs code from within the passed 'cardObjects' param
             * @private
             * @function
             * @param           {Array.<Object>} cardObjects        Array of card-objects
             */
            _evalCardObjects ( cardObjects )
            {
                eval ( this._getCode ( cardObjects ) );
            }

            /**
             * Returns a button for navigation links
             * @private
             * @function
             * @param           {Object} button                     Navigation link object
             * @return          {HTMLElement}                       List item HTML element
             */
            _getButton ( button )
            {
                let _li     = document.createElement ( 'li' );

                let _button = document.createElement ( 'button' );

                let _id     = button.title.toLowerCase ( ) + '-collapse';

                    _button.innerHTML = button.title;


                    _button.setAttribute ( 'data-bs-target',   _id   );

                    _button.setAttribute ( 'data-button-open', false );


                    _button.classList.add ( 'btn', 'btn-toggle', 'align-items-center', 'rounded', 'collapsed' );


                    _li.append ( _button );


                return _li;
            }

            /**
             * Returns eval ready code for passed card-objects
             * @private
             * @function
             * @param           {Array.<Object>} objects            Array of card-objects
             * @return          {string}                            String to be evaluated for all card-objects
             */
            _getCode ( objects )
            {
                let _codes      = [ ]

                let _isTemplate = ( PAGE.group === 'template' );


                for ( let _object of objects )
                {
                    if ( _isTemplate )

                        _object.code = _object.code.replace ( /canvaslab\.center/g, 'new Point ( 154, 77 )' );


                    _codes.push ( `////    ${_object.title}    //////////////////////////\n\n${_object.code}` );
                }


                return `( ( window ) =>\n{\n${_codes.join ( '\n\n' )}\n\n} ) ( window );`
            }

            /**
             * Returns a link for navigation links
             * @private
             * @function
             * @param           {Object} link                       Navigation link object
             * @return          {HTMLElement}                       List item HTML element
             */
            _getLink ( link )
            {
                let _li   = document.createElement ( 'li'  );

                let _img  = document.createElement ( 'img' );

                let _a    = document.createElement ( 'a'   );

                let _icon = ( link.group === 'Animation' ) ? ( TOOL.isCanvasLabObject ( link.title ) ) ? 'Object' : 'Subject' : link.group;


                    _a.href      = ( link.handler ) ? `#${link.handler}${link.group}${link.title}` : `#${link.group}${link.title}`;

                    _a.innerHTML = link.title;


                    _img.src = `images/svg/${_icon}/${link.title}.svg`;


                    _li.append ( _img );

                    _li.append ( _a   );

                    _li.classList.add ( 'nav-link' );


                return _li;
            }

            /**
             * Sets the album cards for the current 'Page'
             * @private
             * @function
             */
            _setAlbumCards ( )
            {
                let _cardObjects = TOOL.copyObjectWithKey ( cardObjects );


                this.clearScreen ( true );


                this._setCardSection  ( _cardObjects );

                this._evalCardObjects ( _cardObjects );
            }

            /**
             * Sets byrne-systems logo
             * @private
             * @function
             */
            _setByrneSystemsLogo ( )
            {
                let _element = document.querySelector ( '#byrne-systems-logo' );

                let _album   = document.querySelector ( '.album' );

                let _main    = document.querySelector ( 'main' );

                let _nav     = document.querySelector ( 'nav' );

                let _div     = document.createElement ( 'div' );

                let _image   = document.createElement ( 'img' );

                ////    LOGIC    ///////////////////////////////////////////////////

                if ( _element ) _element.remove ( );


                    _album.style.display = 'none';

                    _image.src         = '../images/cube_sm.png';


                    _div.id            = 'byrne-systems-logo';

                    _div.style.cssText = `padding-top: ${_main.clientHeight / 2.5}px`;


                    _div.appendChild  ( _image );

                    _main.appendChild ( _div   );

                    _nav.style.left = '0px';
            }

            /**
             * Sets card section's inner HTML
             * @private
             * @function
             * @param           {Array.<Object>} cardObjects        Array of card-objects
             */
            _setCardSection ( cardObjects )
            {
                let _cardTemplates = TEMPLATE.getCards ( cardObjects );

                let _cardSection   = document.querySelector ( '#test-cards' );


                for ( let _cardTemplate of _cardTemplates )

                    _cardSection.innerHTML += _cardTemplate;


                this.clean.blankCards ( );
            }

            /**
             * Sets cards
             * @private
             * @function
             * @param           {HTMLElement} element               HTML DOM Element
             */
            _setCards ( element )
            {
                let _element = element.srcElement;


                element.preventDefault ( );


                PAGE = new Page ( _element );


                if ( PAGE.handler )

                    ( cardObjects [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ] )

                        ? this._setAlbumCards ( )

                        : this._setByrneSystemsLogo ( );

                else

                    ( cardObjects [ PAGE.group ] [ PAGE.type ] )

                        ? this._setAlbumCards ( )

                        : this._setByrneSystemsLogo ( );
            }

            /**
             * Sets all event listeners for this object
             * @private
             * @function
             */
            _setEventListeners ( )
            {
                switch ( 'nav' )
                {
                    case 'nav':

                        let _icon = document.querySelector ( '#nav-icon' );

                        let _open = document.querySelector ( '#nav-open' );


                        if ( _icon )
                        {
                            _icon.addEventListener ( 'click', ( ) => UI.toggle.navigation ( ) );

                            _open.addEventListener ( 'click', ( ) => UI.toggle.navigation ( ) );
                        }


                        _open.addEventListener ( 'click', ( ) => document.body.style.cursor = 'default' );

                    case 'navButtons':

                        let _buttons = new Array;

                        let _menus   = document.querySelectorAll ( '.nav-menu' );


                        for ( let _menu of _menus )

                            _buttons.push ( ..._menu.querySelectorAll ( 'button' ) );


                        for ( let _button of _buttons )

                            _button.addEventListener ( 'click', ( ) => this.toggle._navDropdown ( _button ) );

                    case 'navButtonsReset':

                        let _primaries = document.querySelectorAll ( '#nav-links > li' );


                        for ( let _primary of _primaries )

                            _primary.addEventListener ( 'click', ( ) => this.toggle._navButtonReset ( _primary ) );

                    case 'navLinks':

                        let _links = document.querySelector ( '#nav-links' ).querySelectorAll ( 'a' );


                        for ( let _link of _links )

                            _link.addEventListener ( 'click', ( element ) => this._setCards ( element ) );

                    case 'navButtons-collapse':

                        let _mainButtons = document.querySelectorAll ( '#nav-links > li > button, #doc-links > li > button' );


                        this.toggle._collapsibles ( _mainButtons );

                    case 'navButtons-toggle':

                        let _navButtonsArray =
                        [   /////////////////////////////////////    BUTTON 01    ///////////////////////////////////// ////////////////////////////////////    BUTTON 02    ////////////////////////////////////
                            [ '#core-collapse > li:nth-child(1) > button',                                              '#core-collapse > li:nth-child(3) > button'                                              ],
                            [ '#animations-collapse > li:nth-child(1) > button',                                        '#animations-collapse > li:nth-child(3) > button'                                        ],
                            [ '#core-collapse > #subjects-collapse > li:nth-child(1) > button',                         '#core-collapse > #subjects-collapse > li:nth-child(3) > button'                         ],
                            [ '#animations-collapse > #subjects-collapse > li:nth-child(1) > button',                   '#animations-collapse > #subjects-collapse > li:nth-child(3) > button'                   ],
                            [ '#core-collapse > #subjects-collapse > #color-collapse > li:nth-child(1) > button',       '#core-collapse > #subjects-collapse > #color-collapse > li:nth-child(3) > button'       ],
                            [ '#animations-collapse > #subjects-collapse > #color-collapse > li:nth-child(1) > button', '#animations-collapse > #subjects-collapse > #color-collapse > li:nth-child(3) > button' ]
                        ]

                        for ( let _navButtons of _navButtonsArray )
                        {
                            let _buttonOne = document.querySelector ( _navButtons [ 0 ] );

                            let _buttonTwo = document.querySelector ( _navButtons [ 1 ] );


                                _buttonOne.addEventListener ( 'click', ( ) => this.toggle._twoButtons ( _buttonOne, _buttonTwo, false ) );

                                _buttonTwo.addEventListener ( 'click', ( ) => this.toggle._twoButtons ( _buttonOne, _buttonTwo, true  ) );

                        }

                    case 'copy':

                        let _copyButton = document.querySelector ( 'button.copy-code-link' );

                            _copyButton.addEventListener ( 'click', TOOL.copyCode );

                    case 'lab':

                        let _main       = document.getElementsByTagName ( 'main' ) [ 0 ];

                        let _labStation = document.querySelector ( 'main > div.lab-station' );

                        let _lab        = document.querySelector ( '#nav-lab > img.lab-bottle' );


                            _lab.addEventListener ( 'click', ( ) =>
                            {
                                this.clearScreen  ( );


                                _labStation.style.display = 'block';

                                _main.style.overflow      = 'hidden';


                                LAB.setCanvasSize ( );

                                LAB.setLabDefaults ( );

                                LAB.runCode ( );
                            } );


                        window.addEventListener ( 'resize', LAB.setCanvasSize );

                    case 'lab-links':

                        let _labLink = document.querySelector ( '.lab-station-link'  );

                            _labLink.addEventListener ( 'click', ( element ) =>
                                {
                                    let _code  = document.querySelector ( '#modal-code > div > div > div.modal-body > pre > code' ).innerHTML.replace ( /<[^>]+>/g, '' );


                                    _lab.click ( );

                                    LAB.editor.setValue ( _code );

                                    LAB.runCode ( );

                                    LAB.editor.selection.moveCursorTo ( 0, 0 );
                                } );

                    case 'cards':

                        let _cards = document.querySelector ( '#nav-lab > img.card-stack' );

                            _cards.addEventListener ( 'click', ( ) =>
                                {
                                    this.clearScreen  ( );

                                    this._setByrneSystemsLogo ( );

                                    _labStation.style.display = 'none';

                                    _main.style.overflowY     = 'auto';
                                } );
                }
            }

        ////    PUBLIC    //////////////////////////////////

            /**
             * Displays an alert message within the modal
             * @public
             * @async
             * @function
             * @param           {string} message                    Message to display
             * @param           {string} type                       Type of message; success || failure
             */
            alert ( message, type )
            {
                let _wrapper           = document.createElement ( 'div' );

                    _wrapper.innerHTML = '<div class="alert alert-' + type + ' alert-dismissible" role="alert">' + '<img src="images/svg/General/info-circle.svg" />' + message + '<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>';


                    document.getElementById ( 'copiedAlert' ).append ( _wrapper );
            }

            /**
             * Clears screen prior to rebuilding
             * @public
             * @function
             * @param           {boolean} setCardAlbum              Sets card album display to block (true) || none (false)
             */
            clearScreen ( setCardAlbum = false, setLab = false )
            {
                let _main  = document.querySelector ( 'main' );

                let _album = document.querySelector ( '.album' );

                let _cards = document.querySelector ( '#test-cards' );

                let _logo  = document.querySelector ( '#byrne-systems-logo' );

                let _lab   = document.querySelector ( 'main > div.lab-station' );


                initCanvasLab ( );                              // @NOTE: canvasLab doesn't not initialize twice here, if there's already a preexisting 'window.canvasLab' object within the DOM


                if ( _logo )

                    _logo.remove ( );


                    _main.style.overflowY = 'auto';

                    _album.style.display  = ( setCardAlbum ) ? 'block' : 'none';

                    _cards.innerHTML      = '';

                    _lab.style.display    = 'none';


                if ( setLab )

                    [ _main.style.overflow, _lab.style.display ] = [ 'hidden', 'block' ];
            }

            /**
             * Returns the likely class name for the passed code
             * @public
             * @function
             * @param           {string} code                       Code string
             * @return          {string}                            Likely class name
             */
            getClass ( code )
            {
                let _class   = code.match ( /_(\w+)/ ) [ 1 ];

                let _regex   = new RegExp ( '_(line|lines|circle|circles|ellipse|ellipses|rectangle|rectangles|roundedRectangle|roundedRectangles|text|texts|image)', 'g' );

                let _objects = [ 'line', 'lines', 'circle', 'circles', 'ellipse', 'ellipses', 'rectangle', 'rectangles', 'roundedRectangle', 'roundedRectangles', 'text', 'texts', 'image' ]


                let _result = ( ! _objects.includes ( _class ) )

                                  ? ( _regex.test ( code ) )

                                        ? code.match ( _regex ) [ 0 ].replace ( '_', '' )

                                        : _class

                                  : _class;


                return _result.toTitleCase ( );
            }

            /**
             * Sets navigation links
             * @public
             * @function
             * @param           {HTMLElement}    element            Parent navigation element
             * @param           {Array.<Object>} links              Array of Objects containing navigation link data
             */
            setNavLinks ( element, links )
            {
                for ( let _link of links )

                    if ( _link.links != null )                  // BUTTONS
                    {
                        let _button = this._getButton ( _link );

                        let _id     = _button.firstElementChild.getAttribute ( 'data-bs-target' );

                        let _ul     = document.createElement ( 'ul' );

                            _ul.id  = ( _id ) ? _id : String.empty;

                            _ul.classList.add ( 'collapse' );


                        element.append ( _button );

                        element.append ( _ul );


                        this.setNavLinks ( _ul, _link.links );
                    }
                    else                                        // LINKS
                    {
                        element.classList.add ( 'nav-links' );

                        element.append ( this._getLink ( _link ) );
                    }
            }

    ////    INITIALIZER(S)    //////////////////////////////////////////////////

        /**
         * Sets User Interface
         * @public
         * @function
         */
        init ( )
        {
            ( window ) ? this._setByrneSystemsLogo ( )

                       : console.error ( '[ ERROR ]: window.master is not available !' );


            this._setEventListeners ( );
        }

        /**
         * Sets easing animation for an animation card
         * @public
         * @function
         * @param           {string} easingFunction             Easing function; as a string
         * @param           {number} index                      Index of animation card
         */
        runEasingAnimation ( easingFunction, index )
        {
            let _cardObjects = TOOL.copyObjectWithKey ( cardObjects );

            let _regex       = new RegExp ( /timing:[^,]+,/ );


            let _code        = _cardObjects [ index ].code;

                _code        = _code.toString ( ).replace ( _regex, `timing: '${easingFunction}',` );


            let _card        = _cardObjects [ index ];

                _card.text   = easingFunction;

                _card.code   = eval ( _code );


            cardObjects [ PAGE.handler ] [ PAGE.group ] [ PAGE.type ] [ index ] = _card;


            this._setAlbumCards ( );
        }
}
 
/**
 * Call main module
 * @module                                                  devSuite
 * @param           {Object} window                         Window containing a DOM document
 */
( ( window ) =>
{
    let _classes = [ 'Template', 'Page', 'Tool', 'Ui', 'Lab' ];

    /**
     * Array of navigation links
     * @type {Array.<Object>}
     * @example { title: 'Title', group: 'Icon folder', links: <Array.<Object>> | null }
     */
    let _navLinks =
    [
        // core
        {
            title: 'Core',
            links:
            [
                // objects
                {
                    title: 'Objects',
                    links:
                    [
                        {
                            title: 'Collections',
                            links:
                            [
                                {
                                    title: 'Lines',
                                    group: 'Object'
                                },
                                {
                                    title: 'Circles',
                                    group: 'Object'
                                },
                                {
                                    title: 'Ellipses',
                                    group: 'Object'
                                },
                                {
                                    title: 'Rectangles',
                                    group: 'Object'
                                },
                                {
                                    title: 'RoundedRectangles',
                                    group: 'Object'
                                },
                                {
                                    title: 'Texts',
                                    group: 'Object'
                                },
                                {
                                    title: 'Group',
                                    group: 'Object'
                                },
                            ]
                        },
                        {
                            title: 'Line',
                            group: 'Object'
                        },
                        {
                            title: 'Circle',
                            group: 'Object'
                        },
                        {
                            title: 'Ellipse',
                            group: 'Object'
                        },
                        {
                            title: 'Rectangle',
                            group: 'Object'
                        },
                        {
                            title: 'RoundedRectangle',
                            group: 'Object'
                        },
                        {
                            title: 'Text',
                            group: 'Object'
                        },
                        {
                            title: 'cImage',
                            group: 'Object'
                        },
                    ]
                },
                // subjects
                {
                    title: 'Subjects',
                    links:
                    [
                        {
                            title: 'Color',
                            links:
                            [
                                {
                                    title: 'Model',
                                    links:
                                    [
                                        {
                                            title: 'Rgb',
                                            group: 'Subject'
                                        },
                                    ]
                                },
                                {
                                    title: 'Gradient',
                                    links:
                                    [
                                        {
                                            title: 'Properties',
                                            links:
                                            [
                                                {
                                                    title: 'Stop',
                                                    group: 'Subject'
                                                }
                                            ]
                                        },
                                        {
                                            title: 'Linear',
                                            group: 'Subject'
                                        },
                                        {
                                            title: 'Radial',
                                            group: 'Subject'
                                        },
                                        {
                                            title: 'Conic',
                                            group: 'Subject'
                                        },
                                    ]
                                }
                            ]
                        },
                        // {
                        //     title: 'Templates',
                        //     links:
                        //     [
                        //         {
                        //             title: 'SacredCircles',
                        //             group: 'Subject'
                        //         },
                        //     ]
                        // },
                        {
                            title: 'Staging',
                            links:
                            [
                                {
                                    title: 'Anchor',
                                    group: 'Subject'
                                },
                                {
                                    title: 'Angle',
                                    group: 'Subject'
                                },
                                {
                                    title: 'Aspect',
                                    group: 'Subject'
                                },
                                {
                                    title: 'ControlPoints',
                                    group: 'Subject'
                                },
                                {
                                    title: 'Font',
                                    group: 'Subject'
                                },
                                {
                                    title: 'Point',
                                    group: 'Subject'
                                },
                            ]
                        },
                        {
                            title: 'Stroke',
                            group: 'Subject'
                        },
                        {
                            title: 'Fill',
                            group: 'Subject'
                        },
                        {
                            title: 'Shadow',
                            group: 'Subject'
                        },
                    ]
                },
            ]
        },
        // templates
        {
            title: 'Templates',
            links:
            [
                {
                    title: 'SacredCircles',
                    group: 'Template'
                },
            ]
        },
        // Animations
        {
            title: 'Animations',
            links:
            [
                // objects
                {
                    title: 'Objects',
                    links:
                    [
                        {
                            title:   'Line',
                            group:   'Object',
                            handler: 'Animation'
                        },
                        {
                            title:   'Circle',
                            group:   'Object',
                            handler: 'Animation'
                        },
                        {
                            title:   'Ellipse',
                            group:   'Object',
                            handler: 'Animation'
                        },
                        {
                            title:   'Rectangle',
                            group:   'Object',
                            handler: 'Animation'
                        },
                        {
                            title:   'RoundedRectangle',
                            group:   'Object',
                            handler: 'Animation'
                        },
                        {
                            title:   'Text',
                            group:   'Object',
                            handler: 'Animation'
                        },
                        {
                            title:   'cImage',
                            group:   'Object',
                            handler: 'Animation'
                        }
                    ]
                },
                // subjects
                {
                    title: 'Subjects',
                    links:
                    [
                        {
                            title: 'Color',
                            links:
                            [
                                {
                                    title: 'Model',
                                    links:
                                    [
                                        {
                                            title:   'Rgb',
                                            group:   'Subject',
                                            handler: 'Animation'
                                        },
                                    ]
                                },
                                {
                                    title: 'Gradient',
                                    links:
                                    [
                                        {
                                            title: 'Properties',
                                            links:
                                            [
                                                {
                                                    title:   'Stop',
                                                    group:   'Subject',
                                                    handler: 'Animation'
                                                }
                                            ]
                                        },
                                        {
                                            title:   'Linear',
                                            group:   'Subject',
                                            handler: 'Animation'
                                        },
                                        {
                                            title:   'Radial',
                                            group:   'Subject',
                                            handler: 'Animation'
                                        },
                                        {
                                            title:   'Conic',
                                            group:   'Subject',
                                            handler: 'Animation'
                                        },
                                    ]
                                }
                            ]
                        },
                        // {
                        //     title: 'Templates',
                        //     links:
                        //     [
                        //         {
                        //             title: 'SacredCircles',
                        //             group: 'Subject',
                        //             handler: 'Animation'
                        //         },
                        //     ]
                        // },
                        {
                            title: 'Staging',
                            links:
                            [
                                {
                                    title:   'Anchor',
                                    group:   'Subject',
                                    handler: 'Animation'
                                },
                                {
                                    title:   'Angle',
                                    group:   'Subject',
                                    handler: 'Animation'
                                },
                                {
                                    title:   'Aspect',
                                    group:   'Subject',
                                    handler: 'Animation'
                                },
                                {
                                    title:   'ControlPoints',
                                    group:   'Subject',
                                    handler: 'Animation'
                                },
                                {
                                    title:   'Font',
                                    group:   'Subject',
                                    handler: 'Animation'
                                },
                                {
                                    title:   'Point',
                                    group:   'Subject',
                                    handler: 'Animation'
                                },
                            ]
                        },
                        {
                            title:   'Stroke',
                            group:   'Subject',
                            handler: 'Animation'
                        },
                        {
                            title:   'Fill',
                            group:   'Subject',
                            handler: 'Animation'
                        },
                        {
                            title:   'Shadow',
                            group:   'Subject',
                            handler: 'Animation'
                        },
                    ]
                },
                // templates
                {
                    title: 'Templates',
                    links:
                    [
                        {
                            title:   'SacredCircles',
                            group:   'Template',
                            handler: 'Animation'
                        },
                    ]
                },
            ]
        },
    ]

    /**
     * Object of demo cards
     * @type {Object.<Object>}
     * @example { type: { subType: [ { title: 'title', text: 'text', code: function } ] } }
     */
    let _cardObjects =
    {
        object:
        {
            line:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _line.draw ( );
                    }
                },
                // stroke type
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _line.stroke.type = 'solid';

                        _line.draw ( );
                    }
                },
                // stroke segments
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _line.stroke.segments = [ 2, 7, 10 ];

                        _line.draw ( );
                    }
                },
                // stroke color
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _line.stroke.color = new Rgb ( 0,  150,  200 );

                        _line.draw ( );
                    }
                },
                // stroke alpha
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _line.stroke.color.alpha = 0.25;

                        _line.draw ( );
                    }
                },
                // stroke width
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _line.stroke.width = 5;

                        _line.draw ( );
                    }
                },
                // stroke cap
                {
                    title:   'stroke cap',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _line.stroke.width = 5;

                        _line.lineCap = 'butt';

                        _line.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.draw ( );
                    }
                },
                // shadow color
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow', 'rgb' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.shadow.color = new Rgb ( 0, 150, 200 );

                        _line.draw ( );
                    }
                },
                // shadow blur
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.shadow.blur = 10;

                        _line.draw ( );
                    }
                },
                // shadow offset
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow', 'point' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.shadow.x = 5;

                        _line.shadow.y = 5;

                        _line.draw ( );
                    }
                },
                // curve
                {
                    title:   'curve',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _line.curve ( 50, 0, 0, 0 );

                        _line.draw ( );
                    }
                },
                // move
                {
                    title:   'move',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _line.move ( 90, 25 );

                        _line.draw ( );
                    }
                },
                // rotate
                {
                    title:   'rotate',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _line.rotate ( 45 );

                        _line.draw ( );
                    }
                },
                // anchor
                {
                    title:   'anchor',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _line.options.anchor = true;

                        _line.draw ( );
                    }
                },
                // anchor align
                {
                    title:   'anchor align',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _line.options.anchor = true;

                        _line.anchor.align   = 'start';

                        _line.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _line.options.border = true;

                        _line.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _line.options.axis = true;

                        _line.draw ( );
                    }
                },
                // points
                {
                    title:   'points',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _line.options.points = true;

                        _line.draw ( );
                    }
                },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _line.options.coordinates = true;

                        _line.draw ( );
                    }
                },
                // control points
                {
                    title:   'control points',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'controlpoints' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;  // [ Optional ]

                        _line.controlPoints.points  = [ 50, 0, 0, -50 ];

                        _line.draw ( );
                    }
                },
            ],
            lines:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _lines.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _lines.options.shadow = true;

                        _lines.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _lines.options.border = true;

                        _lines.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _lines.options.axis = true;

                        _lines.draw ( );
                    }
                },
                // anchor
                // {
                //     title:   'anchor',
                //     text:    'blah... blah... blah...',
                //     children: [ 'line' ],
                //     code: ( ) =>
                //     {
                //         _lines.options.anchor   = true;

                //         _lines.draw ( );
                //     }
                // },
                // points
                {
                    title:   'points',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _lines.options.points = true;

                        _lines.draw ( );
                    }
                },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _lines.options.coordinates = true;

                        _lines.draw ( );
                    }
                },
                // controlPoints
                {
                    title:   'controlPoints',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _lines.options.controlPoints = true;

                        _lines.draw ( );
                    }
                },
            ],
            circle:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _circle.draw ( );
                    }
                },
                // radius
                {
                    title:   'radius',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _circle.radius = 50;

                        _circle.draw ( );
                    }
                },
                // radius ellipse
                {
                    title:   'radius ellipse',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _circle.radius = { x: 25, y: 50 };

                        _circle.draw ( );
                    }
                },
                // angle start
                {
                    title:   'angle start',
                    text:    'blah... blah... blah...',
                    children: [ 'angle' ],
                    code: ( ) =>
                    {
                        _circle.angle.start = 90;

                        _circle.draw ( );
                    }
                },
                // angle end
                {
                    title:   'angle end',
                    text:    'blah... blah... blah...',
                    children: [ 'angle' ],
                    code: ( ) =>
                    {
                        _circle.angle.start = 90;

                        _circle.angle.end   = 180;

                        _circle.draw ( );
                    }
                },
                // angle clockwise
                {
                    title:   'angle clockwise',
                    text:    'blah... blah... blah...',
                    children: [ 'angle' ],
                    code: ( ) =>
                    {
                        _circle.angle.start = 90;

                        _circle.angle.end   = 180;

                        _circle.angle.clockwise = false;

                        _circle.draw ( );
                    }
                },
                // stroke type
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _circle.stroke.type = 'solid';

                        _circle.draw ( );
                    }
                },
                // stroke segments
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _circle.stroke.segments = [ 2, 4 ];

                        _circle.draw ( );
                    }
                },
                // stroke color
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.stroke.color = new Rgb ( 0,  150,  200 );

                        _circle.draw ( );
                    }
                },
                // stroke alpha
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.stroke.color.alpha = 0.25;

                        _circle.draw ( );
                    }
                },
                // stroke width
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _circle.stroke.width = 5;

                        _circle.draw ( );
                    }
                },
                // fill color
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.color = new Rgb ( 0,  150,  200 );

                        _circle.draw ( );
                    }
                },
                // fill alpha
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.color = new Rgb ( 0,  150,  200 );

                        _circle.fill.color.alpha = 0.25;

                        _circle.draw ( );
                    }
                },
                // fill linear
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill radial
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'radial', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill conic
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'conic', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill pattern
                {
                    title:   'fill pattern',
                    text:    'blah... blah... blah...',
                    children: [ 'fill' ],
                    code: ( ) =>
                    {
                        _circle.radius = 50;    // [ Optional ]

                        _circle.fill.pattern = 'images/png/sun.png';

                        _circle.draw ( );
                    }
                },
                // fill pattern no-repeat
                {
                    title:   'fill pattern no-repeat',
                    text:    'blah... blah... blah...',
                    children: [ 'fill' ],
                    code: ( ) =>
                    {
                        _circle.radius = 50;    // [ Optional ]

                        _circle.fill.pattern    = 'images/png/sun.png';

                        _circle.fill.repetition = 'no-repeat';

                        _circle.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.draw ( );
                    }
                },
                // shadow color
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.shadow.color = new Rgb ( 0, 150, 200 );

                        _circle.draw ( );
                    }
                },
                // shadow blur
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.shadow.blur = 10;

                        _circle.draw ( );
                    }
                },
                // shadow offset
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.shadow.x = 5;

                        _circle.shadow.y = 5;

                        _circle.draw ( );
                    }
                },
                // move
                {
                    title:   'move',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _circle.move ( 90, 25 );

                        _circle.draw ( );
                    }
                },
                // rotate
                {
                    title:   'rotate',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _circle.rotate ( 45 );

                        _circle.draw ( );
                    }
                },
                // anchor
                {
                    title:   'anchor',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.draw ( );
                    }
                },
                // anchor align
                {
                    title:   'anchor align',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align   = 'topLeft';

                        _circle.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _circle.options.border = true;

                        _circle.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _circle.options.axis = true;

                        _circle.draw ( );
                    }
                },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _circle.options.coordinates = true;

                        _circle.draw ( );
                    }
                },
            ],
            circles:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circles.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circles.options.shadow = true;

                        _circles.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circles.options.border = true;

                        _circles.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circles.options.axis = true;

                        _circles.draw ( );
                    }
                },
                // anchor
                // {
                //     title:   'anchor',
                //     text:    'blah... blah... blah...',
                //     children: [ 'circle' ],
                //     code: ( ) =>
                //     {
                //         _circles.options.anchor   = true;

                //         _circles.draw ( );
                //     }
                // },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circles.options.coordinates = true;

                        _circles.draw ( );
                    }
                },
            ],
            ellipse:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _ellipse.draw ( );
                    }
                },
                // radius
                {
                    title:   'radius',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _ellipse.radius = new Point ( 50, 30 );

                        _ellipse.draw ( );
                    }
                },
                // radius ellipse
                // {
                //     title:   'radius ellipse',
                //     text:    'blah... blah... blah...',
                //     children: undefined,
                //     code: ( ) =>
                //     {
                //         _ellipse.radius = { x: 25, y: 50 };

                //         _ellipse.draw ( );
                //     }
                // },
                // angle start
                {
                    title:   'angle start',
                    text:    'blah... blah... blah...',
                    children: [ 'angle' ],
                    code: ( ) =>
                    {
                        _ellipse.angle.start = 90;

                        _ellipse.draw ( );
                    }
                },
                // angle end
                {
                    title:   'angle end',
                    text:    'blah... blah... blah...',
                    children: [ 'angle' ],
                    code: ( ) =>
                    {
                        _ellipse.angle.start = 90;

                        _ellipse.angle.end   = 180;

                        _ellipse.draw ( );
                    }
                },
                // angle clockwise
                {
                    title:   'angle clockwise',
                    text:    'blah... blah... blah...',
                    children: [ 'angle' ],
                    code: ( ) =>
                    {
                        _ellipse.angle.start = 90;

                        _ellipse.angle.end   = 180;

                        _ellipse.angle.clockwise = false;

                        _ellipse.draw ( );
                    }
                },
                // stroke type
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.type = 'solid';

                        _ellipse.draw ( );
                    }
                },
                // stroke segments
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.segments = [ 2, 4 ];

                        _ellipse.draw ( );
                    }
                },
                // stroke color
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.color = new Rgb ( 0,  150,  200 );

                        _ellipse.draw ( );
                    }
                },
                // stroke alpha
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.color.alpha = 0.25;

                        _ellipse.draw ( );
                    }
                },
                // stroke width
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.width = 5;

                        _ellipse.draw ( );
                    }
                },
                // fill color
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.color = new Rgb ( 0,  150,  200 );

                        _ellipse.draw ( );
                    }
                },
                // fill alpha
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.color = new Rgb ( 0,  150,  200 );

                        _ellipse.fill.color.alpha = 0.25;

                        _ellipse.draw ( );
                    }
                },
                // fill linear
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill radial
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'radial', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill conic
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'conic', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill pattern
                {
                    title:   'fill pattern',
                    text:    'blah... blah... blah...',
                    children: [ 'fill' ],
                    code: ( ) =>
                    {
                        _ellipse.radius = new Point ( 70, 50 );    // [ Optional ]

                        _ellipse.fill.pattern = 'images/png/sun.png';

                        _ellipse.draw ( );
                    }
                },
                // fill pattern no-repeat
                {
                    title:   'fill pattern no-repeat',
                    text:    'blah... blah... blah...',
                    children: [ 'fill' ],
                    code: ( ) =>
                    {
                        _ellipse.radius = new Point ( 70, 50 );    // [ Optional ]

                        _ellipse.fill.pattern    = 'images/png/sun.png';

                        _ellipse.fill.repetition = 'no-repeat';

                        _ellipse.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.draw ( );
                    }
                },
                // shadow color
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.shadow.color = new Rgb ( 0, 150, 200 );

                        _ellipse.draw ( );
                    }
                },
                // shadow blur
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.shadow.blur = 10;

                        _ellipse.draw ( );
                    }
                },
                // shadow offset
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.shadow.x = 5;

                        _ellipse.shadow.y = 5;

                        _ellipse.draw ( );
                    }
                },
                // move
                {
                    title:   'move',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _ellipse.move ( 90, 25 );

                        _ellipse.draw ( );
                    }
                },
                // rotate
                {
                    title:   'rotate',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _ellipse.rotate ( 45 );

                        _ellipse.draw ( );
                    }
                },
                // anchor
                {
                    title:   'anchor',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.draw ( );
                    }
                },
                // anchor align
                {
                    title:   'anchor align',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align   = 'topLeft';

                        _ellipse.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _ellipse.options.border = true;

                        _ellipse.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _ellipse.options.axis = true;

                        _ellipse.draw ( );
                    }
                },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _ellipse.options.coordinates = true;

                        _ellipse.draw ( );
                    }
                },
            ],
            ellipses:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipses.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipses.options.shadow = true;

                        _ellipses.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipses.options.border = true;

                        _ellipses.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipses.options.axis = true;

                        _ellipses.draw ( );
                    }
                },
                // anchor
                // {
                //     title:   'anchor',
                //     text:    'blah... blah... blah...',
                //     children: [ 'ellipse' ],
                //     code: ( ) =>
                //     {
                //         _ellipses.options.anchor   = true;

                //         _ellipses.draw ( );
                //     }
                // },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipses.options.coordinates = true;

                        _ellipses.draw ( );
                    }
                },
            ],
            rectangle:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _rectangle.draw ( );
                    }
                },
                // aspect
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'aspect' ],
                    code: ( ) =>
                    {
                        _rectangle.aspect = { width: 200, height: 100 };

                        _rectangle.draw ( );
                    }
                },
                // radii general
                {
                    title:   'rounded general',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _rectangle.round = [ 10 ];

                        _rectangle.draw ( );
                    }
                },
                // radii specific
                {
                    title:   'rounded specific',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _rectangle.round = [ 0, 10, 0, 20 ];

                        _rectangle.draw ( );
                    }
                },
                // stroke type
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.type = 'solid';

                        _rectangle.draw ( );
                    }
                },
                // stroke segments
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.segments = [ 2, 4 ];

                        _rectangle.draw ( );
                    }
                },
                // stroke color
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.color = new Rgb ( 0,  150,  200 );

                        _rectangle.draw ( );
                    }
                },
                // stroke alpha
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.alpha = 0.25;

                        _rectangle.draw ( );
                    }
                },
                // stroke width
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.width = 5;

                        _rectangle.draw ( );
                    }
                },
                // fill color
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _rectangle.draw ( );
                    }
                },
                // fill alpha
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _rectangle.fill.color.alpha = 0.25;

                        _rectangle.draw ( );
                    }
                },
                // fill linear
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill radial
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'radial', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill conic
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'conic', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill pattern
                {
                    title:   'fill pattern',
                    text:    'blah... blah... blah...',
                    children: [ 'fill' ],
                    code: ( ) =>
                    {
                        _rectangle.aspect = { width: 200, height: 100 };    // [ Optional ]

                        _rectangle.fill.pattern = 'images/png/sun.png';

                        _rectangle.draw ( );
                    }
                },
                // fill pattern no-repeat
                {
                    title:   'fill pattern no-repeat',
                    text:    'blah... blah... blah...',
                    children: [ 'fill' ],
                    code: ( ) =>
                    {
                        _rectangle.aspect = { width: 200, height: 100 };    // [ Optional ]

                        _rectangle.fill.pattern    = 'images/png/sun.png';

                        _rectangle.fill.repetition = 'no-repeat';

                        _rectangle.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.draw ( );
                    }
                },
                // shadow color
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.shadow.color = new Rgb ( 0, 150, 200 );

                        _rectangle.draw ( );
                    }
                },
                // shadow blur
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.shadow.blur = 10;

                        _rectangle.draw ( );
                    }
                },
                // shadow offset
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.shadow.x = 5;

                        _rectangle.shadow.y = 5;

                        _rectangle.draw ( );
                    }
                },
                // move
                {
                    title:   'move',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _rectangle.move ( 90, 25 );

                        _rectangle.draw ( );
                    }
                },
                // rotate
                {
                    title:   'rotate',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _rectangle.rotate ( 45 );

                        _rectangle.draw ( );
                    }
                },
                // anchor
                {
                    title:   'anchor',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.draw ( );
                    }
                },
                // anchor align
                {
                    title:   'anchor align',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align   = 'topLeft';

                        _rectangle.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _rectangle.options.border = true;

                        _rectangle.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _rectangle.options.axis = true;

                        _rectangle.draw ( );
                    }
                },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _rectangle.options.coordinates = true;

                        _rectangle.draw ( );
                    }
                },
            ],
            rectangles:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangles.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangles.options.shadow = true;

                        _rectangles.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangles.options.border = true;

                        _rectangles.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangles.options.axis = true;

                        _rectangles.draw ( );
                    }
                },
                // anchor
                // {
                //     title:   'anchor',
                //     text:    'blah... blah... blah...',
                //     children: [ 'rectangle' ],
                //     code: ( ) =>
                //     {
                //         _rectangles.options.anchor   = true;

                //         _rectangles.draw ( );
                //     }
                // },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangles.options.coordinates = true;

                        _rectangles.draw ( );
                    }
                },
            ],
            roundedRectangle:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _roundedRectangle.draw ( );
                    }
                },
                // aspect
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'aspect' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.aspect = { width: 200, height: 100 };

                        _roundedRectangle.draw ( );
                    }
                },
                // round general
                // {
                //     title:   'round general',
                //     text:    'blah... blah... blah...',
                //     children: undefined,
                //     code: ( ) =>
                //     {
                //         _roundedRectangle.round = [ 10 ];

                //         _roundedRectangle.draw ( );
                //     }
                // },
                // round specific
                // {
                //     title:   'round specific',
                //     text:    'blah... blah... blah...',
                //     children: undefined,
                //     code: ( ) =>
                //     {
                //         _roundedRectangle.round = [ 0, 10, 0, 20 ];

                //         _roundedRectangle.draw ( );
                //     }
                // },
                // stroke type
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.type = 'solid';

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke segments
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.segments = [ 2, 4 ];

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke color
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.color = new Rgb ( 0,  150,  200 );

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke alpha
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.alpha = 0.25;

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke width
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.width = 5;

                        _roundedRectangle.draw ( );
                    }
                },
                // fill color
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _roundedRectangle.draw ( );
                    }
                },
                // fill alpha
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _roundedRectangle.fill.color.alpha = 0.25;

                        _roundedRectangle.draw ( );
                    }
                },
                // fill linear
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill radial
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'radial', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill conic
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'conic', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill pattern
                {
                    title:   'fill pattern',
                    text:    'blah... blah... blah...',
                    children: [ 'fill' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.aspect = { width: 200, height: 100 };    // [ Optional ]

                        _roundedRectangle.fill.pattern = 'images/png/sun.png';

                        _roundedRectangle.draw ( );
                    }
                },
                // fill pattern no-repeat
                {
                    title:   'fill pattern no-repeat',
                    text:    'blah... blah... blah...',
                    children: [ 'fill' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.aspect = { width: 200, height: 100 };    // [ Optional ]

                        _roundedRectangle.fill.pattern    = 'images/png/sun.png';

                        _roundedRectangle.fill.repetition = 'no-repeat';

                        _roundedRectangle.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.draw ( );
                    }
                },
                // shadow color
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.shadow.color = new Rgb ( 0, 150, 200 );

                        _roundedRectangle.draw ( );
                    }
                },
                // shadow blur
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.shadow.blur = 10;

                        _roundedRectangle.draw ( );
                    }
                },
                // shadow offset
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.shadow.x = 5;

                        _roundedRectangle.shadow.y = 5;

                        _roundedRectangle.draw ( );
                    }
                },
                // move
                {
                    title:   'move',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _roundedRectangle.move ( 90, 25 );

                        _roundedRectangle.draw ( );
                    }
                },
                // rotate
                {
                    title:   'rotate',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _roundedRectangle.rotate ( 45 );

                        _roundedRectangle.draw ( );
                    }
                },
                // anchor
                {
                    title:   'anchor',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.draw ( );
                    }
                },
                // anchor align
                {
                    title:   'anchor align',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align   = 'topLeft';

                        _roundedRectangle.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.border = true;

                        _roundedRectangle.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.axis = true;

                        _roundedRectangle.draw ( );
                    }
                },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.coordinates = true;

                        _roundedRectangle.draw ( );
                    }
                },
            ],
            roundedRectangles:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangles.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangles.options.shadow = true;

                        _roundedRectangles.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangles.options.border = true;

                        _roundedRectangles.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangles.options.axis = true;

                        _roundedRectangles.draw ( );
                    }
                },
                // anchor
                // {
                //     title:   'anchor',
                //     text:    'blah... blah... blah...',
                //     children: [ 'roundedrectangle' ],
                //     code: ( ) =>
                //     {
                //         _roundedRectangles.options.anchor   = true;

                //         _roundedRectangles.draw ( );
                //     }
                // },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangles.options.coordinates = true;

                        _roundedRectangles.draw ( );
                    }
                },
            ],
            text:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _text.draw ( );
                    }
                },
                // text
                {
                    title:   'text',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _text.text = '!@#$%^&*'

                        _text.draw ( );
                    }
                },
                // type
                {
                    title:   'type',
                    text:    'blah... blah... blah...',
                    children: [ 'font' ],
                    code: ( ) =>
                    {
                        _text.type = 'Courier New';

                        _text.draw ( );
                    }
                },
                // size
                {
                    title:   'size',
                    text:    'blah... blah... blah...',
                    children: [ 'font' ],
                    code: ( ) =>
                    {
                        _text.size = 36;

                        _text.draw ( );
                    }
                },
                // weight
                {
                    title:   'weight',
                    text:    'blah... blah... blah...',
                    children: [ 'font' ],
                    code: ( ) =>
                    {
                        _text.weight = 'italic';

                        _text.draw ( );
                    }
                },
                // maxWidth
                {
                    title:   'maxWidth',
                    text:    'blah... blah... blah...',
                    children: [ 'font' ],
                    code: ( ) =>
                    {
                        _text.maxWidth = 100;

                        _text.draw ( );
                    }
                },
                // offset
                {
                    title:   'offset',
                    text:    'blah... blah... blah...',
                    children: [ 'font' ],
                    code: ( ) =>
                    {
                        _text.offset = { x: 0, y: -25 }

                        _text.draw ( );
                    }
                },
                // stroke type
                // {
                //     title:   'stroke type',
                //     text:    'blah... blah... blah...',
                //     children: [ 'stroke' ],
                //     code: ( ) =>
                //     {
                //         _text.stroke.type = 'solid';

                //         _text.draw ( );
                //     }
                // },
                // stroke segments
                // {
                //     title:   'stroke segments',
                //     text:    'blah... blah... blah...',
                //     children: [ 'stroke' ],
                //     code: ( ) =>
                //     {
                //         _text.stroke.segments  = [ 2, 7, 10 ];

                //         _text.fill.color.alpha = 0;         // [ Optional ]

                //         _text.draw ( );
                //     }
                // },
                // stroke color
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.stroke.width = 2;

                        _text.stroke.color = new Rgb ( 0,  150,  200 );

                        _text.draw ( );
                    }
                },
                // stroke alpha
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.stroke.width       = 1;

                        _text.stroke.color.alpha = 0.25;

                        _text.fill.color.alpha   = 0;       // [ Optional ]

                        _text.draw ( );
                    }
                },
                // stroke width
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _text.stroke.width     = 2;

                        _text.stroke.color     = new Rgb ( 0,  150,  200 ); // [ Optional ]

                        _text.fill.color.alpha = 0; // [ Optional ]

                        _text.draw ( );
                    }
                },
                // fill color
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.fill.color = new Rgb ( 0,  150,  200 );

                        _text.draw ( );
                    }
                },
                // fill alpha
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'fill', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.fill.color.alpha   = 0.25;

                        _text.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.draw ( );
                    }
                },
                // shadow color
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.shadow.color = new Rgb ( 0, 150, 200 );

                        _text.draw ( );
                    }
                },
                // shadow blur
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.shadow.blur    = 10;

                        _text.draw ( );
                    }
                },
                // shadow offset
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.shadow.x = 5;

                        _text.shadow.y = 5;

                        _text.draw ( );
                    }
                },
                // move
                {
                    title:   'move',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _text.move ( 90, 25 );

                        _text.draw ( );
                    }
                },
                // rotate
                {
                    title:   'rotate',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _text.rotate ( 45 );

                        _text.draw ( );
                    }
                },
                // anchor
                {
                    title:   'anchor',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'anchor' ],
                    code: ( ) =>
                    {
                        _text.options.anchor = true;

                        _text.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _text.options.border = true;

                        _text.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _text.options.axis = true;

                        _text.draw ( );
                    }
                },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _text.options.coordinates = true;

                        _text.draw ( );
                    }
                },
            ],
            texts:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _texts.draw ( );
                    }
                },
                // shadow
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _texts.options.shadow = true;

                        _texts.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _texts.options.border = true;

                        _texts.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _texts.options.axis = true;

                        _texts.draw ( );
                    }
                },
                // anchor
                // {
                //     title:   'anchor',
                //     text:    'blah... blah... blah...',
                //     children: [ 'text' ],
                //     code: ( ) =>
                //     {
                //         _texts.options.anchor   = true;

                //         _texts.draw ( );
                //     }
                // },
                // coordinates
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _texts.options.coordinates = true;

                        _texts.draw ( );
                    }
                },
            ],
            cImage:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.draw ( );
                    }
                },
                // primary point
                {
                    title:   'primary point',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.primary.point  = new Point  ( 154,  85 );

                        _image.primary.aspect = new Aspect (  91, 101 );     // [ Optional ]

                        _image.draw ( );
                    }
                },
                // secondary point
                {
                    title:   'secondary point',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.primary.point    = new Point  ( 154,  85 );  // [ Optional ]

                        _image.primary.aspect   = new Aspect (  91, 101 );

                        _image.secondary.point  = new Point  ( -10, -40 );

                        _image.secondary.aspect = new Aspect (  91, 101 );

                        _image.draw ( );
                    }
                },
                // primary aspect
                {
                    title:   'primary aspect',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.primary.point    = new Point  ( 100,  60 );  // [ Optional ]

                        _image.primary.aspect   = new Aspect ( 182, 202 );

                        _image.secondary.point  = new Point  (   0,   0 );

                        _image.secondary.aspect = new Aspect (  91, 101 );

                        _image.draw ( );
                    }
                },
                // secondary aspect
                {
                    title:   'secondary aspect',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.primary.point    = new Point  ( 100,  60 );  // [ Optional ]

                        _image.primary.aspect   = new Aspect (  91, 101 );

                        _image.secondary.point  = new Point  (   0,   0 );

                        _image.secondary.aspect = new Aspect ( 182, 202 );

                        _image.draw ( );
                    }
                },
                // move
                {
                    title:   'move',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.move ( 90, 25 );

                        _image.draw ( );
                    }
                },
                // rotate
                {
                    title:   'rotate',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.rotate ( 45 );

                        _image.draw ( );
                    }
                },
                // anchor
                {
                    title:   'anchor',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.draw ( );
                    }
                },
                // anchor align
                {
                    title:   'anchor align',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align   = 'topLeft';

                        _image.draw ( );
                    }
                },
                // axis
                {
                    title:   'axis',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.options.axis = true;

                        _image.draw ( );
                    }
                },
                // border
                {
                    title:   'border',
                    text:    'blah... blah... blah...',
                    children: undefined,
                    code: ( ) =>
                    {
                        _image.options.border = true;

                        _image.draw ( );
                    }
                },
                // coordinates
                // {
                //     title:   'coordinates',
                //     text:    'blah... blah... blah...',
                //     children: [ 'options' ],
                //     code: ( ) =>
                //     {
                //         _image.options.coordinates = true;

                //         _image.draw ( );
                //     }
                // },
            ],
            group:
            [
                // draw
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'circle', 'ellipse', 'rectangle', 'roundedrectangle' ],
                    code: ( ) =>
                    {
                        _group.draw ( );
                    }
                },
            ]
        },
        subject:
        {
            anchor:
            [
                // Align : circle
                {
                    title:   'Align',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.draw ( );
                    }
                },
                // Align Top : circle
                {
                    title:   'Align Top',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align = 'top';

                        _circle.draw ( );
                    }
                },
                // Align Top-Right : circle
                {
                    title:   'Align Top-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align = 'topRight';

                        _circle.draw ( );
                    }
                },
                // Align Right : circle
                {
                    title:   'Align Right',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align = 'right';

                        _circle.draw ( );
                    }
                },
                // Align Bottom-Right : circle
                {
                    title:   'Align Bottom-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align = 'bottomRight';

                        _circle.draw ( );
                    }
                },
                // Align Bottom : circle
                {
                    title:   'Align Bottom',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align = 'bottom';

                        _circle.draw ( );
                    }
                },
                // Align Bottom-Left : circle
                {
                    title:   'Align Bottom-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align = 'bottomLeft';

                        _circle.draw ( );
                    }
                },
                // Align Left : circle
                {
                    title:   'Align Left',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align = 'left';

                        _circle.draw ( );
                    }
                },
                // Align Top-Left : circle
                {
                    title:   'Align Top-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.options.anchor = true;

                        _circle.anchor.align = 'topLeft';

                        _circle.draw ( );
                    }
                },

                // Align : ellipse
                {
                    title:   'Align',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.draw ( );
                    }
                },
                // Align Top : ellipse
                {
                    title:   'Align Top',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align = 'top';

                        _ellipse.draw ( );
                    }
                },
                // Align Top-Right : ellipse
                {
                    title:   'Align Top-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align = 'topRight';

                        _ellipse.draw ( );
                    }
                },
                // Align Right : ellipse
                {
                    title:   'Align Right',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align = 'right';

                        _ellipse.draw ( );
                    }
                },
                // Align Bottom-Right : ellipse
                {
                    title:   'Align Bottom-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align = 'bottomRight';

                        _ellipse.draw ( );
                    }
                },
                // Align Bottom : ellipse
                {
                    title:   'Align Bottom',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align = 'bottom';

                        _ellipse.draw ( );
                    }
                },
                // Align Bottom-Left : ellipse
                {
                    title:   'Align Bottom-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align = 'bottomLeft';

                        _ellipse.draw ( );
                    }
                },
                // Align Left : ellipse
                {
                    title:   'Align Left',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align = 'left';

                        _ellipse.draw ( );
                    }
                },
                // Align Top-Left : ellipse
                {
                    title:   'Align Top-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.options.anchor = true;

                        _ellipse.anchor.align = 'topLeft';

                        _ellipse.draw ( );
                    }
                },

                // Align : rectangle
                {
                    title:   'Align',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.draw ( );
                    }
                },
                // Align Top : rectangle
                {
                    title:   'Align Top',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align = 'top';

                        _rectangle.draw ( );
                    }
                },
                // Align Top-Right : rectangle
                {
                    title:   'Align Top-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align = 'topRight';

                        _rectangle.draw ( );
                    }
                },
                // Align Right : rectangle
                {
                    title:   'Align Right',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align = 'right';

                        _rectangle.draw ( );
                    }
                },
                // Align Bottom-Right : rectangle
                {
                    title:   'Align Bottom-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align = 'bottomRight';

                        _rectangle.draw ( );
                    }
                },
                // Align Bottom : rectangle
                {
                    title:   'Align Bottom',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align = 'bottom';

                        _rectangle.draw ( );
                    }
                },
                // Align Bottom-Left : rectangle
                {
                    title:   'Align Bottom-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align = 'bottomLeft';

                        _rectangle.draw ( );
                    }
                },
                // Align Left : rectangle
                {
                    title:   'Align Left',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align = 'left';

                        _rectangle.draw ( );
                    }
                },
                // Align Top-Left : rectangle
                {
                    title:   'Align Top-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.options.anchor = true;

                        _rectangle.anchor.align = 'topLeft';

                        _rectangle.draw ( );
                    }
                },

                // Align : roundedRectangle
                {
                    title:   'Align',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.draw ( );
                    }
                },
                // Align Top : roundedRectangle
                {
                    title:   'Align Top',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align = 'top';

                        _roundedRectangle.draw ( );
                    }
                },
                // Align Top-Right : roundedRectangle
                {
                    title:   'Align Top-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align = 'topRight';

                        _roundedRectangle.draw ( );
                    }
                },
                // Align Right : roundedRectangle
                {
                    title:   'Align Right',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align = 'right';

                        _roundedRectangle.draw ( );
                    }
                },
                // Align Bottom-Right : roundedRectangle
                {
                    title:   'Align Bottom-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align = 'bottomRight';

                        _roundedRectangle.draw ( );
                    }
                },
                // Align Bottom : roundedRectangle
                {
                    title:   'Align Bottom',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align = 'bottom';

                        _roundedRectangle.draw ( );
                    }
                },
                // Align Bottom-Left : roundedRectangle
                {
                    title:   'Align Bottom-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align = 'bottomLeft';

                        _roundedRectangle.draw ( );
                    }
                },
                // Align Left : roundedRectangle
                {
                    title:   'Align Left',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align = 'left';

                        _roundedRectangle.draw ( );
                    }
                },
                // Align Top-Left : roundedRectangle
                {
                    title:   'Align Top-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.anchor = true;

                        _roundedRectangle.anchor.align = 'topLeft';

                        _roundedRectangle.draw ( );
                    }
                },

                // Align : image
                {
                    title:   'Align',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.draw ( );
                    }
                },
                // Align Top : image
                {
                    title:   'Align Top',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align = 'top';

                        _image.draw ( );
                    }
                },
                // Align Top-Right : image
                {
                    title:   'Align Top-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align = 'topRight';

                        _image.draw ( );
                    }
                },
                // Align Right : image
                {
                    title:   'Align Right',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align = 'right';

                        _image.draw ( );
                    }
                },
                // Align Bottom-Right : image
                {
                    title:   'Align Bottom-Right',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align = 'bottomRight';

                        _image.draw ( );
                    }
                },
                // Align Bottom : image
                {
                    title:   'Align Bottom',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align = 'bottom';

                        _image.draw ( );
                    }
                },
                // Align Bottom-Left : image
                {
                    title:   'Align Bottom-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align = 'bottomLeft';

                        _image.draw ( );
                    }
                },
                // Align Left : image
                {
                    title:   'Align Left',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align = 'left';

                        _image.draw ( );
                    }
                },
                // Align Top-Left : image
                {
                    title:   'Align Top-Left',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.options.anchor = true;

                        _image.anchor.align = 'topLeft';

                        _image.draw ( );
                    }
                },
            ],
            angle:
            [
                // angle start : circle
                {
                    title:   'angle start',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.angle.start = 90;

                        _circle.draw ( );
                    }
                },
                // angle end : circle
                {
                    title:   'angle end',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.angle.start = 90;

                        _circle.angle.end   = 180;

                        _circle.draw ( );
                    }
                },
                // angle clockwise : circle
                {
                    title:   'angle clockwise',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.angle.start = 90;

                        _circle.angle.end   = 180;

                        _circle.angle.clockwise = false;

                        _circle.draw ( );
                    }
                },
                // angle clockwise : circle
                {
                    title:   'angle clockwise',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.angle.start = 180;

                        _circle.angle.end   = 360;

                        _circle.angle.clockwise = false;

                        _circle.draw ( );
                    }
                },

                // angle start : ellipse
                {
                    title:   'angle start',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.angle.start = 90;

                        _ellipse.draw ( );
                    }
                },
                // angle end : ellipse
                {
                    title:   'angle end',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.angle.start = 90;

                        _ellipse.angle.end   = 180;

                        _ellipse.draw ( );
                    }
                },
                // angle clockwise : ellipse
                {
                    title:   'angle clockwise',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.angle.start = 90;

                        _ellipse.angle.end   = 180;

                        _ellipse.angle.clockwise = false;

                        _ellipse.draw ( );
                    }
                },
                // angle clockwise : ellipse
                {
                    title:   'angle clockwise',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.angle.start = 180;

                        _ellipse.angle.end   = 360;

                        _ellipse.angle.clockwise = false;

                        _ellipse.draw ( );
                    }
                },
            ],
            aspect:
            [
                // aspect : rectangle
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.aspect = { width: 100, height: 100 };

                        _rectangle.draw ( );
                    }
                },
                // aspect : rectangle
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.aspect = { width: 25, height: 25 };

                        _rectangle.draw ( );
                    }
                },
                // aspect : rectangle
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.aspect = { width: 100, height: 50 };

                        _rectangle.draw ( );
                    }
                },
                // aspect : rectangle
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.aspect = { width: 50, height: 100 };

                        _rectangle.draw ( );
                    }
                },

                // aspect : roundedRectangle
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.aspect = { width: 100, height: 100 };

                        _roundedRectangle.draw ( );
                    }
                },
                // aspect : roundedRectangle
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.aspect = { width: 25, height: 25 };

                        _roundedRectangle.draw ( );
                    }
                },
                // aspect : roundedRectangle
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.aspect = { width: 100, height: 50 };

                        _roundedRectangle.draw ( );
                    }
                },
                // aspect : roundedRectangle
                {
                    title:   'aspect',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.aspect = { width: 50, height: 100 };

                        _roundedRectangle.draw ( );
                    }
                },
            ],
            controlpoints:
            [
                // control points p0
                {
                    title:   'control points p0',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;  // [ Optional ]

                        _line.controlPoints.p0      = 50;

                        _line.draw ( );
                    }
                },
                // control points p1
                {
                    title:   'control points p1',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;  // [ Optional ]

                        _line.controlPoints.p1      = 50;

                        _line.draw ( );
                    }
                },
                // control points p2
                {
                    title:   'control points p2',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;  // [ Optional ]

                        _line.controlPoints.p2      = 50;

                        _line.draw ( );
                    }
                },
                // control points p3
                {
                    title:   'control points',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;

                        _line.controlPoints.p3      = 50;

                        _line.draw ( );
                    }
                },
                // control points
                {
                    title:   'control points',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;  // [ Optional ]

                        _line.controlPoints.points  = [ 50, 50, 50, 50 ];

                        _line.draw ( );
                    }
                },
                // control points
                {
                    title:   'control points',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;  // [ Optional ]

                        _line.controlPoints.points  = [ -50, 50, -50, 50 ];

                        _line.draw ( );
                    }
                },
                // control points
                {
                    title:   'control points',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;  // [ Optional ]

                        _line.controlPoints.points  = [ 50, -50, 50, -50 ];

                        _line.draw ( );
                    }
                },
                // control points
                {
                    title:   'control points',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;

                        _line.controlPoints.points  = [ -50, -50, -50, -50 ];

                        _line.draw ( );
                    }
                },
                // curve
                {
                    title:   'curve',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.options.controlPoints = true;  // [ Optional ]

                        _line.curve ( 50, 50, 50, 50 );

                        _line.draw ( );
                    }
                },
            ],
            fill:
            [
                // fill color : circle
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.color = new Rgb ( 0,  150,  200 );

                        _circle.draw ( );
                    }
                },
                // fill linear : circle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill radial : circle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'radial', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Radial ( { x: 110, y: 90 }, 30, { x: 100, y: 100 }, 70 );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill conic : circle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'conic', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Conic ( 0, { x: 75, y: 155 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill pattern : circle
                {
                    title:   'fill pattern',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.radius = 50;    // [ Optional ]

                        _circle.fill.pattern = 'images/png/sun.png';

                        _circle.draw ( );
                    }
                },
                // fill pattern no-repeat : circle
                // {
                //     title:   'fill pattern no-repeat',
                //     text:    'blah... blah... blah...',
                //     children: [ 'circle' ],
                //     code: ( ) =>
                //     {
                //         _circle.radius = 50;    // [ Optional ]

                //         _circle.fill.pattern    = 'images/png/sun.png';

                //         _circle.fill.repetition = 'no-repeat';

                //         _circle.draw ( );
                //     }
                // },

                // fill color : ellipse
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.color = new Rgb ( 0,  150,  200 );

                        _ellipse.draw ( );
                    }
                },
                // fill linear : ellipse
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill radial : ellipse
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'radial', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Radial ( { x: 110, y: 90 }, 30, { x: 100, y: 100 }, 70 );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill conic : ellipse
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'conic', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Conic ( 0, { x: 75, y: 155 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill pattern : ellipse
                {
                    title:   'fill pattern',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.radius = new Point ( 70, 50 );  // [ Optional ]

                        _ellipse.fill.pattern = 'images/png/sun.png';

                        _ellipse.draw ( );
                    }
                },
                // fill pattern no-repeat : ellipse
                // {
                //     title:   'fill pattern no-repeat',
                //     text:    'blah... blah... blah...',
                //     children: [ 'ellipse' ],
                //     code: ( ) =>
                //     {
                //         _ellipse.radius = 50;    // [ Optional ]

                //         _ellipse.fill.pattern    = 'images/png/sun.png';

                //         _ellipse.fill.repetition = 'no-repeat';

                //         _ellipse.draw ( );
                //     }
                // },

                // fill color : rectangle
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _rectangle.draw ( );
                    }
                },
                // fill linear : rectangle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill radial : rectangle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Radial ( { x: 110, y: 90 }, 30, { x: 100, y: 100 }, 70 );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill conic : rectangle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'conic', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Conic ( 0, { x: 75, y: 155 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    },
                },
                // fill pattern : rectangle
                {
                    title:   'fill pattern',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.aspect = new Aspect ( 200, 100 );  // [ Optional ]

                        _rectangle.fill.pattern = 'images/png/sun.png';

                        _rectangle.draw ( );
                    }
                },
                // fill pattern no-repeat : rectangle
                // {
                //     title:   'fill pattern no-repeat',
                //     text:    'blah... blah... blah...',
                //     children: [ 'rectangle' ],
                //     code: ( ) =>
                //     {
                //         _rectangle.radius = 50;    // [ Optional ]

                //         _rectangle.fill.pattern    = 'images/png/sun.png';

                //         _rectangle.fill.repetition = 'no-repeat';

                //         _rectangle.draw ( );
                //     }
                // },

                // fill color : roundedRectangle
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _roundedRectangle.draw ( );
                    }
                },
                // fill linear : roundedRectangle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill radial : roundedRectangle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle', 'linear', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Radial ( { x: 110, y: 90 }, 30, { x: 100, y: 100 }, 70 );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill conic : roundedRectangle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle', 'conic', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Conic ( 0, { x: 75, y: 155 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    },
                },
                // fill pattern : roundedrectangle
                {
                    title:   'fill pattern',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedrectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.aspect = new Aspect ( 200, 100 );  // [ Optional ]

                        _roundedRectangle.fill.pattern = 'images/png/sun.png';

                        _roundedRectangle.draw ( );
                    }
                },
                // // fill pattern no-repeat : roundedRectangle
                // {
                //     title:   'fill pattern no-repeat',
                //     text:    'blah... blah... blah...',
                //     children: [ 'roundedrectangle' ],
                //     code: ( ) =>
                //     {
                //         _roundedRectangle.radius = 50;    // [ Optional ]

                //         _roundedRectangle.fill.pattern    = 'images/png/sun.png';

                //         _roundedRectangle.fill.repetition = 'no-repeat';

                //         _roundedRectangle.draw ( );
                //     }
                // },

                // fill color : text
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _text.fill.color = new Rgb ( 0,   150, 200, 1 );

                        _text.draw ( );
                    }
                },
                // fill linear : text
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _text.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _text.draw ( );
                    }
                },
                // fill radial : text
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _text.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _text.draw ( );
                    }
                },
                // fill conic : text
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _text.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _text.draw ( );
                    }
                },
            ],
            font:
            [
                // type
                {
                    title:   'type',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _text.type = 'Courier New';

                        _text.draw ( );
                    }
                },
                // size
                {
                    title:   'size',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _text.size = 36;

                        _text.draw ( );
                    }
                },
                // weight
                {
                    title:   'weight',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _text.weight = 'italic';

                        _text.draw ( );
                    }
                },
                // maxWidth
                {
                    title:   'maxWidth',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _text.maxWidth = 100;

                        _text.draw ( );
                    }
                },
                // offset
                {
                    title:   'offset',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _text.offset = { x: 0, y: -25 }

                        _text.draw ( );
                    }
                },
            ],
            point:
            [
                // draw : line
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.draw ( );
                    }
                },
                // shadow offset : line
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.shadow.x = 5;

                        _line.shadow.y = 5;

                        _line.draw ( );
                    }
                },
                // points : line
                {
                    title:   'points',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _line.options.points = true;

                        _line.draw ( );
                    }
                },
                // coordinates : line
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _line.options.coordinates = true;

                        _line.draw ( );
                    }
                },

                // draw : circle
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.draw ( );
                    }
                },
                // shadow offset : circle
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.shadow.x = 5;

                        _circle.shadow.y = 5;

                        _circle.draw ( );
                    }
                },
                // coordinates : circle
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _circle.options.coordinates = true;

                        _circle.draw ( );
                    }
                },

                // draw : ellipse
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.draw ( );
                    }
                },
                // shadow offset : ellipse
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.shadow.x = 5;

                        _ellipse.shadow.y = 5;

                        _ellipse.draw ( );
                    }
                },
                // coordinates : ellipse
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _ellipse.options.coordinates = true;

                        _ellipse.draw ( );
                    }
                },

                // draw : rectangle
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.draw ( );
                    }
                },
                // shadow offset : rectangle
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.shadow.x = 5;

                        _rectangle.shadow.y = 5;

                        _rectangle.draw ( );
                    }
                },
                // coordinates : rectangle
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _rectangle.options.coordinates = true;

                        _rectangle.draw ( );
                    }
                },

                // draw : roundedRectangle
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.draw ( );
                    }
                },
                // shadow offset : roundedRectangle
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.shadow.x = 5;

                        _roundedRectangle.shadow.y = 5;

                        _roundedRectangle.draw ( );
                    }
                },
                // coordinates : roundedRectangle
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.coordinates = true;

                        _roundedRectangle.draw ( );
                    }
                },

                // draw : text
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'text' ],
                    code: ( ) =>
                    {
                        _text.draw ( );
                    }
                },
                // offset : text
                {
                    title:   'offset',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'font' ],
                    code: ( ) =>
                    {
                        _text.offset = { x: 0, y: -25 }

                        _text.draw ( );
                    }
                },
                // shadow offset : text
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.shadow.x = 5;

                        _text.shadow.y = 5;

                        _text.draw ( );
                    }
                },
                // coordinates : text
                {
                    title:   'coordinates',
                    text:    'blah... blah... blah...',
                    children: [ 'options' ],
                    code: ( ) =>
                    {
                        _text.options.coordinates = true;

                        _text.draw ( );
                    }
                },

                // draw : cImage
                {
                    title:   'draw',
                    text:    'blah... blah... blah...',
                    children: [ 'cimage' ],
                    code: ( ) =>
                    {
                        _image.draw ( );
                    }
                },
            ],
            linear:
            [
                // fill linear : circle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },

                // fill linear : ellipse
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },

                // fill linear : rectangle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },

                // fill linear : roundedRectangle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },

                // fill linear : text
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _text.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _text.draw ( );
                    }
                },
            ],
            radial:
            [
                // fill radial : circle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },

                // fill radial : ellipse
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },

                // fill radial : rectangle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },

                // fill radial : roundedRectangle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },

                // fill radial : text
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _text.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _text.draw ( );
                    }
                },
            ],
            conic:
            [
                // fill conic : circle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },

                // fill conic : ellipse
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },

                // fill conic : rectangle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },

                // fill conic : roundedRectangle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },

                // fill conic : text
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'fill', 'stop', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _text.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _text.draw ( );
                    }
                },
            ],
            rgb:
            [
                // stroke color : line
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'stroke' ],
                    code: ( ) =>
                    {
                        _line.stroke.color = new Rgb ( 0,  150,  200 );

                        _line.draw ( );
                    }
                },
                // stroke alpha : line
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'stroke' ],
                    code: ( ) =>
                    {
                        _line.stroke.color.alpha = 0.25;

                        _line.draw ( );
                    }
                },

                // stroke color : circle
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'stroke' ],
                    code: ( ) =>
                    {
                        _circle.stroke.color = new Rgb ( 0,  150,  200 );

                        _circle.draw ( );
                    }
                },
                // stroke alpha : circle
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'stroke' ],
                    code: ( ) =>
                    {
                        _circle.stroke.color.alpha = 0.25;

                        _circle.draw ( );
                    }
                },
                // fill color : circle
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill' ],
                    code: ( ) =>
                    {
                        _circle.fill.color = new Rgb ( 0,  150,  200 );

                        _circle.draw ( );
                    }
                },
                // fill alpha : circle
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill' ],
                    code: ( ) =>
                    {
                        _circle.fill.color = new Rgb ( 0,  150,  200 );

                        _circle.fill.color.alpha = 0.25;

                        _circle.draw ( );
                    }
                },
                // fill linear : circle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'linear', 'stop' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill radial : circle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'radial', 'stop' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill conic : circle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'conic', 'stop' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },

                // stroke color : ellipse
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'stroke' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.color = new Rgb ( 0,  150,  200 );

                        _ellipse.draw ( );
                    }
                },
                // stroke alpha : ellipse
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'stroke' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.color.alpha = 0.25;

                        _ellipse.draw ( );
                    }
                },
                // fill color : ellipse
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.color = new Rgb ( 0,  150,  200 );

                        _ellipse.draw ( );
                    }
                },
                // fill alpha : ellipse
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.color = new Rgb ( 0,  150,  200 );

                        _ellipse.fill.color.alpha = 0.25;

                        _ellipse.draw ( );
                    }
                },
                // fill linear : ellipse
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'linear', 'stop' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill radial : ellipse
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'radial', 'stop' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill conic : ellipse
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'conic', 'stop' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },

                // stroke color : rectangle
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'stroke' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.color = new Rgb ( 0,  150,  200 );

                        _rectangle.draw ( );
                    }
                },
                // stroke alpha : rectangle
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'stroke' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.alpha = 0.25;

                        _rectangle.draw ( );
                    }
                },
                // fill color : rectangle
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _rectangle.draw ( );
                    }
                },
                // fill alpha : rectangle
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _rectangle.fill.color.alpha = 0.25;

                        _rectangle.draw ( );
                    }
                },
                // fill linear : rectangle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'linear', 'stop' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill radial : rectangle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'radial', 'stop' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill conic : rectangle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'conic', 'stop' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },

                // stroke color : roundedRectangle
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'stroke' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.color = new Rgb ( 0,  150,  200 );

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke alpha : roundedRectangle
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'stroke' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.alpha = 0.25;

                        _roundedRectangle.draw ( );
                    }
                },
                // fill color : roundedRectangle
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _roundedRectangle.draw ( );
                    }
                },
                // fill alpha : roundedRectangle
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.color = new Rgb ( 0,  150,  200 );

                        _roundedRectangle.fill.color.alpha = 0.25;

                        _roundedRectangle.draw ( );
                    }
                },
                // fill linear : roundedRectangle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'linear', 'stop' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill radial : roundedRectangle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'radial', 'stop' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill conic : roundedRectangle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'conic', 'stop' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },

                // stroke color : text
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'stroke' ],
                    code: ( ) =>
                    {
                        _text.stroke.width = 1;

                        _text.stroke.color = new Rgb ( 0,  150,  200 );

                        _text.draw ( );
                    }
                },
                // stroke alpha : text
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'stroke' ],
                    code: ( ) =>
                    {
                        _text.stroke.width       = 1;

                        _text.stroke.color.alpha = 0.5;

                        _text.fill.color.alpha   = 0;       // [ Optional ]

                        _text.draw ( );
                    }
                },
                // fill color : text
                {
                    title:   'fill color',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'fill' ],
                    code: ( ) =>
                    {
                        _text.fill.color = new Rgb ( 0,  150,  200 );

                        _text.draw ( );
                    }
                },
                // fill alpha : text
                {
                    title:   'fill alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'fill' ],
                    code: ( ) =>
                    {
                        _text.fill.color.alpha = 0.25;

                        _text.draw ( );
                    }
                },
            ],
            shadow:
            [
                // shadow : line
                {
                    title:   'line',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'options' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.draw ( );
                    }
                },
                // shadow color : line
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.shadow.color = new Rgb ( 0, 150, 200 );

                        _line.draw ( );
                    }
                },
                // shadow alpha : line
                {
                    title:   'shadow alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.shadow.color.alpha = 0.5;

                        _line.draw ( );
                    }
                },
                // shadow blur : line
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'options' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.shadow.blur = 10;

                        _line.draw ( );
                    }
                },
                // shadow offset : line
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'options' ],
                    code: ( ) =>
                    {
                        _line.options.shadow = true;

                        _line.shadow.x = 5;

                        _line.shadow.y = 5;

                        _line.draw ( );
                    }
                },

                // shadow : circle
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'options' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.draw ( );
                    }
                },
                // shadow color : circle
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.shadow.color = new Rgb ( 0, 150, 200 );

                        _circle.draw ( );
                    }
                },
                // shadow alpha : circle
                {
                    title:   'shadow alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.shadow.color.alpha = 0.5;

                        _circle.draw ( );
                    }
                },
                // shadow blur : circle
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'options' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.shadow.blur = 10;

                        _circle.draw ( );
                    }
                },
                // shadow offset : circle
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'options' ],
                    code: ( ) =>
                    {
                        _circle.options.shadow = true;

                        _circle.shadow.x = 5;

                        _circle.shadow.y = 5;

                        _circle.draw ( );
                    }
                },

                // shadow : ellipse
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'options' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.draw ( );
                    }
                },
                // shadow color : ellipse
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.shadow.color = new Rgb ( 0, 150, 200 );

                        _ellipse.draw ( );
                    }
                },
                // shadow alpha : ellipse
                {
                    title:   'shadow alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.shadow.color.alpha = 0.5;

                        _ellipse.draw ( );
                    }
                },
                // shadow blur : ellipse
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'options' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.shadow.blur = 10;

                        _ellipse.draw ( );
                    }
                },
                // shadow offset : ellipse
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'options' ],
                    code: ( ) =>
                    {
                        _ellipse.options.shadow = true;

                        _ellipse.shadow.x = 5;

                        _ellipse.shadow.y = 5;

                        _ellipse.draw ( );
                    }
                },

                // shadow : rectangle
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'options' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.draw ( );
                    }
                },
                // shadow color : rectangle
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.shadow.color = new Rgb ( 0, 150, 200 );

                        _rectangle.draw ( );
                    }
                },
                // shadow alpha : rectangle
                {
                    title:   'shadow alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.shadow.color.alpha = 0.5;

                        _rectangle.draw ( );
                    }
                },
                // shadow blur : rectangle
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'options' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.shadow.blur = 10;

                        _rectangle.draw ( );
                    }
                },
                // shadow offset : rectangle
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'options' ],
                    code: ( ) =>
                    {
                        _rectangle.options.shadow = true;

                        _rectangle.shadow.x = 5;

                        _rectangle.shadow.y = 5;

                        _rectangle.draw ( );
                    }
                },

                // shadow : roundedRectangle
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'options' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.draw ( );
                    }
                },
                // shadow color : roundedRectangle
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.shadow.color = new Rgb ( 0, 150, 200 );

                        _roundedRectangle.draw ( );
                    }
                },
                // shadow alpha : roundedRectangle
                {
                    title:   'shadow alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.shadow.color.alpha = 0.5;

                        _roundedRectangle.draw ( );
                    }
                },
                // shadow blur : roundedRectangle
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'options' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.shadow.blur = 10;

                        _roundedRectangle.draw ( );
                    }
                },
                // shadow offset : roundedRectangle
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'options' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.options.shadow = true;

                        _roundedRectangle.shadow.x = 5;

                        _roundedRectangle.shadow.y = 5;

                        _roundedRectangle.draw ( );
                    }
                },

                // shadow : text
                {
                    title:   'shadow',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'options' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.draw ( );
                    }
                },
                // shadow color : text
                {
                    title:   'shadow color',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.shadow.color = new Rgb ( 0, 150, 200 );

                        _text.draw ( );
                    }
                },
                // shadow alpha : text
                {
                    title:   'shadow alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'options', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.shadow.color.alpha = 0.5;

                        _text.draw ( );
                    }
                },
                // shadow blur : text
                {
                    title:   'shadow blur',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'options' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.shadow.blur = 10;

                        _text.draw ( );
                    }
                },
                // shadow offset : text
                {
                    title:   'shadow offset',
                    text:    'blah... blah... blah...',
                    children: [ 'options', 'shadow' ],
                    code: ( ) =>
                    {
                        _text.options.shadow = true;

                        _text.shadow.x = 5;

                        _text.shadow.y = 5;

                        _text.draw ( );
                    }
                },
            ],
            stop:
            [
                // fill linear : circle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'linear', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill radial : circle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'gradient', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },
                // fill conic : circle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'fill', 'conic', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _circle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _circle.draw ( );
                    }
                },

                // fill linear : ellipse
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'linear', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill radial : ellipse
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'radial', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },
                // fill conic : ellipse
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'fill', 'conic', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _ellipse.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _ellipse.draw ( );
                    }
                },

                // fill linear : rectangle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'linear', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill radial : rectangle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'radial', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },
                // fill conic : rectangle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'fill', 'conic', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _rectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _rectangle.draw ( );
                    }
                },

                // fill linear : roundedRectangle
                {
                    title:   'fill linear',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'linear', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0.5, color: new Rgb ( 0, 150, 200, 1 ) },
                            { offset: 1,   color: new Rgb ( 0,   0,   0, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill radial : roundedRectangle
                {
                    title:   'fill radial',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'radial', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,   color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.5, color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 1,   color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
                // fill conic : roundedRectangle
                {
                    title:   'fill conic',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'fill', 'conic', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                        _roundedRectangle.fill.gradient.stops =
                        [
                            { offset: 0,    color: new Rgb ( 0,   150, 200, 1 ) },
                            { offset: 0.25, color: new Rgb ( 50,  125, 175, 1 ) },
                            { offset: 0.5,  color: new Rgb ( 100, 100, 150, 1 ) },
                            { offset: 0.75, color: new Rgb ( 150,  75, 125, 1 ) },
                            { offset: 1,    color: new Rgb ( 200,  50, 100, 1 ) }
                        ];

                        _roundedRectangle.draw ( );
                    }
                },
            ],
            stroke:
            [
                // stroke type : line
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.stroke.type = 'solid';

                        _line.draw ( );
                    }
                },
                // stroke segments : line
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.stroke.segments = [ 2, 7, 10 ];

                        _line.draw ( );
                    }
                },
                // stroke color : line
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'rgb' ],
                    code: ( ) =>
                    {
                        _line.stroke.color = new Rgb ( 0,  150,  200 );

                        _line.draw ( );
                    }
                },
                // stroke alpha : line
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'line', 'rgb' ],
                    code: ( ) =>
                    {
                        _line.stroke.color.alpha = 0.25;

                        _line.draw ( );
                    }
                },
                // stroke width : line
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.stroke.width = 5;

                        _line.draw ( );
                    }
                },
                // stroke cap : line
                {
                    title:   'stroke cap',
                    text:    'blah... blah... blah...',
                    children: [ 'line' ],
                    code: ( ) =>
                    {
                        _line.stroke.width = 5;

                        _line.lineCap = 'butt';

                        _line.draw ( );
                    }
                },

                // stroke type : circle
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.stroke.type = 'solid';

                        _circle.draw ( );
                    }
                },
                // stroke segments : circle
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.stroke.segments = [ 2, 4 ];

                        _circle.draw ( );
                    }
                },
                // stroke color : circle
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.stroke.color = new Rgb ( 0,  150,  200 );

                        _circle.draw ( );
                    }
                },
                // stroke alpha : circle
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'circle', 'rgb' ],
                    code: ( ) =>
                    {
                        _circle.stroke.color.alpha = 0.25;

                        _circle.draw ( );
                    }
                },
                // stroke width : circle
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'circle' ],
                    code: ( ) =>
                    {
                        _circle.stroke.width = 5;

                        _circle.draw ( );
                    }
                },

                // stroke type : ellipse
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.type = 'solid';

                        _ellipse.draw ( );
                    }
                },
                // stroke segments : ellipse
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.segments = [ 2, 4 ];

                        _ellipse.draw ( );
                    }
                },
                // stroke color : ellipse
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.color = new Rgb ( 0,  150,  200 );

                        _ellipse.draw ( );
                    }
                },
                // stroke alpha : ellipse
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse', 'rgb' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.color.alpha = 0.25;

                        _ellipse.draw ( );
                    }
                },
                // stroke width : ellipse
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'ellipse' ],
                    code: ( ) =>
                    {
                        _ellipse.stroke.width = 5;

                        _ellipse.draw ( );
                    }
                },

                // stroke type : rectangle
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.type = 'solid';

                        _rectangle.draw ( );
                    }
                },
                // stroke segments : rectangle
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.segments = [ 2, 4 ];

                        _rectangle.draw ( );
                    }
                },
                // stroke color : rectangle
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.color = new Rgb ( 0,  150,  200 );

                        _rectangle.draw ( );
                    }
                },
                // stroke alpha : rectangle
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle', 'rgb' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.alpha = 0.25;

                        _rectangle.draw ( );
                    }
                },
                // stroke width : rectangle
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'rectangle' ],
                    code: ( ) =>
                    {
                        _rectangle.stroke.width = 5;

                        _rectangle.draw ( );
                    }
                },

                // stroke type : roundedRectangle
                {
                    title:   'stroke type',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.type = 'solid';

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke segments : roundedRectangle
                {
                    title:   'stroke segments',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.segments = [ 2, 4 ];

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke color : roundedRectangle
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.color = new Rgb ( 0,  150,  200 );

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke alpha : roundedRectangle
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle', 'rgb' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.alpha = 0.25;

                        _roundedRectangle.draw ( );
                    }
                },
                // stroke width : roundedRectangle
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'roundedRectangle' ],
                    code: ( ) =>
                    {
                        _roundedRectangle.stroke.width = 5;

                        _roundedRectangle.draw ( );
                    }
                },

                // stroke type
                // {
                //     title:   'stroke type',
                //     text:    'blah... blah... blah...',
                //     children: [ 'stroke' ],
                //     code: ( ) =>
                //     {
                //         _text.stroke.type = 'solid';

                //         _text.draw ( );
                //     }
                // },
                // stroke segments
                // {
                //     title:   'stroke segments',
                //     text:    'blah... blah... blah...',
                //     children: [ 'stroke' ],
                //     code: ( ) =>
                //     {
                //         _text.stroke.type = 'solid';

                //         _text.stroke.segments = [ 2, 7, 10 ];

                //         _text.draw ( );
                //     }
                // },
                // stroke color : text
                {
                    title:   'stroke color',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.stroke.color = new Rgb ( 0,  150,  200 );

                        _text.stroke.width = 1;

                        _text.draw ( );
                    }
                },
                // stroke alpha : text
                {
                    title:   'stroke alpha',
                    text:    'blah... blah... blah...',
                    children: [ 'text', 'rgb' ],
                    code: ( ) =>
                    {
                        _text.stroke.width       = 1;

                        _text.stroke.color.alpha = 0.5;

                        _text.fill.color.alpha   = 0;       // [ Optional ]

                        _text.draw ( );
                    }
                },
                // stroke width : text
                {
                    title:   'stroke width',
                    text:    'blah... blah... blah...',
                    children: [ 'stroke' ],
                    code: ( ) =>
                    {
                        _text.stroke.color = new Rgb ( 0,  150,  200 );  // [ Optional]

                        _text.stroke.width = 5;

                        _text.draw ( );
                    }
                },
            ]
        },
        template:
        {
            sacredcircles:
            [
                // draw everything
                {
                    title:   'Draw All',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'lines', 'circles', 'rectangles', 'texts', 'rgb' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        let _alpha      = 0.40;

                        let _colors     =
                        [
                            new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                            new Rgb (   0,  0,  255, _alpha ),      // Blue
                            new Rgb (   0, 255, 255, _alpha ),      // Cyan
                            new Rgb (   0, 255,   0, _alpha ),      // Green
                            new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                            new Rgb ( 255, 125,   0, _alpha ),      // Orange
                            new Rgb ( 255,   0,   0, _alpha ),      // Red
                            new Rgb (   0,   0,   0, _alpha ),      // Black
                        ]

                        let _fills   = new Array;

                        ////    POPULATION    //////////////////////////

                        let _group          = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), _colors );

                            _group.draw ( );

                    }
                },
                // draw circles
                {
                    title:   'Circles',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'circles', 'circle' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), new Rgb ( 0, 0, 0, 0 ) );

                            _group.circles.draw ( );
                    }
                },
                // draw circles & color
                {
                    title:   'Circles & Colors',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'circles', 'circle', 'rgb' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        let _alpha      = 0.40;

                        let _colors     =
                        [
                            new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                            new Rgb (   0,  0,  255, _alpha ),      // Blue
                            new Rgb (   0, 255, 255, _alpha ),      // Cyan
                            new Rgb (   0, 255,   0, _alpha ),      // Green
                            new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                            new Rgb ( 255, 125,   0, _alpha ),      // Orange
                            new Rgb ( 255,   0,   0, _alpha ),      // Red
                            new Rgb (   0,   0,   0, _alpha ),      // Black
                        ]

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), _colors );

                            _group.circles.draw ( );
                    }
                },
                // draw ellipses
                {
                    title:   'Ellipses',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'ellipses', 'ellipse' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), new Rgb ( 0, 0, 0, 0 ) );

                            _group.ellipses.draw ( );
                    }
                },
                // draw ellipses & color
                {
                    title:   'Ellipses & Colors',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'ellipses', 'ellipse', 'rgb' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        let _alpha      = 0.40;

                        let _colors     =
                        [
                            new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                            new Rgb (   0,  0,  255, _alpha ),      // Blue
                            new Rgb (   0, 255, 255, _alpha ),      // Cyan
                            new Rgb (   0, 255,   0, _alpha ),      // Green
                            new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                            new Rgb ( 255, 125,   0, _alpha ),      // Orange
                            new Rgb ( 255,   0,   0, _alpha ),      // Red
                            new Rgb (   0,   0,   0, _alpha ),      // Black
                        ]

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), _colors );

                            _group.ellipses.draw ( );
                    }
                },
                // draw rectangles
                {
                    title:   'Rectangles',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'rectangles', 'rectangle' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), new Rgb ( 0, 0, 0, 0 ) );

                            _group.rectangles.draw ( );
                    }
                },
                // draw rectangles & colors
                {
                    title:   'Rectangles & Colors',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'rectangles', 'rectangle', 'rgb' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        let _alpha      = 0.40;

                        let _colors     =
                        [
                            new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                            new Rgb (   0,  0,  255, _alpha ),      // Blue
                            new Rgb (   0, 255, 255, _alpha ),      // Cyan
                            new Rgb (   0, 255,   0, _alpha ),      // Green
                            new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                            new Rgb ( 255, 125,   0, _alpha ),      // Orange
                            new Rgb ( 255,   0,   0, _alpha ),      // Red
                            new Rgb (   0,   0,   0, _alpha ),      // Black
                        ]

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), _colors );

                            _group.rectangles.draw ( );
                    }
                },
                // draw rounded rectangles
                {
                    title:   'Rounded Rectangles',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'roundedrectangles', 'roundedrectangle' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), new Rgb ( 0, 0, 0, 0 ) );

                            _group.roundedRectangles.draw ( );
                    }
                },
                // draw rectangles & colors
                {
                    title:   'Rounded Rectangles & Colors',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'roundedrectangles', 'roundedrectangle', 'rgb' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        let _alpha      = 0.40;

                        let _colors     =
                        [
                            new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                            new Rgb (   0,  0,  255, _alpha ),      // Blue
                            new Rgb (   0, 255, 255, _alpha ),      // Cyan
                            new Rgb (   0, 255,   0, _alpha ),      // Green
                            new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                            new Rgb ( 255, 125,   0, _alpha ),      // Orange
                            new Rgb ( 255,   0,   0, _alpha ),      // Red
                            new Rgb (   0,   0,   0, _alpha ),      // Black
                        ]

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), _colors );

                            _group.roundedRectangles.draw ( );
                    }
                },
                // draw lines
                // {
                //     title:   'Lines',
                //     text:    'blah... blah... blah...',
                //     children: [ 'group', 'lines', 'line' ],
                //     code: ( ) =>
                //     {
                //         ////    INPUTS    //////////////////////////////

                //         let _center     = canvaslab.center;

                //         let _radius     = 25;

                //         let _iterations = 6;

                //         let _degrees    = [ 90, 330, 270, 210, 150, 90, 30 ];

                //         ////    POPULATION    //////////////////////////

                //         let _group = new Group;

                //             _group.canvas = 'canvas';

                //             _group.template = new SacredCircles ( _center, _radius, _iterations, _degrees, new Rgb ( 0, 0, 0, 1 ), new Rgb ( 0, 0, 0, 0 ) );

                //             _group.lines.draw ( );
                //     }
                // },
                // draw texts
                {
                    title:   'Texts',
                    text:    'blah... blah... blah...',
                    children: [ 'group', 'texts', 'text' ],
                    code: ( ) =>
                    {
                        ////    INPUTS    //////////////////////////////

                        let _center     = canvaslab.center;

                        let _radius     = 25;

                        let _iterations = 6;

                        ////    POPULATION    //////////////////////////

                        let _group = new Group;

                            _group.canvas   = 'canvas';

                            _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 0, 0, 0, 1 ), new Rgb ( 0, 0, 0, 0 ) );

                            _group.texts.draw ( );
                    }
                },
            ],
        },
        animation:
        {
            object:
            {
                line:
                [
                    // point -x
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _line.x - 25, _line.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _line.x, _line.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _line.x + 25, _line.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _line.x, _line.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 0째
                    {
                        title:   'Move 0째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 0, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 90째
                    {
                        title:   'Move 90째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 90, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 180째
                    {
                        title:   'Move 180째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 180, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 270째
                    {
                        title:   'Move 270째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 270, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // startPoint
                    {
                        title: 'Start Point',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    startPoint: new Point ( 100, 50 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // endPoint
                    {
                        title: 'End Point',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    endPoint: new Point ( 100, 50 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInSine',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                                _line.options.anchor = true;  // [ Optional ]

                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // // rotate anchor align
                    // {
                    //     title: 'rotate anchor align',
                    //     text: 'easeInSine',
                    //     code: ( ) =>
                    //     {
                    //         _line.options.anchor = true;  // [ Optional ]

                    //         _line.anchor.align   = 'start';

                    //         let _transition =
                    //         {
                    //             object: _line,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 rotate: 180,
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                    // stroke color
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow color
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.options.shadow = true;

                            _line.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.options.shadow     = true;

                            _line.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow' ],
                        code: ( ) =>
                        {
                            _line.options.shadow = true;


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'point' ],
                        code: ( ) =>
                        {
                            _line.options.shadow = true;


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // control points
                    {
                        title:   'control points',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'controlpoints' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;     // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    controlPoints: [ 50, 0, 0, 50 ]
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                circle:
                [
                    // point -x
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _circle.x - 25, _circle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _circle.x, _circle.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _circle.x + 25, _circle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _circle.x, _circle.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 0째
                    {
                        title:   'Move 0째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 0, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 90째
                    {
                        title:   'Move 90째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 90, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 180째
                    {
                        title:   'Move 180째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 180, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 270째
                    {
                        title:   'Move 270째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 270, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _circle.options.anchor = true;  // [ Optional ]

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _circle.options.anchor = true;  // [ Optional ]

                            _circle.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // radius
                    {
                        title: 'Radius',
                        text: 'easeInOutElastic',
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    radius: 50
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke color
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow color
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.options.shadow = true;

                            _circle.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.options.shadow     = true;

                            _circle.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.options.shadow = true;


                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'point' ],
                        code: ( ) =>
                        {
                            _circle.options.shadow = true;


                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'fill', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'fill', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'fill', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'fill', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'fill', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                ellipse:
                [
                    // point -x
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _ellipse.x - 25, _ellipse.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _ellipse.x, _ellipse.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _ellipse.x + 25, _ellipse.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _ellipse.x, _ellipse.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 0째
                    {
                        title:   'Move 0째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 0, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 90째
                    {
                        title:   'Move 90째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 90, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 180째
                    {
                        title:   'Move 180째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 180, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 270째
                    {
                        title:   'Move 270째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 270, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _ellipse.options.anchor = true;

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _ellipse.options.anchor = true;

                            _ellipse.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // // radius
                    // {
                    //     title: 'Radius',
                    //     text: 'easeInOutElastic',
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _ellipse,
                    //             timing: 'easeInOutElastic',
                    //             period: 1750,
                    //             change:
                    //             {
                    //                 radius: 50
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                    // stroke color
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow color
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.options.shadow = true;

                            _ellipse.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.options.shadow     = true;

                            _ellipse.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.options.shadow     = true;


                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.options.shadow     = true;


                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'fill', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'fill', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'fill', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                rectangle:
                [
                    // point -x
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _rectangle.x - 25, _rectangle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _rectangle.x, _rectangle.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _rectangle.x + 25, _rectangle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _rectangle.x, _rectangle.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 0째
                    {
                        title:   'Move 0째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 0, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 90째
                    {
                        title:   'Move 90째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 90, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 180째
                    {
                        title:   'Move 180째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 180, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 270째
                    {
                        title:   'Move 270째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 270, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // aspect
                    {
                        title:   'aspect',
                        text:    'blah... blah... blah...',
                        children: [ 'aspect' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    aspect: new Aspect ( 100, 100 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // aspect
                    {
                        title:   'aspect',
                        text:    'blah... blah... blah...',
                        children: [ 'aspect' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    aspect: new Aspect ( 25, 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _rectangle.options.anchor = true;

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _rectangle.options.anchor = true;

                            _rectangle.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke color
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow color
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.options.shadow = true;

                            _rectangle.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.options.shadow     = true;

                            _rectangle.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow' ],
                        code: ( ) =>
                        {
                            _rectangle.options.shadow     = true;


                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'point' ],
                        code: ( ) =>
                        {
                            _rectangle.options.shadow     = true;


                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'fill', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'fill', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'fill', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'fill', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'fill', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                roundedRectangle:
                [
                    // point -x
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _roundedRectangle.x - 25, _roundedRectangle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _roundedRectangle.x, _roundedRectangle.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _roundedRectangle.x + 25, _roundedRectangle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _roundedRectangle.x, _roundedRectangle.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 0째
                    {
                        title:   'Move 0째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 0, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 90째
                    {
                        title:   'Move 90째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 90, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 180째
                    {
                        title:   'Move 180째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 180, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 270째
                    {
                        title:   'Move 270째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 270, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // aspect
                    {
                        title:   'aspect',
                        text:    'blah... blah... blah...',
                        children: [ 'aspect' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    aspect: new Aspect ( 100, 100 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // aspect
                    {
                        title:   'aspect',
                        text:    'blah... blah... blah...',
                        children: [ 'aspect' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    aspect: new Aspect ( 25, 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.anchor = true;

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.anchor = true;

                            _roundedRectangle.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke color
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow color
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.shadow = true;

                            _roundedRectangle.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.shadow     = true;

                            _roundedRectangle.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.shadow     = true;


                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'options', 'shadow', 'point' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.shadow     = true;


                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'fill', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'fill', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'fill', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'fill', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'fill', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                text:
                [
                    // point -x
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _text.x - 25, _text.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _text.x, _text.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _text.x + 25, _text.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _text.x, _text.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 0째
                    {
                        title:   'Move 0째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 0, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 90째
                    {
                        title:   'Move 90째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 90, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 180째
                    {
                        title:   'Move 180째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 180, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 270째
                    {
                        title:   'Move 270째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 270, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _text.options.anchor = true;

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke color
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.stroke.width = 2;

                            _text.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.stroke.width = 2;

                            _text.stroke.color.alpha = 0;

                            _text.fill.color.alpha   = 0;   // [ Optional ]

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'fill', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'fill', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'fill', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'fill', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'fill', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                cImage:
                [
                    // point -x
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _image.x - 25, _image.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _image.x, _image.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _image.x + 25, _image.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'point' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _image.x, _image.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 0째
                    {
                        title:   'Move 0째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 0, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 90째
                    {
                        title:   'Move 90째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 90, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 180째
                    {
                        title:   'Move 180째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 180, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // move 270째
                    {
                        title:   'Move 270째',
                        text:    'blah... blah... blah...',
                        children: undefined,
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    move: { degree: 270, distance: 25 }
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _image.options.anchor = true;

                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'anchor' ],
                        code: ( ) =>
                        {
                            _image.options.anchor = true;

                            _image.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ]
            },
            subject:
            {
                anchor:
                [
                    // rotate anchor : line
                    {
                        title: 'rotate anchor',
                        text: 'easeInSine',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                                _line.options.anchor = true;  // [ Optional ]

                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // rotate anchor : circle
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            _circle.options.anchor = true;  // [ Optional ]

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align : circle
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            _circle.options.anchor = true;  // [ Optional ]

                            _circle.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // rotate anchor : ellipse
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            _ellipse.options.anchor = true;

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align : ellipse
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            _ellipse.options.anchor = true;

                            _ellipse.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // rotate anchor : rectangle
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            _rectangle.options.anchor = true;

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align : rectangle
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            _rectangle.options.anchor = true;

                            _rectangle.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // rotate anchor : roundedRectangle
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'roundedrectangle' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.anchor = true;

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align : roundedRectangle
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'roundedrectangle' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.anchor = true;

                            _roundedRectangle.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // rotate anchor : text
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'text' ],
                        code: ( ) =>
                        {
                            _text.options.anchor = true;

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // rotate anchor : cImage
                    {
                        title: 'Rotate Anchor',
                        text: 'easeInOutElastic',
                        children: [ 'cimage' ],
                        code: ( ) =>
                        {
                            _image.options.anchor = true;

                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // rotate anchor align : cImage
                    {
                        title: 'Rotate Anchor Align',
                        text: 'easeInOutElastic',
                        children: [ 'cimage' ],
                        code: ( ) =>
                        {
                            _image.options.anchor = true;

                            _image.anchor.align   = 'top';

                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    rotate: 180,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                angle:
                [
                    // angle start : circle
                    {
                        title:   'angle start',
                        text:    'blah... blah... blah...',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    angleStart: 360,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // angle end : circle
                    {
                        title:   'angle end',
                        text:    'blah... blah... blah...',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    angleEnd: 360,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // angle start & end : circle
                    {
                        title:   'angle start & end',
                        text:    'blah... blah... blah...',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    angleStart: 270,
                                    angleEnd: 90
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // angle start & end : circle
                    {
                        title:   'angle start & end',
                        text:    'blah... blah... blah...',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    angleStart: 90,
                                    angleEnd: 270
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // angle start : ellipse
                    {
                        title:   'angle start',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    angleStart: 360,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // angle end : ellipse
                    {
                        title:   'angle end',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    angleEnd: 360,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // angle start & end : ellipse
                    {
                        title:   'angle start & end',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    angleStart: 270,
                                    angleEnd: 90
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // angle start & end : ellipse
                    {
                        title:   'angle start & end',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    angleStart: 90,
                                    angleEnd: 270
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                aspect:
                [
                    // aspect : rectangle
                    {
                        title:   'aspect',
                        text:    'blah... blah... blah...',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    aspect: new Aspect ( 100, 100 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // aspect : rectangle
                    {
                        title:   'aspect',
                        text:    'blah... blah... blah...',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    aspect: new Aspect ( 25, 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // // aspect : rectangle
                    // {
                    //     title:   'aspect',
                    //     text:    'blah... blah... blah...',
                    //     children: [ 'rectangle' ],
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _rectangle,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 aspect: new Aspect ( 100, 25 )
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                    // // aspect : rectangle
                    // {
                    //     title:   'aspect',
                    //     text:    'blah... blah... blah...',
                    //     children: [ 'rectangle' ],
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _rectangle,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 aspect: new Aspect ( 25, 100 )
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                    // aspect width : rectangle
                    {
                        title:   'aspect width',
                        text:    'blah... blah... blah...',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    width: 100
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // // aspect width : rectangle
                    // {
                    //     title:   'aspect width',
                    //     text:    'blah... blah... blah...',
                    //     children: [ 'rectangle' ],
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _rectangle,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 width: 25
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                    // aspect height : rectangle
                    {
                        title:   'aspect height',
                        text:    'blah... blah... blah...',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    height: 100
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // // aspect height : rectangle
                    // {
                    //     title:   'aspect height',
                    //     text:    'blah... blah... blah...',
                    //     children: [ 'rectangle' ],
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _rectangle,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 height: 25
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },

                    // aspect : roundedRectangle
                    {
                        title:   'aspect',
                        text:    'blah... blah... blah...',
                        children: [ 'roundedRectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    aspect: new Aspect ( 100, 100 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // aspect : roundedRectangle
                    {
                        title:   'aspect',
                        text:    'blah... blah... blah...',
                        children: [ 'roundedRectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    aspect: new Aspect ( 25, 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // // aspect : roundedRectangle
                    // {
                    //     title:   'aspect',
                    //     text:    'blah... blah... blah...',
                    //     children: [ 'roundedRectangle' ],
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _roundedRectangle,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 aspect: new Aspect ( 100, 25 )
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                    // // aspect : roundedRectangle
                    // {
                    //     title:   'aspect',
                    //     text:    'blah... blah... blah...',
                    //     children: [ 'roundedRectangle' ],
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _roundedRectangle,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 aspect: new Aspect ( 25, 100 )
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                    // aspect width : roundedRectangle
                    {
                        title:   'aspect width',
                        text:    'blah... blah... blah...',
                        children: [ 'roundedRectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    width: 100
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // // aspect width : roundedRectangle
                    // {
                    //     title:   'aspect width',
                    //     text:    'blah... blah... blah...',
                    //     children: [ 'roundedRectangle' ],
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _roundedRectangle,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 width: 25
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                    // aspect height : roundedRectangle
                    {
                        title:   'aspect height',
                        text:    'blah... blah... blah...',
                        children: [ 'roundedRectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    height: 100
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // // aspect height : roundedRectangle
                    // {
                    //     title:   'aspect height',
                    //     text:    'blah... blah... blah...',
                    //     children: [ 'roundedRectangle' ],
                    //     code: ( ) =>
                    //     {
                    //         let _transition =
                    //         {
                    //             object: _roundedRectangle,
                    //             timing: 'easeInSine',
                    //             period: 2000,
                    //             change:
                    //             {
                    //                 height: 25
                    //             }
                    //         }

                    //         canvaslab.animate ( _transition );
                    //     }
                    // },
                ],
                controlpoints:
                [
                    // control points p0
                    {
                        title:   'control points p0',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    p0: 50
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // control points p1
                    {
                        title:   'control points p1',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    p1: 50
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // control points p2
                    {
                        title:   'control points p2',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    p2: 50
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // control points p3
                    {
                        title:   'control points p3',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    p3: 50
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // control points p[0]
                    {
                        title:   'control points p[0]',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    controlPoints: [ 50, 0, 0, 0 ]
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // control points p[1]
                    {
                        title:   'control points p[1]',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    controlPoints: [ 0, 50, 0, 0 ]
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // control points p[2]
                    {
                        title:   'control points p[2]',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    controlPoints: [ 0, 0, 50, 0 ]
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // control points p[3]
                    {
                        title:   'control points p[3]',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    controlPoints: [ 0, 0, 0, 50 ]
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // curve
                    {
                        title:   'curve',
                        text:    'blah... blah... blah...',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            _line.options.controlPoints = true;  // [ Optional ]


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 1000,
                                change:
                                {
                                    curve: [ 50, 50, 50, 50 ]
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                fill:
                [
                    // fill color : circle
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'circle', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : circle
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'circle', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : circle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'circle', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : circle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'circle', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : circle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'circle', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // fill color : ellipse
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : ellipse
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : ellipse
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : ellipse
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : ellipse
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // fill color : rectangle
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : rectangle
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : rectangle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : rectangle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : rectangle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // fill color : roundedRectangle
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : roundedRectangle
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : roundedRectangle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : roundedRectangle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : roundedRectangle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // fill color : text
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'text', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : text
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'text', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : text
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'text', 'linear', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : text
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'text', 'radial', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : text
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'text', 'conic', 'stop', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                font:
                [
                    // font size
                    {
                        title: 'font size',
                        text: 'easeInSine',
                        children: [ 'text' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fontSize: 36,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                point:
                [
                    // point -x : line
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _line.x - 25, _line.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y : line
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _line.x, _line.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x : line
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _line.x + 25, _line.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y : line
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'line' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _line.x, _line.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // point -x : circle
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _circle.x - 25, _circle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y : circle
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _circle.x, _circle.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x : circle
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _circle.x + 25, _circle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y : circle
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'circle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _circle.x, _circle.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // point -x : ellipse
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _ellipse.x - 25, _ellipse.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y : ellipse
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _ellipse.x, _ellipse.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x : ellipse
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _ellipse.x + 25, _ellipse.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y : ellipse
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'ellipse' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _ellipse.x, _ellipse.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // point -x : rectangle
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _rectangle.x - 25, _rectangle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y : rectangle
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _rectangle.x, _rectangle.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x : rectangle
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _rectangle.x + 25, _rectangle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y : rectangle
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'rectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _rectangle.x, _rectangle.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // point -x : roundedRectangle
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'roundedrectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _roundedRectangle.x - 25, _roundedRectangle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y : roundedRectangle
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'roundedrectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _roundedRectangle.x, _roundedRectangle.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x : roundedRectangle
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'roundedrectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _roundedRectangle.x + 25, _roundedRectangle.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y : roundedRectangle
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'roundedrectangle' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _roundedRectangle.x, _roundedRectangle.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // point -x : text
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'text' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _text.x - 25, _text.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y : text
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'text' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _text.x, _text.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x : text
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'text' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _text.x + 25, _text.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y : text
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'text' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _text.x, _text.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // point -x : cImage
                    {
                        title: 'Point -X',
                        text: 'easeInOutElastic',
                        children: [ 'cimage' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _image.x - 25, _image.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point -y : cImage
                    {
                        title: 'Point -Y',
                        text: 'easeInOutElastic',
                        children: [ 'cimage' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _image.x, _image.y - 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +x : cImage
                    {
                        title: 'Point +X',
                        text: 'easeInOutElastic',
                        children: [ 'cimage' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _image.x + 25, _image.y )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // point +y : cImage
                    {
                        title: 'Point +Y',
                        text: 'easeInOutElastic',
                        children: [ 'cimage' ],
                        code: ( ) =>
                        {
                            let _transition =
                            {
                                object: _image,
                                timing: 'easeInOutElastic',
                                period: 1750,
                                change:
                                {
                                    point: new Point ( _image.x, _image.y + 25 )
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                linear:
                [
                    // gradient linear : circle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient linear : ellipse
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient linear : rectangle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient linear : roundedRectangle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient linear : text
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                radial:
                [
                    // gradient radial : circle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient radial : ellipse
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient radial : rectangle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient radial : roundedRectangle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient radial : text
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                conic:
                [
                    // gradient conic : circle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient conic : ellipse
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient conic : rectangle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient conic : roundedRectangle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient conic : text
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'stop' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                rgb:
                [
                    // stroke color : line
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'line', 'stroke' ],
                        code: ( ) =>
                        {
                            _line.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : line
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'line', 'stroke' ],
                        code: ( ) =>
                        {
                            _line.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : circle
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'circle', 'stroke' ],
                        code: ( ) =>
                        {
                            _circle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : circle
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'circle', 'stroke' ],
                        code: ( ) =>
                        {
                            _circle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color : circle
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill' ],
                        code: ( ) =>
                        {
                            _circle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : circle
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill' ],
                        code: ( ) =>
                        {
                            _circle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : circle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'linear', 'stop' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : circle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'radial', 'stop' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : circle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'conic', 'stop' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : ellipse
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'stroke' ],
                        code: ( ) =>
                        {
                            _ellipse.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : ellipse
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'stroke' ],
                        code: ( ) =>
                        {
                            _ellipse.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color : ellipse
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : ellipse
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : ellipse
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'linear', 'stop' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : ellipse
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'radial', 'stop' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : ellipse
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'conic', 'stop' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : rectangle
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'stroke' ],
                        code: ( ) =>
                        {
                            _rectangle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : rectangle
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'stroke' ],
                        code: ( ) =>
                        {
                            _rectangle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color : rectangle
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : rectangle
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : rectangle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'linear', 'stop' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : rectangle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'radial', 'stop' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : rectangle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'conic', 'stop' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : roundedRectangle
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'roundedRectangle', 'stroke' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : roundedRectangle
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'roundedRectangle', 'stroke' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color : roundedRectangle
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'roundedRectangle', 'fill' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : roundedRectangle
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'roundedRectangle', 'fill' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : roundedRectangle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'roundedRectangle', 'fill', 'linear', 'stop' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : roundedRectangle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'roundedRectangle', 'fill', 'radial', 'stop' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : roundedRectangle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'roundedRectangle', 'fill', 'conic', 'stop' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : text
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'text', 'stroke' ],
                        code: ( ) =>
                        {
                            _text.stroke.width = 2;

                            _text.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : text
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'text', 'stroke' ],
                        code: ( ) =>
                        {
                            _text.stroke.width = 2;

                            _text.stroke.color.alpha = 0;

                            _text.fill.color.alpha   = 0;   // [ Optional ]

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill color : text
                    {
                        title: 'Fill Color',
                        text: 'easeInSine',
                        children: [ 'text', 'fill' ],
                        code: ( ) =>
                        {
                            _text.fill.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // fill alpha : text
                    {
                        title: 'Fill Alpha',
                        text: 'easeInSine',
                        children: [ 'text', 'fill' ],
                        code: ( ) =>
                        {
                            _text.fill.color.alpha = 0;

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient linear : text
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'linear', 'stop' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : text
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'radial', 'stop' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : text
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'conic', 'stop' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                shadow:
                [
                    // shadow color : line
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'line', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.options.shadow = true;

                            _line.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha : line
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'line', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.options.shadow     = true;

                            _line.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur : line
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'line', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.options.shadow     = true;


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset : line
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'line', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.options.shadow     = true;


                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // shadow color : circle
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.options.shadow = true;

                            _circle.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha : circle
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.options.shadow     = true;

                            _circle.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur : circle
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.options.shadow     = true;


                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset : circle
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.options.shadow     = true;


                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // shadow color : ellipse
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.options.shadow = true;

                            _ellipse.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha : ellipse
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.options.shadow     = true;

                            _ellipse.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur : ellipse
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.options.shadow     = true;


                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset : ellipse
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'ellipse', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.options.shadow     = true;


                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // shadow color : rectangle
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'rectangle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.options.shadow = true;

                            _rectangle.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha : rectangle
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'rectangle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.options.shadow     = true;

                            _rectangle.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur : rectangle
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'rectangle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.options.shadow     = true;


                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset : rectangle
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'rectangle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.options.shadow     = true;


                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // shadow color : roundedRectangle
                    {
                        title:   'shadow color',
                        text:    'blah... blah... blah...',
                        children: [ 'roundedRectangle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.shadow = true;

                            _roundedRectangle.shadow.color   = new Rgb ( 0, 150, 200 );


                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow alpha : roundedRectangle
                    {
                        title:   'shadow alpha',
                        text:    'blah... blah... blah...',
                        children: [ 'roundedRectangle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.shadow     = true;

                            _roundedRectangle.shadow.color.alpha = 0;


                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowAlpha: 1,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow blur : roundedRectangle
                    {
                        title:   'shadow blur',
                        text:    'blah... blah... blah...',
                        children: [ 'roundedRectangle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.shadow     = true;


                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowBlur: 12,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // shadow offset : roundedRectangle
                    {
                        title:   'shadow offset',
                        text:    'blah... blah... blah...',
                        children: [ 'roundedRectangle', 'options', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.options.shadow     = true;


                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    shadowOffset: new Point ( 10, 10 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                stop:
                [
                    // gradient linear : circle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'linear' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : circle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'radial' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : circle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'circle', 'fill', 'conic' ],
                        code: ( ) =>
                        {
                            _circle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _circle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient linear : ellipse
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'linear' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : ellipse
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'radial' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : ellipse
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'fill', 'conic' ],
                        code: ( ) =>
                        {
                            _ellipse.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _ellipse.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient linear : rectangle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'linear' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : rectangle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'radial' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : rectangle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'fill', 'conic' ],
                        code: ( ) =>
                        {
                            _rectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _rectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient linear : roundedRectangle
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'fill', 'linear' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : roundedRectangle
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'fill', 'radial' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : roundedRectangle
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'fill', 'conic' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _roundedRectangle.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // gradient linear : text
                    {
                        title: 'Gradient Linear',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'linear' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Linear ( { x: 20, y: 0 }, { x: 220, y: 0 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillLinear:
                                    [
                                        new Stop ( new Rgb ( 200,  25,   0, 1 ), 1   ),
                                        new Stop ( new Rgb (   0, 150, 200, 1 ), 0.5 )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient radial : text
                    {
                        title: 'Gradient Radial',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'linear' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Radial ( { x: 180, y: 110 }, 0, { x: 180, y: 110 }, 50 );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillRadial:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1   ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0   )
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // gradient conic : text
                    {
                        title: 'Gradient Conic',
                        text: 'easeInSine',
                        children: [ 'text', 'fill', 'linear' ],
                        code: ( ) =>
                        {
                            _text.fill.gradient = new Conic ( 0, { x: 77, y: 155 } );

                            _text.fill.gradient.stops =
                            [
                                new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    )
                            ];

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    fillConic:
                                    [
                                        new Stop ( new Rgb ( 200,  50, 100, 1 ), 1    ),
                                        new Stop ( new Rgb ( 150,  75, 125, 1 ), 0.75 ),
                                        new Stop ( new Rgb ( 100, 100, 150, 1 ), 0.5  ),
                                        new Stop ( new Rgb ( 50,  125, 175, 1 ), 0.25 ),
                                        new Stop ( new Rgb ( 0,   150, 200, 1 ), 0    ),
                                    ],
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
                stroke:
                [
                    // stroke color : line
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'line', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : line
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'line', 'rgb' ],
                        code: ( ) =>
                        {
                            _line.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _line,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : circle
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'circle', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : circle
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'circle', 'rgb' ],
                        code: ( ) =>
                        {
                            _circle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _circle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : ellipse
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : ellipse
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'ellipse', 'rgb' ],
                        code: ( ) =>
                        {
                            _ellipse.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _ellipse,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : rectangle
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : rectangle
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'rectangle', 'rgb' ],
                        code: ( ) =>
                        {
                            _rectangle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _rectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : roundedRectangle
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : roundedRectangle
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'roundedrectangle', 'rgb' ],
                        code: ( ) =>
                        {
                            _roundedRectangle.stroke.color.alpha = 0;

                            let _transition =
                            {
                                object: _roundedRectangle,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },

                    // stroke color : text
                    {
                        title: 'Stroke Color',
                        text: 'easeInSine',
                        children: [ 'text', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.stroke.width = 2;

                            _text.stroke.color = new Rgb ( 0,  150,  200 );

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeColor: new Rgb ( 200,  25,  0 ),
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                    // stroke alpha : text
                    {
                        title: 'Stroke Alpha',
                        text: 'easeInSine',
                        children: [ 'text', 'rgb' ],
                        code: ( ) =>
                        {
                            _text.stroke.width = 2;

                            _text.stroke.color.alpha = 0;

                            _text.fill.color.alpha   = 0;   // [ Optional ]

                            let _transition =
                            {
                                object: _text,
                                timing: 'easeInSine',
                                period: 2000,
                                change:
                                {
                                    strokeAlpha: 0.5,
                                }
                            }

                            canvaslab.animate ( _transition );
                        }
                    },
                ],
            },
            template:
            {
                sacredcircles:
                [
                    // transitions hop
                    {
                        title:   'hop',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'fill', 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            ////    INPUT    ///////////////////////////////

                            let _center     = canvaslab.center;

                            let _iterations = 2;

                            let _timing     = 'easeOutBack';

                            let _period     = 500;

                            let _radius     = 25;

                            let _alpha      = 0.4;

                            let _strokes    = new Rgb ( 0, 0, 0, 1 );

                            let _fills      =
                            [
                                new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                                new Rgb (   0,  0,  255, _alpha ),      // Blue
                                new Rgb (   0, 255, 255, _alpha ),      // Cyan
                                new Rgb (   0, 255,   0, _alpha ),      // Green
                                new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                                new Rgb ( 255, 125,   0, _alpha ),      // Orange
                                new Rgb ( 255,   0,   0, _alpha ),      // Red
                                new Rgb (   0,   0,   0, _alpha ),      // Black
                            ]

                            let _degrees    = undefined;

                            ////    DEFINE    //////////////////////////////

                            let _group          = new Group;

                                _group.canvas   = 'canvas';

                                _group.template = new SacredCircles ( _center, _radius, _iterations, _strokes, _fills, _degrees, new myTransitions );

                            ////    ANIMATION    ///////////////////////////

                            let _transitions    = _group.template.transitions.hop ( _group.circles [ 0 ], _group.circles, _timing, _period, _center );


                            canvaslab.animate ( _transitions );
                        }
                    },
                    // transitions skip
                    {
                        title:   'skip',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'fill', 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            ////    INPUT    ///////////////////////////////

                            let _center     = canvaslab.center;

                            let _iterations = 2;

                            let _timing     = 'easeOutBack';

                            let _period     = 500;

                            let _radius     = 25;

                            let _alpha      = 0.4;

                            let _strokes    = new Rgb ( 0, 0, 0, 1 );

                            let _fills      =
                            [
                                new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                                new Rgb (   0,  0,  255, _alpha ),      // Blue
                                new Rgb (   0, 255, 255, _alpha ),      // Cyan
                                new Rgb (   0, 255,   0, _alpha ),      // Green
                                new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                                new Rgb ( 255, 125,   0, _alpha ),      // Orange
                                new Rgb ( 255,   0,   0, _alpha ),      // Red
                                new Rgb (   0,   0,   0, _alpha ),      // Black
                            ]

                            let _degrees    = undefined;

                            ////    DEFINE    //////////////////////////////

                            let _group          = new Group;

                                _group.canvas   = 'canvas';

                                _group.template = new SacredCircles ( _center, _radius, _iterations, _strokes, _fills, _degrees, new myTransitions );

                            ////    ANIMATION    ///////////////////////////

                            let _transitions    = _group.template.transitions.skip ( _group.circles [ 0 ], _group.circles, _timing, _period, _center );


                            canvaslab.animate ( _transitions );
                        }
                    },
                    // transitions bloom out
                    {
                        title:   'bloom out',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'fill', 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            ////    INPUT    ///////////////////////////////

                            let _center     = canvaslab.center;

                            let _iterations = 2;

                            let _timing     = 'easeInSine';

                            let _period     = 3500;

                            let _radius     = 25;

                            let _alpha      = 0.4;

                            let _strokes    = new Rgb ( 0, 0, 0, 1 );

                            let _fills      =
                            [
                                new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                                new Rgb (   0,  0,  255, _alpha ),      // Blue
                                new Rgb (   0, 255, 255, _alpha ),      // Cyan
                                new Rgb (   0, 255,   0, _alpha ),      // Green
                                new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                                new Rgb ( 255, 125,   0, _alpha ),      // Orange
                                new Rgb ( 255,   0,   0, _alpha ),      // Red
                                new Rgb (   0,   0,   0, _alpha ),      // Black
                            ]

                            let _degrees    = undefined;

                            ////    DEFINE    //////////////////////////////

                            let _group          = new Group;

                                _group.canvas   = 'canvas';

                                _group.template = new SacredCircles ( _center, _radius, _iterations, _strokes, _fills, _degrees, new myTransitions );

                            ////    ANIMATION    ///////////////////////////

                            let _transitions = _group.template.transitions.bloom ( _group.circles, _timing, _period );


                            canvaslab.animate ( _transitions );
                        }
                    },
                    // transitions bloom in
                    {
                        title:   'bloom in',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'fill', 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            ////    INPUT    ///////////////////////////////

                            let _center     = canvaslab.center;

                            let _iterations = 2;

                            let _timing     = 'easeInSine';

                            let _period     = 3500;

                            let _radius     = 25;

                            let _alpha      = 0.4;

                            let _strokes    = new Rgb ( 0, 0, 0, 1 );

                            let _fills      =
                            [
                                new Rgb ( 255,  0,  255, _alpha ),      // Magenta
                                new Rgb (   0,  0,  255, _alpha ),      // Blue
                                new Rgb (   0, 255, 255, _alpha ),      // Cyan
                                new Rgb (   0, 255,   0, _alpha ),      // Green
                                new Rgb ( 255, 255,   0, _alpha ),      // Yellow
                                new Rgb ( 255, 125,   0, _alpha ),      // Orange
                                new Rgb ( 255,   0,   0, _alpha ),      // Red
                                new Rgb (   0,   0,   0, _alpha ),      // Black
                            ]

                            let _degrees    = undefined;

                            ////    DEFINE    //////////////////////////////

                            let _group          = new Group;

                                _group.canvas   = 'canvas';

                                _group.template = new SacredCircles ( _center, _radius, _iterations, _strokes, _fills, _degrees, new myTransitions );

                            ////    ANIMATION    ///////////////////////////

                            let _transitions = _group.template.transitions.bloom ( _group.circles, _timing, _period, false );


                            canvaslab.animate ( _transitions );
                        }
                    },
                    // transitions shape implicit
                    {
                        title:   'shape implicit',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'fill', 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            ////    INPUT    ///////////////////////////////

                            let _center     = canvaslab.center;

                            let _iterations = 2;

                            let _seed       = null;

                            let _timing     = 'easeInSine';

                            let _period     = 3500;

                            let _radius     = 50;

                            let _strokes    = new Rgb ( 0, 0, 0, 0.3 );

                            let _fills      = new Rgb ( 0, 0, 0, 0 );

                            let _degrees    = undefined;

                            ////    DEFINE    //////////////////////////////

                            let _group          = new Group;

                                _group.canvas   = 'canvas';

                                _group.template = new SacredCircles ( canvaslab.center, _radius, _iterations, _strokes, _fills, _degrees, new myTransitions );

                            ////    ANIMATION    ///////////////////////////

                            let _transitions    = _group.template.transitions.shape ( _seed, _group.circles, _timing, _period, Circle );

                            canvaslab.animate ( _transitions );
                        }
                    },
                    // transitions shape explicit
                    {
                        title:   'shape explicit',
                        text:    'blah... blah... blah...',
                        children: [ 'circle', 'fill', 'stroke', 'rgb' ],
                        code: ( ) =>
                        {
                            ////    INPUT    ///////////////////////////////

                            let _center     = canvaslab.center;

                            let _iterations = 5;

                            let _seed       = [ 37, 39, 59, 9, 0, 17, 11, 15, 13, 49 ];

                            let _timing     = 'easeInSine';

                            let _period     = 3500;

                            let _radius     = 15;

                            let _strokes    = new Rgb ( 0, 0, 0, 0.3 );

                            let _fills      = new Rgb ( 0, 0, 0, 0 );

                            let _degrees    = undefined;

                            ////    DEFINE    //////////////////////////////

                            let _group          = new Group;

                                _group.canvas   = 'canvas';

                                _group.template = new SacredCircles ( canvaslab.center, _radius, _iterations, _strokes, _fills, _degrees, new myTransitions );

                            ////    ANIMATION    ///////////////////////////

                            let _transitions    = _group.template.transitions.shape ( _seed, _group.circles, _timing, _period, Circle );


                            canvaslab.animate ( _transitions );
                        }
                    },
                ]
            }
        }
    }

    /**
     * Object of lab scripts
     * @type {Object.<Object<Function>>}
     * @example { <title>: <Function> }
     */
    let _scripts =
    {
        // 6:2
        fountainOfRegeneratingObjects: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse = { x: 0, y: 0 }

                window.addEventListener ( 'mousemove', function ( )
                {
                    _mouse.x = event.clientX;

                    _mouse.y = event.clientY;
                } );

            ////    OBJECTS    /////////////////////////////

                let _circles  = new Array;

            ////    SET DEFAULTS    ////////////////////////

                ////    BALLS    ///////////////////////

                    let _numBalls = 80;

                    let _gravity  = 0.5;

                ////    EASING    //////////////////////

                    let _easing  = 0.05;

                    let _targetY = _canvas.height;

            ////    POPULATION    //////////////////////////

                for ( let _circle, _i = 0; _i < _numBalls; _i++ )
                {
                    let _radius = utils.getRandomNumber ( 10 );


                    _circle = new Circle;

                    _circle.canvas = 'canvas';

                    _circle.radius = _radius;


                    _circle.x = _canvas.width / 2;

                    _circle.y = _canvas.height;


                    _circle.velocity.x = Math.random ( ) * 2 - 1;

                    _circle.velocity.y = Math.random ( ) * -10 - 10;


                    _circles.push ( _circle );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _drawCircle ( circle )
                {
                    circle.velocity.y += _gravity;


                    circle.x += circle.velocity.x;

                    circle.y += circle.velocity.y;


                    if ( circle.x - circle.radius > canvas.width  || circle.x + circle.radius < 0 ||

                         circle.y - circle.radius > canvas.height || circle.y + circle.radius < 0 )
                    {
                        circle.x = _mouse.x;

                        circle.y = _mouse.y;


                        circle.velocity.x = Math.random ( ) * 2 - 1;

                        circle.velocity.y = Math.random ( ) * -10 - 10;
                    }


                    circle.draw ( );
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                     window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    DRAW    ////////////////////////

                        _circles.forEach ( _drawCircle );
                }


                _drawFrame ( );
        },
        // 6:8
        spaceshipSimulationWithFrictionApplied: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

                let _screen  = { left: 0, right: _canvas.width, top: 0, bottom: _canvas.height }

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                window.addEventListener ( 'keydown', function ( event )
                {
                    switch ( event.keyCode )
                    {
                        case 37:    _velocity.rotational = -3;                      break;  // left
                        case 39:    _velocity.rotational =  3;                      break;  // right
                        case 38:    [ _thrust, _ship.flame ] = [ 0.05, true ];      break;  // up
                    }
                } );

                window.addEventListener ( 'keyup', function ( )
                {
                    _velocity.rotational = 0;
                    _thrust             = 0;
                    _ship.flame         = false;
                } );

            ////    OBJECTS    /////////////////////////////

                let _ship = new Ship;


                    _ship.canvas = 'canvas';


                    _ship.x = canvas.width  / 2;

                    _ship.y = canvas.height / 2;

            ////    SET DEFAULTS    ////////////////////////

                let _velocity = new Point;


                    _velocity.x = 0;

                    _velocity.y = 0;


                    _velocity.rotational = 0

                // let _velocityRotational = 0;

                // let _velocityX          = 0;

                // let _velocityY          = 0;

                let _thrust             = 0;

                let _friction           = 0.97;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _ship.position.rotation += _velocity.rotational * Math.PI / 180;


                        let _angle = _ship.position.rotation;       // in radians


                        let _acceleration = new Point;


                            _acceleration.x = Math.cos ( _angle ) * _thrust;

                            _acceleration.y = Math.sin ( _angle ) * _thrust;


                        _velocity.x += _acceleration.x;

                        _velocity.y += _acceleration.y;


                        _velocity.x *= _friction;

                        _velocity.y *= _friction;


                        _ship.x += _velocity.x;

                        _ship.y += _velocity.y;

                    ////    SCREEN WRAPPING    /////////////

                        if ( _ship.x - _ship.width  / 2 > _screen.right )

                            _ship.x = _screen.left   - _ship.width  / 2;


                        if ( _ship.x + _ship.width  / 2 < _screen.left )

                            _ship.x = _screen.right  + _ship.width  / 2;


                        if ( _ship.y - _ship.height / 2 > _screen.bottom )

                            _ship.y = _screen.top    - _ship.height / 2;


                        if ( _ship.y < _screen.top - _ship.height / 2 )

                            _ship.y = _screen.bottom + _ship.height / 2;

                    ////    DRAW    ////////////////////////

                        _ship.draw ( );
                }


                _drawFrame ( );
        },
        // 7:6
        throwingAnObject: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

                let _screen  = { left: 0, right: _canvas.width, top: 0, bottom: _canvas.height }

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle  = new Circle;

                    _circle.x = canvas.width  / 2;

                    _circle.y = canvas.height / 2;

            ////    SET DEFAULTS    ////////////////////////

                let _velocity = new Point;

                    _velocity.x = Math.random() * 10 - 5;

                    _velocity.y = -10;


                let _bounce    = -0.7;

                let _gravity   = 0.2;


                let _isMouseDown = false;


                let _prior = new Point;

            ////    INPUT    ///////////////////////////////

                _canvas.addEventListener ( 'mousedown', function ( )
                {
                    if ( utils.containsPoint ( _circle.bounds, _mouse.x, _mouse.y ) )
                    {
                        _isMouseDown = true;


                        [ _prior.x, _prior.y ] = [ _circle.x, _circle.y ];


                        _canvas.addEventListener ( 'mouseup',   _onMouseUp   );

                        _canvas.addEventListener ( 'mousemove', _onMouseMove );
                    }
                } );

            ////    FUNCTIONS    ///////////////////////////

                function _onMouseUp ( )
                {
                    _isMouseDown = false;


                    _canvas.removeEventListener ( 'mouseup',   _onMouseUp   );

                    _canvas.removeEventListener ( 'mousemove', _onMouseMove );
                }

                function _onMouseMove ( event )
                {
                    [ _circle.x, _circle.y ] = [ _mouse.x, _mouse.y ];
                }

                function _trackVelocity ( )
                {
                    [ _velocity.x, _velocity.y ] = [ _circle.x - _prior.x, _circle.y - _prior.y ];

                    [ _prior.x,    _prior.y    ] = [ _circle.x,            _circle.y            ];
                }

                function _checkBoundaries ( )
                {
                    _velocity.y += _gravity;


                    _circle.x += _velocity.x;

                    _circle.y += _velocity.y;


                    // BOUNDARY DETECT AND BOUNCE
                    if ( _circle.x + _circle.radius > _screen.right )
                    {
                        _circle.x   = _screen.right - _circle.radius;

                        _velocity.x *= _bounce;
                    }

                    if ( _circle.x - _circle.radius < _screen.left )
                    {
                        _circle.x   = _screen.left + _circle.radius;

                        _velocity.x *= _bounce;
                    }

                    if ( _circle.y + _circle.radius > _screen.bottom )
                    {
                        _circle.y   = _screen.bottom - _circle.radius;

                        _velocity.y *= _bounce;
                    }

                    if ( _circle.y - _circle.radius < _screen.top )
                    {
                        _circle.y   = _screen.top + _circle.radius;

                        _velocity.y *= _bounce;
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        ( _isMouseDown ) ? _trackVelocity ( )

                                         : _checkBoundaries ( );


                    ////    DRAW    ////////////////////////

                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // 8:2
        draggingAndEasing: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.canvas = 'canvas';

            ////    SET DEFAULTS    ////////////////////////

                let _easing = 0.05;


                let _isMouseDown = false;


                let _target = new Point;

                    _target.x = _canvas.width  / 2;

                    _target.y = _canvas.height / 2;


                let _velocity = new Point;

            ////    INPUT    ///////////////////////////////

                _canvas.addEventListener ( 'mousedown', function ( )
                {
                    if ( utils.containsPoint ( _circle.bounds, _mouse.x, _mouse.y ) )
                    {
                        _isMouseDown = true;


                        _canvas.addEventListener ( 'mouseup',   _onMouseUp   );

                        _canvas.addEventListener ( 'mousemove', _onMouseMove );
                    }
                } );

            ////    FUNCTIONS    ///////////////////////////

                function _onMouseUp ( )
                {
                    _isMouseDown = false;

                    _canvas.removeEventListener ( 'mouseup',   _onMouseUp   );

                    _canvas.removeEventListener ( 'mousemove', _onMouseMove );
                }

                function _onMouseMove ( )
                {
                    [ _circle.x, _circle.y ] = [ _mouse.x, _mouse.y ];
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        if ( ! _isMouseDown )
                        {
                            _velocity.x = ( _target.x - _circle.x ) * _easing;

                            _velocity.y = ( _target.y - _circle.y ) * _easing;


                            _circle.x += _velocity.x;

                            _circle.y += _velocity.y;
                        }

                    ////    DRAW    ////////////////////////

                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // draggingAndEasingDemo: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse   = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:   _easing   += 0.0005;   break;
        //                 case KEYCODE.A:   _easing   -= 0.0005;   break;
        //                 case KEYCODE.W:   _isInward  = false;    break;
        //                 case KEYCODE.S:   _isInward  = true;     break;
        //                 case KEYCODE.Q:   _easing    = 0;        break;
        //             }
        //         } );

        //     ////    OBJECTS    /////////////////////////////

        //         let _circle = new Circle;


        //         let _group  = new Group;

        //             _group.template = new SacredCircles ( _center, 75, 10, new Rgb ( 0, 0, 0, 0.5 ), new Rgb ( 0, 0, 0, 0 ) );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _easing = 0.0005;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _move ( circle )
        //         {
        //             if ( _lastCircle.y > _center.y - 1 )

        //                 _isInward = false;


        //             if ( ! _isMouseDown )
        //             {
        //                 _velocity.x = ( _target.x - circle.x ) * _easing;

        //                 _velocity.y = ( _target.y - circle.y ) * _easing;


        //                 if ( _isInward )
        //                 {
        //                     circle.x += _velocity.x;

        //                     circle.y += _velocity.y;
        //                 }
        //                 else
        //                 {
        //                     circle.x -= _velocity.x;

        //                     circle.y -= _velocity.y;
        //                 }
        //             }
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    TRANSITIONS    /////////////////

        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo2: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //     ////    OBJECTS    /////////////////////////////

        //         let _circle = new Circle;


        //         let _group  = new Group;

        //             _group.template = new SacredCircles ( _center, 75, 10, new Rgb ( 0, 0, 0, 0.5 ), new Rgb ( 0, 0, 0, 0 ) );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _easing = 0.0005;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _move ( circle )
        //         {
        //             if ( _lastCircle.y > _center.y - 1 )

        //                 _isInward = false;

        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - circle.x ) * _easing;

        //                 _velocity.y = ( _target.y - circle.y ) * _easing;


        //                 if ( _isInward )
        //                 {
        //                     circle.x += _velocity.x;

        //                     circle.y += _velocity.y;
        //                 }
        //                 else
        //                 {
        //                     circle.x -= _velocity.x;

        //                     circle.y -= _velocity.y;
        //                 }

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( circle.x - _center.x, circle.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 circle.x = _center.x + _pointB.x;

        //                 circle.y = _center.y + _pointB.y;
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo3: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //     ////    OBJECTS    /////////////////////////////

        //         let _circle = new Circle;


        //         let _group  = new Group;

        //             _group.template = new SacredCircles ( _center, 75, 10, new Rgb ( 0, 0, 0, 0.5 ), new Rgb ( 0, 0, 0, 0 ) );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _easing = 0;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _move ( circle )
        //         {
        //             if ( _lastCircle.y > _center.y - 1 )

        //                 _isInward = false;

        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - circle.x ) * _easing;

        //                 _velocity.y = ( _target.y - circle.y ) * _easing;


        //                 if ( _isInward )
        //                 {
        //                     circle.x += _velocity.x;

        //                     circle.y += _velocity.y;
        //                 }
        //                 else
        //                 {
        //                     circle.x -= _velocity.x;

        //                     circle.y -= _velocity.y;
        //                 }

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( circle.x - _center.x, circle.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 circle.x = _center.x + _pointB.x;

        //                 circle.y = _center.y + _pointB.y;
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo4: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //     ////    OBJECTS    /////////////////////////////

        //         let _circle = new Circle;


        //         let _group  = new Group;

        //             _group.template = new SacredCircles ( _center, 75, 5, new Rgb ( 0, 0, 0, 0.5 ), new Rgb ( 0, 0, 0, 0 ) );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _easing = 0;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME


        //         let _lines = new Lines;

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _setLines ( collection )
        //         {
        //             for ( let _i = 0; _i < collection.length; _i++ )

        //                 for ( let _j = 0; _j < collection.length; _j++ )
        //                 {
        //                     if ( true )
        //                     {
        //                         if ( _i === _j ) continue;

        //                         if (  _i > _j  ) continue;
        //                     }


        //                     let _line = new Line;

        //                         _line.start  = collection [ _i ].point;

        //                         _line.end    = collection [ _j ].point;

        //                         _line.stroke.color = new Rgb ( 255, 255, 255, 0.15 );


        //                     _lines.push ( _line );
        //                 }
        //         }

        //         _setLines ( _group.circles );

        //         function _move ( circle )
        //         {
        //             if ( _lastCircle.y > _center.y - 1 )

        //                 _isInward = false;

        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - circle.x ) * _easing;

        //                 _velocity.y = ( _target.y - circle.y ) * _easing;


        //                 if ( _isInward )
        //                 {
        //                     circle.x += _velocity.x;

        //                     circle.y += _velocity.y;
        //                 }
        //                 else
        //                 {
        //                     circle.x -= _velocity.x;

        //                     circle.y -= _velocity.y;
        //                 }

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( circle.x - _center.x, circle.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 circle.x = _center.x + _pointB.x;

        //                 circle.y = _center.y + _pointB.y;
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );

        //                 _lines.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo5: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //     ////    OBJECTS    /////////////////////////////

        //         let _iterations = 5;

        //         let _radius     = 180;

        //         let _group      = new Group;

        //             _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 255, 255, 255, 0.5 ), new Rgb ( 255, 255, 255, 0 ) );

        //             _group.circles.forEach ( _setShadows );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _minDistance = _radius;


        //         let _easing = 0;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME


        //         let _lines = new Lines;

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _setShadows ( circle )
        //         {
        //             circle.options.shadow = true;

        //             circle.shadow.color = new Rgb ( 255, 255, 255 );

        //             circle.shadow.blur = 3;
        //         }

        //         function _drawLine ( objectA, objectB )
        //         {
        //             let _distance     = new Point;

        //             let _acceleration = new Point;


        //                 _distance.x = objectB.x - objectA.x;

        //                 _distance.y = objectB.y - objectA.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < _minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / _minDistance;


        //                 _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( objectB.x, objectB.y );


        //                 _context.stroke ( );


        //                 _acceleration.x = _distance.x * _easing;

        //                 _acceleration.y = _distance.y * _easing;


        //                 objectA.velocity.x += _acceleration.x / objectA.mass;

        //                 objectA.velocity.y += _acceleration.y / objectA.mass;


        //                 objectB.velocity.x -= _acceleration.x / objectB.mass;

        //                 objectB.velocity.y -= _acceleration.y / objectB.mass;
        //             }
        //         }

        //         function _move ( objectA, iter )
        //         {
        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - objectA.x ) * _easing;

        //                 _velocity.y = ( _target.y - objectA.y ) * _easing;


        //                 objectA.x += _velocity.x;

        //                 objectA.y += _velocity.y;

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( objectA.x - _center.x, objectA.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 objectA.x = _center.x + _pointB.x;

        //                 objectA.y = _center.y + _pointB.y;

        //             ////    DRAW LINES    //////////////

        //                 for ( let _objectB, _j = iter + 1; _j < _group.circles.length; _j++ )
        //                 {
        //                     ////    SKIP REDUNDANT LINES    ////

        //                     if ( iter === _j ) continue;

        //                     if (  iter > _j  ) continue;


        //                     _objectB = _group.circles [ _j ];

        //                     _drawLine ( objectA, _objectB );
        //                 }
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo6: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //     ////    OBJECTS    /////////////////////////////

        //         let _iterations = 5;

        //         let _radius     = 75;

        //         let _group      = new Group;

        //             _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 255, 255, 255, 0.5 ), new Rgb ( 255, 255, 255, 0 ) );

        //             _group.circles.forEach ( _setShadows );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _minDistance = _radius * 2;


        //         let _easing = 0;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME


        //         let _lines = new Lines;

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _setShadows ( circle )
        //         {
        //             circle.options.shadow = true;

        //             circle.shadow.color   = new Rgb ( 255, 255, 255 );

        //             circle.shadow.blur    = 3;
        //         }

        //         function _drawLine ( objectA, objectB )
        //         {
        //             let _distance     = new Point;

        //             let _acceleration = new Point;


        //                 _distance.x = objectB.x - objectA.x;

        //                 _distance.y = objectB.y - objectA.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < _minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / _minDistance;


        //                 _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( objectB.x, objectB.y );


        //                 _context.stroke ( );


        //                 if ( true )
        //                 {
        //                     _context.beginPath ( );


        //                     _context.moveTo ( objectA.x, objectA.y );

        //                     _context.lineTo ( _mouse.x, _mouse.y );


        //                     _context.stroke ( );


        //                     _acceleration.x = _distance.x * _easing;

        //                     _acceleration.y = _distance.y * _easing;
        //                 }


        //                 objectA.velocity.x += _acceleration.x / objectA.mass;

        //                 objectA.velocity.y += _acceleration.y / objectA.mass;


        //                 objectB.velocity.x -= _acceleration.x / objectB.mass;

        //                 objectB.velocity.y -= _acceleration.y / objectB.mass;
        //             }
        //         }

        //         function _getDistance ( objectA, input )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = input.x - objectA.x;

        //                 _distance.y = input.y - objectA.y;


        //             return Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );
        //         }

        //         function _move ( objectA, iter )
        //         {;
        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - objectA.x ) * _easing;

        //                 _velocity.y = ( _target.y - objectA.y ) * _easing;


        //                 objectA.x += _velocity.x;

        //                 objectA.y += _velocity.y;

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( objectA.x - _center.x, objectA.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 objectA.x = _center.x + _pointB.x;

        //                 objectA.y = _center.y + _pointB.y;

        //             ////    DRAW LINES    //////////////

        //                 for ( let _objectB, _j = iter + 1; _j < _group.circles.length; _j++ )
        //                 {
        //                     ////    SKIP REDUNDANT LINES    ////

        //                     if ( iter === _j ) continue;

        //                     if (  iter > _j  ) continue;


        //                     _objectB = _group.circles [ _j ];

        //                     _drawLine ( objectA, _objectB );
        //                 }
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo7: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //         document.body.style.cursor = 'none';

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //     ////    OBJECTS    /////////////////////////////

        //         let _iterations = 5;

        //         let _radius     = 75;

        //         let _group      = new Group;

        //             _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 255, 255, 255, 0.5 ), new Rgb ( 255, 255, 255, 0 ) );

        //             _group.circles.forEach ( _setShadows );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _minDistance = _radius * 2;


        //         let _easing = 0;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME


        //         let _lines = new Lines;

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _setShadows ( circle )
        //         {
        //             circle.options.shadow = true;

        //             circle.shadow.color   = new Rgb ( 255, 255, 255 );

        //             circle.shadow.blur    = 3;
        //         }

        //         function _drawLineToMouse ( objectA, mouse )
        //         {
        //             let _mouseDistance    = new Point;

        //             let _minMouseDistance = _radius * 6;


        //                 _mouseDistance.x = objectA.x - _mouse.x;

        //                 _mouseDistance.y = objectA.y - _mouse.y;


        //                 _mouseDistance.total = Math.sqrt ( _mouseDistance.x * _mouseDistance.x + _mouseDistance.y * _mouseDistance.y );


        //             if ( _mouseDistance.total < _minMouseDistance )
        //             {
        //                 let _alpha = 1 - _mouseDistance.total / _minMouseDistance;


        //                 _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( _mouse.x, _mouse.y );


        //                 _context.stroke ( );
        //             }
        //         }

        //         function _drawLine ( objectA, objectB )
        //         {
        //             let _distance     = new Point;

        //             let _acceleration = new Point;


        //                 _distance.x = objectB.x - objectA.x;

        //                 _distance.y = objectB.y - objectA.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < _minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / _minDistance;


        //                 _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( objectB.x, objectB.y );


        //                 _context.stroke ( );


        //                 _acceleration.x = _distance.x * _easing;

        //                 _acceleration.y = _distance.y * _easing;


        //                 objectA.velocity.x += _acceleration.x / objectA.mass;

        //                 objectA.velocity.y += _acceleration.y / objectA.mass;


        //                 objectB.velocity.x -= _acceleration.x / objectB.mass;

        //                 objectB.velocity.y -= _acceleration.y / objectB.mass;
        //             }
        //         }

        //         function _getDistance ( objectA, input )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = input.x - objectA.x;

        //                 _distance.y = input.y - objectA.y;


        //             return Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );
        //         }

        //         function _move ( objectA, iter )
        //         {
        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - objectA.x ) * _easing;

        //                 _velocity.y = ( _target.y - objectA.y ) * _easing;


        //                 objectA.x += _velocity.x;

        //                 objectA.y += _velocity.y;

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( objectA.x - _center.x, objectA.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 objectA.x = _center.x + _pointB.x;

        //                 objectA.y = _center.y + _pointB.y;

        //             ////    DRAW LINES    //////////////

        //                 for ( let _objectB, _j = iter + 1; _j < _group.circles.length; _j++ )
        //                 {
        //                     ////    SKIP REDUNDANT LINES    ////

        //                     if ( iter === _j ) continue;

        //                     if (  iter > _j  ) continue;


        //                     _objectB = _group.circles [ _j ];

        //                     _drawLine ( objectA, _objectB );

        //                     _drawLineToMouse ( objectA, _mouse );
        //                 }
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo8: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //         document.body.style.cursor = 'none';

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //     ////    OBJECTS    /////////////////////////////

        //         let _iterations = 5;

        //         let _radius     = 75;

        //         let _group      = new Group;

        //             _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 255, 255, 255, 0 ), new Rgb ( 255, 255, 255, 0 ) );

        //             _group.circles.forEach ( _setShadows );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _minDistance = _radius * 2;


        //         let _easing = 0;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME


        //         let _lines = new Lines;

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _setShadows ( circle )
        //         {
        //             circle.options.shadow = true;

        //             circle.shadow.color   = new Rgb ( 255, 255, 255 );

        //             circle.shadow.blur    = 3;
        //         }

        //         function _strokeObjectBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 objectA.stroke.color = new Rgb ( 255, 255, 255, _alpha / 8 );
        //                 // object.stroke.color.alpha = 1;


        //                 _context.stroke ( );
        //             }
        //         }

        //         function _fillObjectBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 objectA.fill.color = new Rgb ( 255, 255, 255, _alpha / 6 );


        //                 _context.fill ( );
        //             }
        //         }

        //         function _drawLineBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 let _color = new Rgb ( 255, 255, 255, _alpha / 8 );


        //                 _context.strokeStyle = _color.toCss ( );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( objectB.x, objectB.y );


        //                 _context.stroke ( );
        //             }
        //         }

        //         function _getDistance ( objectA, input )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = input.x - objectA.x;

        //                 _distance.y = input.y - objectA.y;


        //             return Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );
        //         }

        //         function _move ( objectA, iter )
        //         {
        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - objectA.x ) * _easing;

        //                 _velocity.y = ( _target.y - objectA.y ) * _easing;


        //                 objectA.x += _velocity.x;

        //                 objectA.y += _velocity.y;

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( objectA.x - _center.x, objectA.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 objectA.x = _center.x + _pointB.x;

        //                 objectA.y = _center.y + _pointB.y;

        //             ////    DRAW LINES    //////////////

        //                 for ( let _objectB, _j = iter + 1; _j < _group.circles.length; _j++ )
        //                 {
        //                     ////    SKIP REDUNDANT LINES    ////

        //                     if ( iter === _j ) continue;

        //                     if (  iter > _j  ) continue;


        //                     _objectB = _group.circles [ _j ];


        //                     // _drawLineBetween ( objectA, _objectB, _radius * 3 );

        //                     // _drawLineBetween ( objectA, _mouse, _radius * 6 );

        //                     _strokeObjectBetween ( objectA, _mouse, _radius * 3 );

        //                     // _fillObjectBetween ( objectA, _mouse,   _radius * 6 );
        //                 }
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo9: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //         document.body.style.cursor = 'none';

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse = utils.captureMouse ( _canvas );


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //         /**
        //          * This function returns a positive number of connections,
        //          * a negative number of disconnections, or zero for no change.
        //          */
        //         let _testForConnections = ( function( )
        //         {
        //             let _connectionCount = 0;                // Keep track of the connection count

        //             // Return a function that does the actual tracking
        //             return function ( )
        //             {
        //                 let _gamepads = navigator.getGamepads ( );

        //                 let _count    = 0;


        //                 for ( let _i = _gamepads.length - 1; _i >= 0; _i-- )
        //                 {
        //                     let _gamepad = _gamepads [ _i ];


        //                     if ( _gamepad && _gamepad.connected )               // Make sure they're not null and connected

        //                         _count++;
        //                 }


        //                 let _diff = _count - _connectionCount;                  // Return any changes

        //                 _connectionCount = _count;


        //                 return _diff;
        //             }
        //         } ( ) );


        //         function _isGamepad ( )
        //         {
        //             let _testConnections = _testForConnections ( );


        //             if ( _testConnections > 0 || _testConnections < 0 )

        //                 return true;


        //             return false;
        //         }

        //         function _gamepad ( )
        //         {
        //             let _gamepads = navigator.getGamepads ( );

        //             let _gamepad  = _gamepads [ 0 ];        // Blindly assuming this is connected

        //             let _pip      = document.querySelector ( '#pip' );

        //             let _stick    =
        //             {
        //                 left:  new Point,
        //                 right: new Point
        //             }


        //                 _stick.left.x  = _gamepad.axes [ 0 ];

        //                 _stick.left.y  = _gamepad.axes [ 1 ];


        //                 _stick.right.x = _gamepad.axes [ 2 ];

        //                 _stick.right.y = _gamepad.axes [ 3 ];


        //             if ( true )                   // DEADZONE
        //             {
        //                 [ _stick.left.x,  _stick.left.y  ] = gpLib.deadzone ( _stick.left.x,  _stick.left.y  );

        //                 [ _stick.right.x, _stick.right.y ] = gpLib.deadzone ( _stick.right.x, _stick.right.y );
        //             }


        //             let _distance = _radius;

        //             let _clamp = new Point;


        //             if ( true )                   // CLAMP
        //             {
        //                 [ _stick.left.x,  _stick.left.y  ] = gpLib.clamp ( _stick.left.x,  _stick.left.y, 'clamp'  );

        //                 [ _stick.right.x, _stick.right.y ] = gpLib.clamp ( _stick.right.x, _stick.right.y, 'clamp' );
        //             }


        //                 _pip.style.left = ( _stick.left.x + 1 ) / 2 * 100 + '%';

        //                 _pip.style.top  = ( _stick.left.y + 1 ) / 2 * 100 + '%';
        //         }

        //     ////    OBJECTS    /////////////////////////////

        //         let _iterations = 5;

        //         let _radius     = 75;

        //         let _group      = new Group;

        //             _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 255, 255, 255, 0 ), new Rgb ( 255, 255, 255, 0 ) );

        //             _group.circles.forEach ( _setShadows );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _minDistance = _radius * 2;


        //         let _easing = 0;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME


        //         let _lines = new Lines;

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _setShadows ( circle )
        //         {
        //             circle.options.shadow = true;

        //             circle.shadow.color   = new Rgb ( 255, 255, 255 );

        //             circle.shadow.blur    = 3;
        //         }

        //         function _strokeObjectBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 objectA.stroke.color = new Rgb ( 255, 255, 255, _alpha / 3 );
        //             }
        //         }

        //         function _fillObjectBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 objectA.fill.color = new Rgb ( 255, 255, 255, _alpha / 6 );
        //             }
        //         }

        //         function _drawLineBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( objectB.x, objectB.y );


        //                 _context.stroke ( );
        //             }
        //         }

        //         function _drawLineBetweenThings ( objectA, objectB, objectC, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectC.x;

        //                 _distance.y = objectA.y - objectC.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( objectB.x, objectB.y );


        //                 _context.stroke ( );
        //             }
        //         }

        //         function _getDistance ( objectA, input )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = input.x - objectA.x;

        //                 _distance.y = input.y - objectA.y;


        //             return Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );
        //         }

        //         function _move ( objectA, iter )
        //         {
        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - objectA.x ) * _easing;

        //                 _velocity.y = ( _target.y - objectA.y ) * _easing;


        //                 objectA.x += _velocity.x;

        //                 objectA.y += _velocity.y;

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( objectA.x - _center.x, objectA.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 objectA.x = _center.x + _pointB.x;

        //                 objectA.y = _center.y + _pointB.y;

        //             ////    DRAW LINES    //////////////

        //                 for ( let _objectB, _j = iter + 1; _j < _group.circles.length; _j++ )
        //                 {
        //                     ////    SKIP REDUNDANT LINES    ////

        //                     if ( iter === _j ) continue;

        //                     if (  iter > _j  ) continue;


        //                     _objectB = _group.circles [ _j ];


        //                     // _drawLineBetween ( objectA, _objectB, _radius * 3 );

        //                     // _drawLineBetweenThings ( objectA, _objectB, _mouse, _radius * 3 );

        //                     // _drawLineBetween ( _objectB, _mouse, _radius * 6 );

        //                     _strokeObjectBetween ( _objectB, _mouse, _radius * 6 );

        //                     _fillObjectBetween ( _objectB, _mouse, _radius * 6 );
        //                 }
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    INPUTS    //////////////////////

        //                 _gamepad ( );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        // draggingAndEasingDemo10: ( ) =>
        // {
        //     ////    CONTEXT    /////////////////////////////

        //         let _canvas  = document.getElementById ( 'canvas' );

        //         let _context = _canvas.getContext ( '2d' );

        //         let _center  = canvaslab.center;

        //         document.body.style.cursor = 'none';

        //     ////    LOOP DATA    ///////////////////////////

        //         let _timeCurrent = new Date ( );

        //     ////    INPUT    ///////////////////////////////

        //         let _mouse   = utils.captureMouse ( _canvas );

        //         let _gamepad = undefined;


        //         window.addEventListener ( 'keydown', function ( event )
        //         {
        //             switch ( event.keyCode )
        //             {
        //                 case KEYCODE.D:         _easing   += 0.0005;        break;
        //                 case KEYCODE.A:         _easing   -= 0.0005;        break;
        //                 case KEYCODE.W:         _isInward  = false;         break;
        //                 case KEYCODE.S:         _isInward  = true;          break;
        //                 case KEYCODE.Q:         _easing    = 0;             break;
        //                 case KEYCODE.RIGHT:     _angle    += 1;             break;
        //                 case KEYCODE.LEFT:      _angle    -= 1;             break;
        //             }
        //         } );

        //         /**
        //          * This function returns a positive number of connections,
        //          * a negative number of disconnections, or zero for no change.
        //          */
        //         // let _testForConnections = ( function( )
        //         // {
        //         //     let _connectionCount = 0;                // Keep track of the connection count

        //         //     // Return a function that does the actual tracking
        //         //     return function ( )
        //         //     {
        //         //         let _gamepads = navigator.getGamepads ( );

        //         //         let _count    = 0;


        //         //         for ( let _i = _gamepads.length - 1; _i >= 0; _i-- )
        //         //         {
        //         //             let _gamepad = _gamepads [ _i ];


        //         //             if ( _gamepad && _gamepad.connected )               // Make sure they're not null and connected

        //         //                 _count++;
        //         //         }


        //         //         let _diff = _count - _connectionCount;                  // Return any changes

        //         //         _connectionCount = _count;


        //         //         return _diff;
        //         //     }
        //         // } ( ) );


        //         function _isGamepad ( )
        //         {
        //             let _testConnections = _testForConnections ( );


        //             if ( _testConnections > 0 || _testConnections < 0 )

        //                 return true;


        //             return false;
        //         }

        //         // function _gamepad ( )
        //         // {
        //         //     let _gamepads = navigator.getGamepads ( );

        //         //     let _gamepad  = _gamepads [ 0 ];        // Blindly assuming this is connected

        //         //     let _pip      = document.querySelector ( '#pip' );

        //         //     let _stick    =
        //         //     {
        //         //         left:  new Point,
        //         //         right: new Point
        //         //     }


        //         //         _stick.left.x  = _gamepad.axes [ 0 ];

        //         //         _stick.left.y  = _gamepad.axes [ 1 ];


        //         //         _stick.right.x = _gamepad.axes [ 2 ];

        //         //         _stick.right.y = _gamepad.axes [ 3 ];


        //         //     if ( true )                   // DEADZONE
        //         //     {
        //         //         [ _stick.left.x,  _stick.left.y  ] = gpLib.deadzone ( _stick.left.x,  _stick.left.y  );

        //         //         [ _stick.right.x, _stick.right.y ] = gpLib.deadzone ( _stick.right.x, _stick.right.y );
        //         //     }


        //         //     let _distance = _radius;

        //         //     let _clamp = new Point;


        //         //     if ( true )                   // CLAMP
        //         //     {
        //         //         [ _stick.left.x,  _stick.left.y  ] = gpLib.clamp ( _stick.left.x,  _stick.left.y, 'clamp'  );

        //         //         [ _stick.right.x, _stick.right.y ] = gpLib.clamp ( _stick.right.x, _stick.right.y, 'clamp' );
        //         //     }


        //         //         _pip.style.left = ( _stick.left.x + 1 ) / 2 * 100 + '%';

        //         //         _pip.style.top  = ( _stick.left.y + 1 ) / 2 * 100 + '%';
        //         // }

        //     ////    OBJECTS    /////////////////////////////

        //         let _iterations = 5;

        //         let _radius     = 75;

        //         let _group      = new Group;

        //             _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 255, 255, 255, 0 ), new Rgb ( 255, 255, 255, 0 ) );

        //             _group.circles.forEach ( _setShadows );

        //     ////    SET DEFAULTS    ////////////////////////

        //         let _minDistance = _radius * 2;


        //         let _easing = 0;

        //         let _angle  = 0;


        //         let _isMouseDown = false;

        //         let _isInward    = true;


        //         let _target      = _center;

        //         let _velocity    = new Point;


        //         let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


        //         let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

        //         let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME


        //         let _lines = new Lines;

        //     ////    FUNCTIONS    ///////////////////////////

        //         function _setShadows ( circle )
        //         {
        //             circle.options.shadow = true;

        //             circle.shadow.color   = new Rgb ( 255, 255, 255 );

        //             circle.shadow.blur    = 3;
        //         }

        //         function _strokeObjectBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 objectA.stroke.color = new Rgb ( 255, 255, 255, _alpha / 3 );
        //             }
        //         }

        //         function _fillObjectBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 objectA.fill.color = new Rgb ( 255, 255, 255, _alpha / 6 );
        //             }
        //         }

        //         function _drawLineBetween ( objectA, objectB, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectB.x;

        //                 _distance.y = objectA.y - objectB.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( objectB.x, objectB.y );


        //                 _context.stroke ( );
        //             }
        //         }

        //         function _drawLineBetweenThings ( objectA, objectB, objectC, minDistance )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = objectA.x - objectC.x;

        //                 _distance.y = objectA.y - objectC.y;


        //                 _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


        //             if ( _distance.total < minDistance )
        //             {
        //                 let _alpha = 1 - _distance.total / minDistance;


        //                 _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

        //                 _context.beginPath ( );


        //                 _context.moveTo ( objectA.x, objectA.y );

        //                 _context.lineTo ( objectB.x, objectB.y );


        //                 _context.stroke ( );
        //             }
        //         }

        //         function _getDistance ( objectA, input )
        //         {
        //             let _distance = new Point;


        //                 _distance.x = input.x - objectA.x;

        //                 _distance.y = input.y - objectA.y;


        //             return Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );
        //         }

        //         let _pip = document.querySelector ( '#pip' );

        //         function _movePip ( )
        //         {
        //             _pip.style.left = ( _gamepad.stick.left.x + 1 ) / 2 * 100 + '%';

        //             _pip.style.top  = ( _gamepad.stick.left.y + 1 ) / 2 * 100 + '%';
        //         }

        //         function _move ( objectA, iter )
        //         {
        //             ////    INWARD & OUTWORD    ////////

        //                 _velocity.x = ( _target.x - objectA.x ) * _easing;

        //                 _velocity.y = ( _target.y - objectA.y ) * _easing;


        //                 objectA.x += _velocity.x;

        //                 objectA.y += _velocity.y;

        //             ////    ROTATION    ////////////////

        //                 let _pointA = new Point ( objectA.x - _center.x, objectA.y - _center.y );

        //                 let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


        //                 objectA.x = _center.x + _pointB.x;

        //                 objectA.y = _center.y + _pointB.y;

        //             ////    DRAW LINES    //////////////

        //                 for ( let _objectB, _j = iter + 1; _j < _group.circles.length; _j++ )
        //                 {
        //                     ////    SKIP REDUNDANT LINES    ////

        //                     if ( iter === _j ) continue;

        //                     if (  iter > _j  ) continue;


        //                     _objectB = _group.circles [ _j ];


        //                     _movePip ( );

        //                     // _drawLineBetween ( objectA, _objectB, _radius * 3 );

        //                     // _drawLineBetweenThings ( objectA, _objectB, _mouse, _radius * 3 );

        //                     // _drawLineBetween ( _objectB, _mouse, _radius * 6 );

        //                     let _pointer = new Point;

        //                         _pointer.x = _pip.offsetLeft;

        //                         _pointer.y = _pip.offsetTop;

        //                     _strokeObjectBetween ( _objectB, _mouse, _radius * 6 );

        //                     _fillObjectBetween ( _objectB, _pointer, _radius * 6 );
        //                 }
        //         }

        //     ////    DRAW    ////////////////////////////////

        //         function _drawFrame ( )
        //         {
        //             window.requestAnimationFrame ( _drawFrame, _canvas );

        //             ////    LOOP DATA    ///////////////////

        //                 _timeCurrent = LAB.getFps ( _timeCurrent );

        //             ////    CLEAR SCREEN    ////////////////

        //                 _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

        //             ////    INPUTS    //////////////////////

        //                 _gamepad = utils.captureGamepad ( );

        //             ////    TRANSITIONS    /////////////////

        //                 let _angleFinal = _angle * 0.0005;


        //                 _cos = Math.cos ( _angleFinal );

        //                 _sin = Math.sin ( _angleFinal );


        //                 _group.circles.forEach ( _move );

        //             ////    DRAW    ////////////////////////

        //                 _group.circles.draw ( );
        //         }


        //         _drawFrame ( );
        // },
        draggingAndEasingDemo11: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas   = document.getElementById ( 'canvas' );

                let _context  = _canvas.getContext ( '2d' );

                let _center   = canvaslab.center;


                let _pipLeft  = document.querySelector ( '#pip-left' );

                let _pipRight = document.querySelector ( '#pip-right' );


                let _easingOutput = document.querySelector ( '#debug > div.easing > span' );

                let _angleOutput  = document.querySelector ( '#debug > div.angle > span' );


                let _stick    =
                {
                    left:  new Point,
                    right: new Point
                }

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

                let _gamepad = undefined;


                window.addEventListener ( 'keydown', function ( event )
                {
                    switch ( event.keyCode )
                    {
                        case KEYCODE.D:         _easing   += 0.0005;        break;
                        case KEYCODE.A:         _easing   -= 0.0005;        break;
                        case KEYCODE.W:         _isInward  = false;         break;
                        case KEYCODE.S:         _isInward  = true;          break;
                        case KEYCODE.Q:         _easing    = 0;             break;
                        case KEYCODE.RIGHT:     _angle    += 1;             break;
                        case KEYCODE.LEFT:      _angle    -= 1;             break;
                    }
                } );

                function _isGamepad ( )
                {
                    let _testConnections = _testForConnections ( );


                    if ( _testConnections > 0 || _testConnections < 0 )

                        return true;


                    return false;
                }

            ////    OBJECTS    /////////////////////////////

                let _iterations = 5;

                let _radius     = 75;

                let _group      = new Group;

                    _group.template = new SacredCircles ( _center, _radius, _iterations, new Rgb ( 255, 255, 255, 0 ), new Rgb ( 255, 255, 255, 0 ) );

                    _group.circles.forEach ( _setShadows );

            ////    SET DEFAULTS    ////////////////////////

                let _minDistance = _radius * 2;


                let _easing = 0;

                let _angle  = 0;


                let _isMouseDown = false;

                let _isInward    = true;


                let _target      = _center;

                let _velocity    = new Point;


                let _lastCircle  = _group.circles [ _group.circles.length - 1 ];


                let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

                let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME


                let _lines = new Lines;

            ////    FUNCTIONS    ///////////////////////////

                function _setShadows ( circle )
                {
                    circle.options.shadow = true;

                    circle.shadow.color   = new Rgb ( 255, 255, 255 );

                    circle.shadow.blur    = 3;
                }

                function _strokeObjectBetween ( objectA, objectB, minDistance )
                {
                    let _distance = new Point;


                        _distance.x = objectA.x - objectB.x;

                        _distance.y = objectA.y - objectB.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    if ( _distance.total < minDistance )
                    {
                        let _alpha = 1 - _distance.total / minDistance;


                        objectA.stroke.color = new Rgb ( 255, 255, 255, _alpha / 3 );
                    }
                }

                function _fillObjectBetween ( objectA, objectB, minDistance )
                {
                    let _distance = new Point;


                        _distance.x = objectA.x - objectB.x;

                        _distance.y = objectA.y - objectB.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    if ( _distance.total < minDistance )
                    {
                        let _alpha = 1 - _distance.total / minDistance;


                        objectA.fill.color = new Rgb ( 255, 255, 255, _alpha / 6 );
                    }
                }

                function _drawLineBetween ( objectA, objectB, minDistance )
                {
                    let _distance = new Point;


                        _distance.x = objectA.x - objectB.x;

                        _distance.y = objectA.y - objectB.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    if ( _distance.total < minDistance )
                    {
                        let _alpha = 1 - _distance.total / minDistance;


                        _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

                        _context.beginPath ( );


                        _context.moveTo ( objectA.x, objectA.y );

                        _context.lineTo ( objectB.x, objectB.y );


                        _context.stroke ( );
                    }
                }

                function _drawLineBetweenThings ( objectA, objectB, objectC, minDistance )
                {
                    let _distance = new Point;


                        _distance.x = objectA.x - objectC.x;

                        _distance.y = objectA.y - objectC.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    if ( _distance.total < minDistance )
                    {
                        let _alpha = 1 - _distance.total / minDistance;


                        _context.strokeStyle = utils.colorToRGB ( "#FFFFFF", _alpha );

                        _context.beginPath ( );


                        _context.moveTo ( objectA.x, objectA.y );

                        _context.lineTo ( objectB.x, objectB.y );


                        _context.stroke ( );
                    }
                }

                function _getDistance ( objectA, input )
                {
                    let _distance = new Point;


                        _distance.x = input.x - objectA.x;

                        _distance.y = input.y - objectA.y;


                    return Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );
                }

                function _movePips ( )
                {
                    _pipLeft.style.left  = ( _gamepad.stick.left.x + 1 ) / 2 * 100 + '%';

                    _pipLeft.style.top   = ( _gamepad.stick.left.y + 1 ) / 2 * 100 + '%';


                    _pipRight.style.left = ( _gamepad.stick.right.x + 1 ) / 2 * 100 + '%';

                    _pipRight.style.top  = ( _gamepad.stick.right.y + 1 ) / 2 * 100 + '%';
                }

                function _move ( objectA, iter )
                {
                    ////    INWARD & OUTWORD    ////////

                        _velocity.x = ( _target.x - objectA.x ) * _easing;

                        _velocity.y = ( _target.y - objectA.y ) * _easing;


                        objectA.x += _velocity.x;

                        objectA.y += _velocity.y;

                    ////    ROTATION    ////////////////

                        let _pointA = new Point ( objectA.x - _center.x, objectA.y - _center.y );

                        let _pointB = new Point ( _cos * _pointA.x - _sin * _pointA.y, _cos * _pointA.y + _sin * _pointA.x );


                        objectA.x = _center.x + _pointB.x;

                        objectA.y = _center.y + _pointB.y;

                    ////    DRAW LINES    //////////////

                        for ( let _objectB, _j = iter + 1; _j < _group.circles.length; _j++ )
                        {
                            ////    SKIP REDUNDANT LINES    ////

                            if ( iter === _j ) continue;

                            if (  iter > _j  ) continue;


                            _objectB = _group.circles [ _j ];


                            _movePips ( );


                            [ _stick.left.x,  _stick.left.y  ] = [ _pipLeft.offsetLeft,  _pipLeft.offsetTop  ];

                            [ _stick.right.x, _stick.right.y ] = [ _pipRight.offsetLeft, _pipRight.offsetTop ];


                            // _drawLineBetween ( objectA, _objectB, _radius * 3 );

                            _strokeObjectBetween ( _objectB, _mouse, _radius * 6 );

                            // _drawLineBetweenThings ( objectA, _objectB, _mouse, _radius * 3 );

                            _fillObjectBetween ( _objectB, _stick.left, _radius * 6 );

                            _drawLineBetween ( _objectB, _stick.right, _radius * 6 );

                            // _drawLineBetween ( _objectB, _mouse, _radius * 6 );
                        }
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    INPUTS    //////////////////////

                        _gamepad = utils.captureGamepad ( );

                    ////    OUTPUTS    /////////////////////

                        _easingOutput.innerHTML = _easing;

                        _angleOutput.innerHTML  = _angle;

                    ////    TRANSITIONS    /////////////////

                        let _angleFinal = _angle * 0.0005;


                        _cos = Math.cos ( _angleFinal );

                        _sin = Math.sin ( _angleFinal );


                        _group.circles.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _group.circles.draw ( );
                }


                _drawFrame ( );
        },
        // 8:3
        simpleEasingWithEnd: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

                let _animRequest = undefined;

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.canvas = 'canvas';

                    _circle.fill.color = new Rgb ( 255, 255, 255 );

                    _circle.x = _canvas.width  / 2;

                    _circle.y = _canvas.height / 2;

                ////    OPTIONS    /////////////////////

                    _circle.options.axis        = true;

                    _circle.options.coordinates = true;

                    _circle.options.shadow      = true;

                    _circle.options.border      = true;

            ////    SET DEFAULTS    ////////////////////////

                let _easing  = 0.05;

                let _targetY = ( _canvas.height / 2 ) - 60;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    _animRequest = window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        let _distance = _targetY - _circle.y;


                        if ( Math.abs ( _distance ) < 1 )
                        {
                            _circle.y = _targetY;
                            /* ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec.
                            * See utils.js for the update to check for cross-browser compatibility.
                            */

                            window.cancelAnimationFrame ( _animRequest );

                            // log.value = "Animation done!";
                        }
                        else
                        {
                            let _velocityY = _distance.y * _easing;


                            _circle.y += _velocityY;
                        }

                    ////    DRAW    ////////////////////////

                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // 8:4
        easeToAMovingTarget: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.canvas = 'canvas';

            ////    SET DEFAULTS    ////////////////////////

                let _easing = 0.05;

                let _velocity = new Point;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ()
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _velocity.x = ( _mouse.x - _circle.x ) * _easing;

                        _velocity.y = ( _mouse.y - _circle.y ) * _easing;


                        _circle.x += _velocity.x;

                        _circle.y += _velocity.y;

                    ////    DRAW    ////////////////////////

                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // 8:6
        springingToAMovingTarget: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle   = new Circle;

                    _circle.canvas = 'canvas';

            ////    SET DEFAULTS    ////////////////////////

                let _spring   = 0.03;

                let _friction = 0.95;


                let _velocity     = new Point;

                let _distance     = new Point;

                let _acceleration = new Point;

            ////    DRAW    ////////////////////////////////

            function _drawFrame ( )
            {
                window.requestAnimationFrame ( _drawFrame, _canvas );

                ////    LOOP DATA    ///////////////////

                    _timeCurrent = LAB.getFps ( _timeCurrent );

                ////    CLEAR SCREEN    ////////////////

                    _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                ////    TRANSITIONS    /////////////////

                    _distance.x = _mouse.x - _circle.x;

                    _distance.y = _mouse.y - _circle.y;


                    _acceleration.x = _distance.x * _spring;

                    _acceleration.y = _distance.y * _spring;


                    _velocity.x += _acceleration.x;

                    _velocity.y += _acceleration.y;


                    _velocity.x *= _friction;

                    _velocity.y *= _friction;


                    _circle.x += _velocity.x;

                    _circle.y += _velocity.y;

                ////    DRAW    ////////////////////////

                    _circle.draw ( );
            }


            _drawFrame ( );
        },
        // 8:9
        addGravityAndDrawSpring: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle  = new Circle;

                    _circle.canvas = 'canvas';

            ////    SET DEFAULTS    ////////////////////////

                let _spring   = 0.03;

                let _friction = 0.9;

                let _gravity  = 2;


                let _velocity     = new Point;

                let _distance     = new Point;

                let _acceleration = new Point;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _distance.x = _mouse.x - _circle.x;

                        _distance.y = _mouse.y - _circle.y;


                        _acceleration.x = _distance.x * _spring;

                        _acceleration.y = _distance.y * _spring;


                        _velocity.x += _acceleration.x;

                        _velocity.y += _acceleration.y;


                        _velocity.y += _gravity;

                        _velocity.x *= _friction;


                        _velocity.y *= _friction;


                        _circle.x += _velocity.x;

                        _circle.y += _velocity.y;

                    ////    DRAW    ////////////////////////

                        _context.beginPath ( );


                        _context.moveTo ( _circle.x, _circle.y );

                        _context.lineTo ( _mouse.x,  _mouse.y  );


                        _context.stroke ( );


                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // 8:10
        chainingMultipleSprings: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circle0 = new Circle;

                let _circle1 = new Circle;

                let _circle2 = new Circle;


                    _circle0.canvas = 'canvas';

                    _circle1.canvas = 'canvas';

                    _circle2.canvas = 'canvas';

            ////    SET DEFAULTS    ////////////////////////

                let _mouse    = utils.captureMouse ( _canvas );

                let _spring   = 0.03;

                let _friction = 0.9;

                let _gravity  = 2;

            ////    FUNCTIONS    ///////////////////////////

                function _move ( circle, targetX, targetY )
                {
                    circle.velocity.x += ( targetX - circle.x ) * _spring;

                    circle.velocity.y += ( targetY - circle.y ) * _spring;


                    circle.velocity.y += _gravity;

                    circle.velocity.x *= _friction;

                    circle.velocity.y *= _friction;


                    circle.x  += circle.velocity.x;

                    circle.y  += circle.velocity.y;
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _move ( _circle0, _mouse.x, _mouse.y );

                        _move ( _circle1, _circle0.x, _circle0.y );

                        _move ( _circle2, _circle1.x, _circle1.y );

                    ////    DRAW    ////////////////////////

                        ////    SPRING    //////////////

                            _context.beginPath ( );


                            _context.moveTo ( _mouse.x, _mouse.y );

                            _context.lineTo ( _circle0.x, _circle0.y );

                            _context.lineTo ( _circle1.x, _circle1.y );

                            _context.lineTo ( _circle2.x, _circle2.y );


                            _context.stroke ( );

                        ////    BALLS    ///////////////

                            _circle0.draw ( );

                            _circle1.draw ( );

                            _circle2.draw ( );
                }


                _drawFrame ( );
        },
        // 8:12
        springingToMultipleTargets: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle  = new Circle;

                let _handles = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount   = 3;


                let _spring   = 0.03;

                let _friction = 0.9;


                let _movingHandle = undefined;

            ////    POPULATION    //////////////////////////

                for ( let _handle, _i = 0; _i < _amount; _i++ )
                {
                    _handle = new Circle;


                    _handle.x = Math.random ( ) * _canvas.width;

                    _handle.y = Math.random ( ) * _canvas.height;


                    _handles.push ( _handle );
                }

            ////    INPUT    ///////////////////////////////

                _canvas.addEventListener ( 'mousedown', function ( )
                {
                    _handles.forEach ( function ( handle )
                    {
                        if ( utils.containsPoint ( handle.bounds, _mouse.x, _mouse.y ) )

                            _movingHandle = handle;
                    } );
                } );

                _canvas.addEventListener ( 'mouseup', function ( )
                {
                    if ( _movingHandle )

                        _movingHandle = null;
                } );

                _canvas.addEventListener ( 'mousemove', function ( )
                {
                    if ( _movingHandle )

                        [ _movingHandle.x, _movingHandle.y ] = [ _mouse.x, _mouse.y ];
                } );

            ////    FUNCTIONS    ///////////////////////////

                function _applyHandle ( handle )
                {
                    let _distance = new Point;


                        _distance.x = handle.x - _circle.x;

                        _distance.y = handle.y - _circle.y;


                    _circle.velocity.x += _distance.x * _spring;

                    _circle.velocity.y += _distance.y * _spring;
                }

                function _drawHandle ( handle )
                {
                    _context.moveTo ( _circle.x, _circle.y );

                    _context.lineTo ( handle.x, handle.y );

                    _context.stroke ( );


                    handle.draw ( );
                }

            ////    DRAW    //////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _handles.forEach ( _applyHandle );


                        _circle.velocity.x *= _friction;

                        _circle.velocity.y *= _friction;


                        _circle.x += _circle.velocity.x;

                        _circle.y += _circle.velocity.y;


                        _context.beginPath ( );

                    ////    DRAW    ////////////////////////

                        _handles.forEach ( _drawHandle );

                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // 8:13
        offsetTheSpringTarget: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle  = new Circle;

                    _circle.canvas = 'canvas';

            ////    SET DEFAULTS    ////////////////////////

                let _spring       = 0.03;

                let _friction     = 0.9;

                let _springLength = 100;


                let _velocity = new Point;

                let _distance = new Point;

                let _target   = new Point;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _distance.x = _circle.x - _mouse.x;

                        _distance.y = _circle.y - _mouse.y;


                        let _angle = Math.atan2 ( _distance.y, _distance.x );


                        _target.x = _mouse.x + Math.cos ( _angle ) * _springLength;

                        _target.y = _mouse.y + Math.sin ( _angle ) * _springLength;


                        _velocity.x += ( _target.x - _circle.x ) * _spring;

                        _velocity.y += ( _target.y - _circle.y ) * _spring;


                        _velocity.x *= _friction;

                        _velocity.y *= _friction;


                        _circle.x += _velocity.x;

                        _circle.y += _velocity.y;

                    ////    DRAW    ////////////////////////

                        _context.beginPath ( );


                        _context.moveTo ( _circle.x, _circle.y );

                        _context.lineTo ( _mouse.x, _mouse.y );


                        _context.stroke ( );


                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // 8:14
        twoObjectsConnectedByASpring: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle0 = new Circle;

                    _circle0.canvas = 'canvas';

                    _circle0.x = Math.random ( ) * _canvas.width;

                    _circle0.y = Math.random ( ) * _canvas.height;

                let _circle1 = new Circle;

                    _circle1.canvas = 'canvas';

                    _circle1.x = Math.random ( ) * _canvas.width;

                    _circle1.y = Math.random ( ) * _canvas.height;

            ////    SET DEFAULTS    ////////////////////////

                let _circle0_dragging = false;

                let _circle1_dragging = false;


                let _spring   = 0.03;

                let _friction = 0.9;


                let _springLength = 100;


                let _velocity = new Point;

                let _distance = new Point;

                let _target   = new Point;

            ////    INPUT    ///////////////////////////////

                _canvas.addEventListener ( 'mousedown', function ( )
                {
                    if ( utils.containsPoint ( _circle0.bounds, _mouse.x, _mouse.y ) )

                        _circle0_dragging = true;


                    if ( utils.containsPoint ( _circle1.bounds, _mouse.x, _mouse.y ) )

                        _circle1_dragging = true;
                } );

                _canvas.addEventListener ( 'mouseup', function ( )
                {
                    if ( _circle0_dragging || _circle1_dragging )

                        _circle0_dragging = _circle1_dragging = false;
                } );

                _canvas.addEventListener ( 'mousemove', function ( )
                {
                    if ( _circle0_dragging )

                        [ _circle0.x, _circle0.y ] = [ _mouse.x, _mouse.y ];


                    if ( _circle1_dragging )

                        [ _circle1.x, _circle1.y ] = [ _mouse.x, _mouse.y ];
                } );

            ////    FUNCTIONS    ///////////////////////////

                function _springTo ( circleA, circleB )
                {
                    _distance.x = circleB.x - circleA.x;

                    _distance.y = circleB.y - circleA.y;


                    let _angle = Math.atan2 ( _distance.y, _distance.x );


                    _target.x = circleB.x - Math.cos ( _angle ) * _springLength;

                    _target.y = circleB.y - Math.sin ( _angle ) * _springLength;


                    circleA.velocity.x += ( _target.x - circleA.x ) * _spring;

                    circleA.velocity.y += ( _target.y - circleA.y ) * _spring;


                    circleA.velocity.x *= _friction;

                    circleA.velocity.y *= _friction;


                    circleA.x += circleA.velocity.x;

                    circleA.y += circleA.velocity.y;
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        if ( ! _circle0_dragging )

                            _springTo ( _circle0, _circle1 );


                        if ( ! _circle1_dragging )

                            _springTo ( _circle1, _circle0 );

                    ////    DRAW    ////////////////////////

                        _context.beginPath ( );

                        _context.moveTo ( _circle0.x, _circle0.y );
                        _context.lineTo ( _circle1.x, _circle1.y );

                        _context.stroke ( );


                        _circle0.draw ( );

                        _circle1.draw ( );
                }


                _drawFrame ( );
        },
        // 8:15
        threeObjectsConnectedByASpring: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle0 = new Circle;

                    _circle0.x = Math.random ( ) * _canvas.width;

                    _circle0.y = Math.random ( ) * _canvas.height;

                let _circle1 = new Circle;

                    _circle1.x = Math.random ( ) * _canvas.width;

                    _circle1.y = Math.random ( ) * _canvas.height;

                let _circle2 = new Circle;

                    _circle2.x = Math.random ( ) * _canvas.width;

                    _circle2.y = Math.random ( ) * _canvas.height;

            ////    SET DEFAULTS    ////////////////////////

                let _circle0_dragging = false;

                let _circle1_dragging = false;

                let _circle2_dragging = false;


                let _spring       = 0.03;

                let _friction     = 0.9;

                let _springLength = 100;


                let _velocity = new Point;

                let _distance = new Point;

                let _target   = new Point;

            ////    INPUT    ///////////////////////////////

                _canvas.addEventListener ( 'mousedown', function ( )
                {
                    if ( utils.containsPoint ( _circle0.bounds, _mouse.x, _mouse.y ) )
                    {
                        _circle0_dragging = true;
                    }

                    if ( utils.containsPoint ( _circle1.bounds, _mouse.x, _mouse.y ) )
                    {
                        _circle1_dragging = true;
                    }

                    if ( utils.containsPoint ( _circle2.bounds, _mouse.x, _mouse.y ) )
                    {
                        _circle2_dragging = true;
                    }
                } );

                _canvas.addEventListener ( 'mouseup', function ( )
                {
                    if ( _circle0_dragging || _circle1_dragging || _circle2_dragging )
                    {
                        _circle0_dragging = false;
                        _circle1_dragging = false;
                        _circle2_dragging = false;
                    }
                } );

                _canvas.addEventListener ( 'mousemove', function ( )
                {
                    if ( _circle0_dragging )
                    {
                        _circle0.x = _mouse.x;
                        _circle0.y = _mouse.y;
                    }

                    if ( _circle1_dragging )
                    {
                        _circle1.x = _mouse.x;
                        _circle1.y = _mouse.y;
                    }

                    if ( _circle2_dragging )
                    {
                        _circle2.x = _mouse.x;
                        _circle2.y = _mouse.y;
                    }
                } );

            ////    FUNCTIONS    ///////////////////////////

                function _springTo ( circleA, circleB )
                {
                    _distance.x = circleB.x - circleA.x;

                    _distance.y = circleB.y - circleA.y;


                    let _angle = Math.atan2 ( _distance.y, _distance.x );


                    _target.x = circleB.x - Math.cos ( _angle ) * _springLength;

                    _target.y = circleB.y - Math.sin ( _angle ) * _springLength;


                    circleA.velocity.x += ( _target.x - circleA.x ) * _spring;

                    circleA.velocity.y += ( _target.y - circleA.y ) * _spring;


                    circleA.velocity.x *= _friction;

                    circleA.velocity.y *= _friction;


                    circleA.x += circleA.velocity.x;

                    circleA.y += circleA.velocity.y;
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        if ( ! _circle0_dragging )
                        {
                            _springTo ( _circle0, _circle1 );
                            _springTo ( _circle0, _circle2 );
                        }

                        if ( ! _circle1_dragging )
                        {
                            _springTo ( _circle1, _circle0 );
                            _springTo ( _circle1, _circle2 );
                        }

                        if ( ! _circle2_dragging )
                        {
                            _springTo ( _circle2, _circle0 );
                            _springTo ( _circle2, _circle1 );
                        }

                    ////    DRAW    ////////////////////////

                        _context.beginPath ( );

                        _context.moveTo ( _circle0.x, _circle0.y );
                        _context.lineTo ( _circle1.x, _circle1.y );
                        _context.lineTo ( _circle2.x, _circle2.y );
                        _context.lineTo ( _circle0.x, _circle0.y );

                        _context.stroke ( );


                        _circle0.draw ( );

                        _circle1.draw ( );

                        _circle2.draw ( );
                }


                _drawFrame ( );
        },
        // 9:2
        stackingBoxes: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _rectangles = new Array;

                let _activeRectangle = _createRectangle ( );

            ////    SET DEFAULTS    ////////////////////////

                let _gravity   = 0.2;

            ////    FUNCTIONS    ///////////////////////////

                function _createRectangle ( )
                {
                    let _rectangle = new Rectangle;

                        _rectangle.canvas = 'canvas';

                        _rectangle.x      = Math.random ( ) * _canvas.width;


                    _rectangles.push ( _rectangle );


                    return _rectangle;
                }

                function _drawRectangle ( rectangle )
                {
                    if ( _activeRectangle !== rectangle && utils.intersects ( _activeRectangle, rectangle ) )
                    {
                        _activeRectangle.y = rectangle.y - _activeRectangle.height;

                        _activeRectangle   = _createRectangle ( );
                    }


                    rectangle.draw ( );
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _activeRectangle.velocity.y += _gravity;

                        _activeRectangle.y          += _activeRectangle.velocity.y;


                        if ( _activeRectangle.y + _activeRectangle.height > _canvas.height )
                        {
                            _activeRectangle.y = _canvas.height - _activeRectangle.height;

                            _activeRectangle   = _createRectangle ( );
                        }

                    ////    DRAW    ////////////////////////

                        _rectangles.forEach ( _drawRectangle );
                }


                _drawFrame ( );
        },
        // 9:3
        hitTestingAPointAndABoundingBox: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse = utils.captureMouse ( _canvas );

                    _canvas.addEventListener ( 'mousemove', function ( )
                    {
                        if ( utils.containsPoint ( _circle.bounds, _mouse.x, _mouse.y ) )
                        {
                          console.log ( "Hit!" )
                        }
                    } );

            ////    OBJECTS    /////////////////////////////

                let _circle   = new Circle;

                    _circle.canvas = 'canvas';

                    _circle.x = canvas.width  / 2;

                    _circle.y = canvas.height / 2;

            ////    DRAW    ////////////////////////////////

                _circle.draw ( );
        },
        // 9:5
        distanceBasedCollisionDetectionWithArbitrarySize: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse = utils.captureMouse ( _canvas );

                    _canvas.addEventListener ( 'mousemove', _drawFrame, false );

            ////    OBJECTS    /////////////////////////////

                let _circleA = new Circle;

                    _circleA.canvas = 'canvas';

                    _circleA.radius = Math.random ( ) * 100;

                    _circleA.x      = canvas.width  / 2;

                    _circleA.y      = canvas.height / 2;


                let _circleB   = new Circle ( _context, Math.random ( ) * 100 );

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _circleB.x = _mouse.x;

                        _circleB.y = _mouse.y;


                        let _distance = new Point;


                        _distance.x = _circleB.x - _circleA.x;

                        _distance.y = _circleB.y - _circleA.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                        if ( _distance.total < _circleA.radius + _circleB.radius )
                        {
                            console.log ( "Hit!" );
                        }

                    ////    DRAW    ////////////////////////

                        _circleA.draw ( );

                        _circleB.draw ( );
                }


                _drawFrame ( );
        },
        // 9:8
        optimizedMultipleObjectCollisionDetectionAndSpringing: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circles = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount  = 10;

                let _bounce  = -0.5;

                let _spring  = 0.015;

                let _gravity = 0.1;


                let _velocity     = new Point;

                let _target       = new Point;

                let _acceleration = new Point;


            ////    POPULATION    //////////////////////////

                for ( let _circle, _i = 0; _i < _amount; _i++ )
                {
                    _circle = new Circle;


                    _circle.radius = Math.random ( ) * 30 + 20;


                    _circle.x = Math.random ( ) * _canvas.width / 2;

                    _circle.y = Math.random ( ) * _canvas.height / 2;


                    _circle.velocity.x = Math.random ( ) * 6 - 3;

                    _circle.velocity.y = Math.random ( ) * 6 - 3;


                    _circles.push ( _circle );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _checkCollision ( circleA, iter )
                {
                    for ( let _circleB, _distanceX, _distanceY, _distance, _min_distance, _j = iter + 1; _j < _amount; _j++ )
                    {
                        _circleB = _circles [ _j ];


                        _distanceX = _circleB.x - circleA.x;

                        _distanceY = _circleB.y - circleA.y;


                        let _distance = Math.sqrt ( _distanceX * _distanceX + _distanceY * _distanceY );


                        _min_distance = circleA.radius + _circleB.radius;


                        if ( _distance < _min_distance )
                        {
                            _target.x = circleA.x + _distanceX / _distance * _min_distance;

                            _target.y = circleA.y + _distanceY / _distance * _min_distance;


                            _acceleration.x = (_target.x - _circleB.x) * _spring;

                            _acceleration.y = (_target.y - _circleB.y) * _spring;


                            circleA.velocity.x -= _acceleration.x;

                            circleA.velocity.y -= _acceleration.y;


                            _circleB.velocity.x += _acceleration.x;

                            _circleB.velocity.y += _acceleration.y;
                        }
                    }
                }

                function _move ( circle )
                {
                    circle.velocity.y += _gravity;


                    circle.x += circle.velocity.x;

                    circle.y += circle.velocity.y;


                    if ( circle.x + circle.radius > _canvas.width )
                    {
                        circle.x = _canvas.width - circle.radius;

                        circle.velocity.x *= _bounce;
                    }


                    if ( circle.x - circle.radius < 0 )
                    {
                        circle.x = circle.radius;

                        circle.velocity.x *= _bounce;
                    }


                    if ( circle.y + circle.radius > _canvas.height )
                    {
                        circle.y = _canvas.height - circle.radius;

                        circle.velocity.y *= _bounce;
                    }


                    if ( circle.y - circle.radius < 0 )
                    {
                        circle.y = circle.radius;

                        circle.velocity.y *= _bounce;
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( circle )
                {
                    circle.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    DRAW    ////////////////////////

                        _circles.forEach ( _checkCollision );

                        _circles.forEach ( _move );

                        _circles.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 10:2
        rotatingAroundAPointUsingAdvancedCoordinateRotation: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.canvas = 'canvas';

                    _circle.x = Math.random ( ) * _canvas.width;

                    _circle.y = Math.random ( ) * _canvas.height;

            ////    SET DEFAULTS    ////////////////////////

                let _velocityRotation = 0.05;


                let _cos     = Math.cos ( _velocityRotation );

                let _sin     = Math.sin ( _velocityRotation );


                let _centerX = _canvas.width  / 2;

                let _centerY = _canvas.height / 2;

            ////    DRAW    ////////////////////////////////

                function _drawFrmae ( )
                {
                    window.requestAnimationFrame ( _drawFrmae, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        let _x1 = _circle.x - _centerX;

                        let _y1 = _circle.y - _centerY;


                        let _x2 = _cos * _x1 - _sin * _y1;

                        let _y2 = _cos * _y1 + _sin * _x1;


                        _circle.x = _centerX + _x2;

                        _circle.y = _centerY + _y2;

                    ////    DRAW    ////////////////////////

                        _circle.draw ( );
                }


                _drawFrmae ( );
        },
        // 10:3
        rotatingMultipleObjects: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circles = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _numCircles = 10;


                let _centerX = _canvas.width  / 2;

                let _centerY = _canvas.height / 2;


                let _cos = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

                let _sin = undefined;   // ACCESSIBLE BY MOVE AND DRAWFRAME

            ////    POPULATION    //////////////////////////

                for ( let _circle, _i = 0; _i < _numCircles; _i++ )
                {
                    _circle   = new Circle ( _context );

                    _circle.x = Math.random ( ) * _canvas.width;

                    _circle.y = Math.random ( ) * _canvas.height;


                    _circles.push ( _circle );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _move ( circle )
                {
                    let _x1 = circle.x - _centerX;

                    let _y1 = circle.y - _centerY;


                    let _x2 = _cos * _x1 - _sin * _y1;

                    let _y2 = _cos * _y1 + _sin * _x1;


                    circle.x = _centerX + _x2;

                    circle.y = _centerY + _y2;
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( circle )
                {
                    circle.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        let _angle = ( _mouse.x - _centerX ) * 0.0005;


                        _cos = Math.cos ( _angle );

                        _sin = Math.sin ( _angle );

                    ////    DRAW    ////////////////////////

                        _circles.forEach ( _move );

                        _circles.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 10:5
        optimizedBouncingOffAnAngle: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.canvas = 'canvas';

                    _circle.x = 100;

                    _circle.y = 100;


                let _line = new Line ( { x: 0, y: 0 }, { x: _canvas.width, y: 0 } );

                    _line.canvas = 'canvas';

                    _line.x = 0;

                    _line.y = 200;

            ////    SET DEFAULTS    ////////////////////////

                let _rotate = 10;

                    _line.position.rotation = _rotate * Math.PI / 180;


                let _cos = Math.cos ( _line.position.rotation );

                let _sin = Math.sin ( _line.position.rotation );


                let _gravity = 0.2;

                let _bounce  = -0.6;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        /** NORMAL MOTION CODE **/
                        _circle.velocity.y += _gravity;

                        _circle.x          += _circle.velocity.x;

                        _circle.y          += _circle.velocity.y;


                        /** GET POSITION OF _CIRCLE, RELATIVE TO LINE **/
                        let _x1 = _circle.x - _line.x;

                        let _y1 = _circle.y - _line.y;


                        /** ROTATE COORDINATES **/
                        let _y2 = _cos * _y1 - _sin * _x1;


                        /** PERFORM BOUNCE WITH ROTATED VALUES **/
                        if ( _y2 > - _circle.radius )
                        {
                            /** ROTATE COORDINATES **/
                            let _x2 = _cos * _x1 + _sin * _y1;


                            /** ROTATE VELOCITY **/
                            let _vx1 = _cos * _circle.velocity.x + _sin * _circle.velocity.y;

                            let _vy1 = _cos * _circle.velocity.y - _sin * _circle.velocity.x;


                            _y2   = - _circle.radius;

                            _vy1 *= _bounce;


                            /** ROTATE EVERYTHING BACK **/
                            _x1 = _cos * _x2 - _sin * _y2;

                            _y1 = _cos * _y2 + _sin * _x2;


                            _circle.velocity.x = _cos * _vx1 - _sin * _vy1;

                            _circle.velocity.y = _cos * _vy1 + _sin * _vx1;


                            _circle.x = _line.x + _x1;

                            _circle.y = _line.y + _y1;
                        }

                    ////    DRAW    ////////////////////////

                        _circle.draw ( );

                        _line.draw ( );
                }


                _drawFrame ( );
        },
        // 10:8
        bouncingOffAngleAndCheckBoundingBox: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.x = 100;

                    _circle.y = 100;


                let _line = new Line ( new Point ( 0, 0 ), new Point ( 300, 0 ) );

                    _line.x = 50;

                    _line.y = 200;

            ////    SET DEFAULTS    ////////////////////////

                let _gravity = 0.2;

                let _bounce  = -0.6;


                let _start    = new Point;

                let _end      = new Point;

                let _velocity = new Point;

            ////    DRAW    ////////////////////////////////

            function _drawFrame ( )
            {
                window.requestAnimationFrame ( _drawFrame, _canvas );

                ////    LOOP DATA    ///////////////////

                    _timeCurrent = LAB.getFps ( _timeCurrent );

                ////    CLEAR SCREEN    ////////////////

                    _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                ////    TRANSITIONS    /////////////////

                    let _bounds = _line.bounds;


                    // MOVE _LINE WITH MOUSE
                    _line.position.rotation = ( ( _canvas.width / 2 - _mouse.x ) * 0.1 ) * Math.PI / 180;

                    // NORMAL MOTION CODE
                    _circle.velocity.y += _gravity;


                    _circle.x += _circle.velocity.x;

                    _circle.y += _circle.velocity.y;


                    if ( _circle.x + _circle.radius > _bounds.x && _circle.x - _circle.radius < _bounds.x + _bounds.width )
                    {
                        // GET ANGLE, SINE, AND COSINE
                        let _cos = Math.cos ( _line.position.rotation );

                        let _sin = Math.sin ( _line.position.rotation );


                        // GET POSITION OF _CIRCLE, RELATIVE TO _LINE
                        _start.x = _circle.x - _line.x;

                        _start.y = _circle.y - _line.y;


                        // ROTATE COORDINATES
                        _end.y = _cos * _start.y - _sin * _start.x;


                        // PERFORM BOUNCE WITH ROTATED VALUES
                        if ( _end.y > - _circle.radius )
                        {
                            // ROTATE COORDINATES
                            _end.x = _cos * _start.x + _sin * _start.y;

                            // ROTATE VELOCITY
                            _velocity.x = _cos * _circle.velocity.x + _sin * _circle.velocity.y;

                            _velocity.y = _cos * _circle.velocity.y - _sin * _circle.velocity.x;


                            _end.y = - _circle.radius;


                            _velocity.y   *= _bounce;

                            // ROTATE EVERYTHING BACK
                            _start.x = _cos * _end.x - _sin * _end.y;

                            _start.y = _cos * _end.y + _sin * _end.x;


                            _circle.velocity.x = _cos * _velocity.x - _sin * _velocity.y;

                            _circle.velocity.y = _cos * _velocity.y + _sin * _velocity.x;


                            _circle.x = _line.x + _start.x;

                            _circle.y = _line.y + _start.y;
                        }
                    }

                ////    DRAW    ////////////////////////

                    _circle.draw ( );

                    _line.draw ( );
            }


            _drawFrame ( );
        },
        // 10:9
        bouncingOffAngleAndWalls: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.x = 100;

                    _circle.y = 100;


                let _line   = new Line ( new Point ( 0, 0 ), new Point ( 200, 0 ) );

                    _line.x = 50;

                    _line.y = 200;

            ////    SET DEFAULTS    ////////////////////////

                let _gravity = 0.2;

                let _bounce  = -0.6;


                let _start    = new Point;

                let _end      = new Point;

                let _velocity = new Point;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        let _bounds = _line.bounds;


                        // MOVE LINE WITH MOUSE
                        _line.position.rotation = ( ( _canvas.width / 2 - _mouse.x ) * 0.1 ) * Math.PI / 180;


                        // NORMAL MOTION CODE
                        _circle.velocity.y += _gravity;


                        _circle.x += _circle.velocity.x;

                        _circle.y += _circle.velocity.y;


                        if ( _circle.x + _circle.radius > _bounds.x && _circle.x - _circle.radius < _bounds.x + _bounds.width )
                        {
                            // GET ANGLE, SINE, AND COSINE
                            let _cos = Math.cos ( _line.position.rotation );

                            let _sin = Math.sin ( _line.position.rotation );


                            // GET POSITION OF _CIRCLE, RELATIVE TO _LINE
                            _start.x = _circle.x - _line.x,

                            _start.y = _circle.y - _line.y,


                            // ROTATE COORDINATES
                            _end.y = _cos * _start.y - _sin * _start.x;


                            // ROTATE VELOCITY
                            _velocity.y = _cos * _circle.velocity.y - _sin * _circle.velocity.x;


                            // PERFORM BOUNCE WITH ROTATED VALUES
                            if ( _end.y > - _circle.radius && _end.y < _velocity.y )
                            {
                                // ROTATE COORDINATES
                                _end.x = _cos * _start.x + _sin * _start.y,


                                // ROTATE VELOCITY
                                _velocity.x  = _cos * _circle.velocity.x + _sin * _circle.velocity.y;

                                _end.y       = - _circle.radius;

                                _velocity.y *= _bounce;


                                // ROTATE EVERYTHING BACK
                                _start.x = _cos * _end.x - _sin * _end.y;

                                _start.y = _cos * _end.y + _sin * _end.x;


                                _circle.velocity.x = _cos * _velocity.x - _sin * _velocity.y;

                                _circle.velocity.y = _cos * _velocity.y + _sin * _velocity.x;


                                _circle.x = _line.x + _start.x;

                                _circle.y = _line.y + _start.y;
                            }
                        }

                        // BOUNCE OFF CEILING, FLOOR, AND WALLS
                        if ( _circle.x + _circle.radius > _canvas.width )
                        {
                            _circle.x = _canvas.width - _circle.radius;

                            _circle.velocity.x *= _bounce;
                        }


                        if ( _circle.x - _circle.radius < 0 )
                        {
                            _circle.x = _circle.radius;

                            _circle.velocity.x *= _bounce;
                        }


                        if ( _circle.y + _circle.radius > _canvas.height )
                        {
                            _circle.y = _canvas.height - _circle.radius;

                            _circle.velocity.y *= _bounce;
                        }


                        if ( _circle.y - _circle.radius < 0 )
                        {
                            _circle.y = _circle.radius;

                            _circle.velocity.y *= _bounce;
                        }


                        _circle.draw ( );

                        _line.draw ( );
                }


                _drawFrame ( );
        },
        // 10:10
        bouncingOffMultipleAngles: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.x = 100;

                    _circle.y = 50;


                let _lines  = new Array;

                    // CREATE 5 LINES, POSITION AND ROTATE
                    _lines [ 0 ] = new Line( new Point ( -50, 0 ), new Point ( 50, 0 ) );

                    _lines [ 0 ].x = 100;
                    _lines [ 0 ].y = 100;

                    _lines [ 0 ].position.rotation = 30 * Math.PI / 180;


                    _lines [ 1 ] = new Line( new Point ( -50, 0 ), new Point ( 50, 0 ) );

                    _lines [ 1 ].x = 100;
                    _lines [ 1 ].y = 200;

                    _lines [ 1 ].position.rotation = 45 * Math.PI / 180;


                    _lines [ 2 ] = new Line( new Point ( -50, 0 ), new Point ( 50, 0 ) );

                    _lines [ 2 ].x = 220;
                    _lines [ 2 ].y = 150;

                    _lines [ 2 ].position.rotation = -20 * Math.PI / 180;


                    _lines [ 3 ] = new Line( new Point ( -50, 0 ), new Point ( 50, 0 ) );

                    _lines [ 3 ].x = 150;
                    _lines [ 3 ].y = 330;

                    _lines [ 3 ].position.rotation = 10 * Math.PI / 180;


                    _lines [ 4 ] = new Line( new Point ( -50, 0 ), new Point ( 50, 0 ) );

                    _lines [ 4 ].x = 230;
                    _lines [ 4 ].y = 250;

                    _lines [ 4 ].position.rotation = -30 * Math.PI / 180;

            ////    SET DEFAULTS    ////////////////////////

                let _gravity = 0.2;

                let _bounce  = -0.6;


                let _start    = new Point;

                let _end      = new Point;

                let _velocity = new Point;

            ////    FUNCTIONS    ///////////////////////////

                function _checkLine ( line )
                {
                    let _bounds = line.bounds;


                    if ( _circle.x + _circle.radius > _bounds.x && _circle.x - _circle.radius < _bounds.x + _bounds.width )
                    {
                        // GET ANGLE, SINE, AND COSINE
                        let _cos = Math.cos ( line.position.rotation );

                        let _sin = Math.sin ( line.position.rotation );


                        // GET POSITION OF _CIRCLE, RELATIVE TO LINE
                        _start.x = _circle.x - line.x;

                        _start.y = _circle.y - line.y;


                        // ROTATE COORDINATES
                        _end.y = _cos * _start.y - _sin * _start.x;


                        // ROTATE VELOCITY
                        _velocity.y = _cos * _circle.velocity.y - _sin * _circle.velocity.x;


                        // PERFORM BOUNCE WITH ROTATED VALUES
                        if ( _end.y > - _circle.radius && _end.y < _velocity.y )
                        {
                            // ROTATE COORDINATES
                            _end.x = _cos * _start.x + _sin * _start.y;

                            // ROTATE VELOCITY
                            _velocity.x  = _cos * _circle.velocity.x + _sin * _circle.velocity.y;

                            _end.y       = - _circle.radius;

                            _velocity.y *= _bounce;


                            // ROTATE EVERYTHING BACK
                            _start.x = _cos * _end.x - _sin * _end.y;

                            _start.y = _cos * _end.y + _sin * _end.x;


                            _circle.velocity.x = _cos * _velocity.x - _sin * _velocity.y;

                            _circle.velocity.y = _cos * _velocity.y + _sin * _velocity.x;


                            _circle.x = line.x + _start.x;

                            _circle.y = line.y + _start.y;
                        }
                    }
                }

                function _drawLine ( line )
                {
                    _checkLine ( line );

                    line.draw ( );
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        // NORMAL MOTION CODE
                        _circle.velocity.y += _gravity;

                        _circle.x += _circle.velocity.x;
                        _circle.y += _circle.velocity.y;

                        // BOUNCE OFF CEILING, FLOOR, AND WALLS
                        if ( _circle.x + _circle.radius > _canvas.width )
                        {
                            _circle.x = _canvas.width - _circle.radius;

                            _circle.velocity.x *= _bounce;
                        }


                        if ( _circle.x - _circle.radius < 0 )
                        {
                            _circle.x = _circle.radius;

                            _circle.velocity.x *= _bounce;
                        }


                        if ( _circle.y + _circle.radius > _canvas.height )
                        {
                            _circle.y = _canvas.height - _circle.radius;

                            _circle.velocity.y *= _bounce;
                        }


                        if ( _circle.y - _circle.radius < 0 )
                        {
                            _circle.y = _circle.radius;

                            _circle.velocity.y *= _bounce;
                        }

                    ////    DRAW    ////////////////////////

                        _lines.forEach ( _drawLine );

                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // 11:2
        optimizedConservationOfMomentumOnOneAxis: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circle0 = new Circle;


                    _circle0.mass = 2;


                    _circle0.x = 50;

                    _circle0.y = _canvas.height / 2;


                    _circle0.velocity.x = 1;


                let _circle1 = new Circle;


                    _circle1.mass = 1;


                    _circle1.x = 300;

                    _circle1.y = _canvas.height / 2;


                    _circle1.velocity.x = -1;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ()
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _circle0.x += _circle0.velocity.x;

                        _circle1.x += _circle1.velocity.x;


                        let _distance = _circle1.x - _circle0.x;


                        // ON COLLISION
                        if ( Math.abs ( _distance ) < _circle0.radius + _circle1.radius )
                        {
                            let _velocityXTotal = _circle0.velocity.x - _circle1.velocity.x;


                            _circle0.velocity.x = ( ( _circle0.mass - _circle1.mass) * _circle0.velocity.x + 2 * _circle1.mass * _circle1.velocity.x ) / ( _circle0.mass + _circle1.mass );

                            _circle1.velocity.x = _velocityXTotal + _circle0.velocity.x;


                            _circle0.x += _circle0.velocity.x;

                            _circle1.y += _circle1.velocity.x;
                        }

                    ////    DRAW    ////////////////////////

                        _circle0.draw ( );

                        _circle1.draw ( );
                }


                _drawFrame ( );
        },
        // 11:4
        optimizedConservationOfMomentumOnTwoAxes: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circle0 = new Circle;


                    _circle0.mass = 2;


                    _circle0.x = canvas.width  - 200;

                    _circle0.y = canvas.height - 200;


                    _circle0.velocity.x = Math.random() * 10 - 5;

                    _circle0.velocity.y = Math.random() * 10 - 5;


                let _circle1 = new Circle();


                    _circle1.mass = 1;


                    _circle1.x = 100;

                    _circle1.y = 100;


                    _circle1.velocity.x = Math.random() * 10 - 5;

                    _circle1.velocity.y = Math.random() * 10 - 5;

            ////    SET DEFAULTS    ////////////////////////

                let _bounce = -1.0;

            ////    FUNCTIONS    ///////////////////////////

                function _rotate ( x, y, sin, cos, reverse )
                {
                    return {
                               x: ( reverse ) ? ( x * cos + y * sin ) : ( x * cos - y * sin ),

                               y: ( reverse ) ? ( y * cos - x * sin ) : ( y * cos + x * sin )
                           };
                }

                function _checkCollision ( object0, object1 )
                {
                    let _distance = new Point;


                        _distance.x   = object1.x - object0.x;

                        _distance.y   = object1.y - object0.y;


                    _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    // COLLISION HANDLING CODE HERE
                    if ( _distance.total < object0.radius + object1.radius )
                    {
                        // CALCULATE ANGLE, SINE, AND COSINE
                        let _angle = Math.atan2 ( _distance.y, _distance.x );


                        let _sin = Math.sin ( _angle );

                        let _cos = Math.cos ( _angle );


                        // ROTATE OBJECT0'S POSITION
                        let _position0 = new Point;


                        // ROTATE OBJECT1'S POSITION
                        let _position1 = _rotate ( _distance.x, _distance.y, _sin, _cos, true );


                        // ROTATE OBJECT0'S VELOCITY
                        let _velocity0 = _rotate ( object0.velocity.x, object0.velocity.y, _sin, _cos, true );


                        // ROTATE OBJECT1'S VELOCITY
                        let _velocity1 = _rotate ( object1.velocity.x, object1.velocity.y, _sin, _cos, true );


                        // COLLISION REACTION
                        let _velocityXTotal = _velocity0.x - _velocity1.x;


                            _velocity0.x = ( ( object0.mass - object1.mass ) * _velocity0.x + 2 * object1.mass * _velocity1.x ) / ( object0.mass + object1.mass );

                            _velocity1.x = _velocityXTotal + _velocity0.x;


                            // UPDATE POSITION
                            _position0.x += _velocity0.x;

                            _position1.x += _velocity1.x;


                        // ROTATE POSITIONS BACK
                        let _position0Final = _rotate ( _position0.x, _position0.y, _sin, _cos, false );

                        let _position1Final = _rotate ( _position1.x, _position1.y, _sin, _cos, false );


                        // ADJUST POSITIONS TO ACTUAL SCREEN POSITIONS
                        object1.x = object0.x + _position1Final.x;

                        object1.y = object0.y + _position1Final.y;


                        object0.x = object0.x + _position0Final.x;

                        object0.y = object0.y + _position0Final.y;


                        // ROTATE VELOCITIES BACK
                        let _velocity0Final = _rotate ( _velocity0.x, _velocity0.y, _sin, _cos, false );

                        let _velocity1Final = _rotate ( _velocity1.x, _velocity1.y, _sin, _cos, false );


                        object0.velocity.x = _velocity0Final.x;

                        object0.velocity.y = _velocity0Final.y;


                        object1.velocity.x = _velocity1Final.x;

                        object1.velocity.y = _velocity1Final.y;
                    }
                }

                function _checkWalls ( object )
                {
                    if ( object.x + object.radius > _canvas.width )
                    {
                        object.x           = _canvas.width - object.radius;

                        object.velocity.x *= _bounce;
                    }


                    if ( object.x - object.radius < 0 )
                    {
                        object.x           = object.radius;

                        object.velocity.x *= _bounce;
                    }


                    if ( object.y + object.radius > _canvas.height )
                    {
                        object.y           = _canvas.height - object.radius;

                        object.velocity.y *= _bounce;
                    }


                    if ( object.y - object.radius < 0 )
                    {
                        object.y           = object.radius;

                        object.velocity.y *= _bounce;
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _circle0.x += _circle0.velocity.x;

                        _circle0.y += _circle0.velocity.y;


                        _circle1.x += _circle1.velocity.x;

                        _circle1.y += _circle1.velocity.y;


                        _checkCollision ( _circle0, _circle1 );


                        _checkWalls ( _circle0 );

                        _checkWalls ( _circle1 );

                    ////    DRAW    ////////////////////////

                        _circle0.draw ( );

                        _circle1.draw ( );
                }


                _drawFrame ( );
        },
        // 11:6
        multipleObjectCollisionsWithProblemFixed: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circles = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount = 15;

                let _bounce = -1.0;


                for ( let _radius, _circle, _i = 0; _i < _amount; _i++ )
                {
                    _radius = Math.random ( ) * 20 + 15;


                    _circle = new Circle;


                    _circle.radius = _circle.mass = _radius;


                    _circle.x = Math.random ( ) * _canvas.width;

                    _circle.y = Math.random ( ) * _canvas.height;


                    _circle.velocity.x = Math.random ( ) * 10 - 5;

                    _circle.velocity.y = Math.random ( ) * 10 - 5;


                    _circles.push ( _circle );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _rotate ( x, y, sin, cos, reverse )
                {
                    return {
                               x: ( reverse ) ? ( x * cos + y * sin ) : ( x * cos - y * sin ),

                               y: ( reverse ) ? ( y * cos - x * sin ) : ( y * cos + x * sin )
                           };
                }

                function _checkCollision ( object0, object1 )
                {
                    let _distance = new Point;


                        _distance.x = object1.x - object0.x;

                        _distance.y = object1.y - object0.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    // COLLISION HANDLING CODE HERE
                    if ( _distance.total < object0.radius + object1.radius )
                    {
                        // CALCULATE ANGLE, SINE, AND COSINE
                        let _angle = Math.atan2 ( _distance.y, _distance.x );


                        let _sin = Math.sin ( _angle );

                        let _cos = Math.cos ( _angle );


                        // ROTATE OBJECT0'S POSITION
                        let _position0 = new Point;


                        // ROTATE OBJECT1'S POSITION
                        let _position1 = _rotate ( _distance.x, _distance.y, _sin, _cos, true );


                        // ROTATE OBJECT0'S VELOCITY
                        let _velocity0 = _rotate ( object0.velocity.x, object0.velocity.y, _sin, _cos, true );


                        // ROTATE OBJECT1'S VELOCITY
                        let _velocity1 = _rotate ( object1.velocity.x, object1.velocity.y, _sin, _cos, true );


                        // COLLISION REACTION
                        let _vxTotal = _velocity0.x - _velocity1.x;


                            _velocity0.x = ( ( object0.mass - object1.mass ) * _velocity0.x + 2 * object1.mass * _velocity1.x ) / ( object0.mass + object1.mass );

                            _velocity1.x = _vxTotal + _velocity0.x;


                        // UPDATE POSITION - TO AVOID OBJECTS BECOMING STUCK TOGETHER
                        let _absoluteVelocity = Math.abs ( _velocity0.x ) + Math.abs ( _velocity1.x );


                        let _overlap = ( object0.radius + object1.radius ) - Math.abs ( _position0.x - _position1.x );


                            _position0.x += _velocity0.x / _absoluteVelocity * _overlap;

                            _position1.x += _velocity1.x / _absoluteVelocity * _overlap;


                        // ROTATE POSITIONS BACK
                        let _position0Final = _rotate ( _position0.x, _position0.y, _sin, _cos, false );

                        let _position1Final = _rotate ( _position1.x, _position1.y, _sin, _cos, false );


                        // ADJUST POSITIONS TO ACTUAL SCREEN POSITIONS
                        object1.x = object0.x + _position1Final.x;

                        object1.y = object0.y + _position1Final.y;


                        object0.x = object0.x + _position0Final.x;

                        object0.y = object0.y + _position0Final.y;


                        // ROTATE VELOCITIES BACK
                        let _velocity0Final = _rotate ( _velocity0.x, _velocity0.y, _sin, _cos, false );

                        let _velocity1Final = _rotate ( _velocity1.x, _velocity1.y, _sin, _cos, false );


                        object0.velocity.x = _velocity0Final.x;

                        object0.velocity.y = _velocity0Final.y;


                        object1.velocity.x = _velocity1Final.x;

                        object1.velocity.y = _velocity1Final.y;
                    }
                }

                function _checkWalls ( object )
                {
                    if ( object.x + object.radius > _canvas.width )
                    {
                        object.x           = _canvas.width - object.radius;

                        object.velocity.x *= _bounce;
                    }


                    if ( object.x - object.radius < 0 )
                    {
                        object.x           = object.radius;

                        object.velocity.x *= _bounce;
                    }


                    if ( object.y + object.radius > _canvas.height )
                    {
                        object.y           = _canvas.height - object.radius;

                        object.velocity.y *= _bounce;
                    }


                    if ( object.y - object.radius < 0 )
                    {
                        object.y           = object.radius;

                        object.velocity.y *= _bounce;
                    }
                }

                function _move ( object )
                {
                    object.x += object.velocity.x;

                    object.y += object.velocity.y;


                    _checkWalls ( object );
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( object )
                {
                    object.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _circles.forEach ( _move );


                        for ( let _objectA, _i = 0, _length = _amount - 1; _i < _length; _i++ )
                        {
                            _objectA = _circles [ _i ];


                            for ( let _objectB, _j = _i + 1; _j < _amount; _j++ )
                            {
                                _objectB = _circles [ _j ];

                                _checkCollision ( _objectA, _objectB );
                            }
                        }

                    ////    DRAW    ////////////////////////

                        _circles.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 12:3
        gravitationalForceAndCollisionDetectionWithRandomSizes: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _particles = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount = 30;

            ////    POPULATION    //////////////////////////

                for ( let _size, _particle, _i = 0; _i < _amount; _i++ )
                {
                    _size = Math.random ( ) * 25 + 5;


                    _particle = new Circle;


                    _particle.radius = _size;


                    _particle.x = Math.random ( ) * _canvas.width;

                    _particle.y = Math.random ( ) * _canvas.height;


                    _particle.mass = _size;


                    _particles.push ( _particle );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _rotate ( x, y, sin, cos, reverse )
                {
                    return {
                               x: ( reverse ) ? ( x * cos + y * sin ) : ( x * cos - y * sin ),

                               y: ( reverse ) ? ( y * cos - x * sin ) : ( y * cos + x * sin )
                           };
                }

                function _checkCollision ( object0, object1 )
                {
                    let _distance = new Point;


                        _distance.x = object1.x - object0.x;

                        _distance.y = object1.y - object0.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    // COLLISION HANDLING CODE HERE
                    if ( _distance.total < object0.radius + object1.radius )
                    {
                        // CALCULATE ANGLE, SINE, AND COSINE
                        let _angle = Math.atan2 ( _distance.y, _distance.x );

                        let _sin   = Math.sin ( _angle );

                        let _cos   = Math.cos ( _angle );


                        // ROTATE BALL0'S POSITION
                        let _position0 = new Point;


                        // ROTATE BALL1'S POSITION
                        let _position1 = _rotate ( _distance.x, _distance.y, _sin, _cos, true );


                        // ROTATE BALL0'S VELOCITY
                        let _velocity0 = _rotate ( object0.velocity.x, object0.velocity.y, _sin, _cos, true );


                        // ROTATE BALL1'S VELOCITY
                        let _velocity1 = _rotate ( object1.velocity.x, object1.velocity.y, _sin, _cos, true );


                        // COLLISION REACTION
                        let _vxTotal = _velocity0.x - _velocity1.x;


                            _velocity0.x = ( ( object0.mass - object1.mass ) * _velocity0.x + 2 * object1.mass * _velocity1.x ) / ( object0.mass + object1.mass );

                            _velocity1.x = _vxTotal + _velocity0.x;


                        // UPDATE POSITION - TO AVOID OBJECTS BECOMING STUCK TOGETHER
                        let _absoluteVelocity = Math.abs ( _velocity0.x ) + Math.abs ( _velocity1.x );


                        let _overlap = ( object0.radius + object1.radius ) - Math.abs ( _position0.x - _position1.x );


                            _position0.x += _velocity0.x / _absoluteVelocity * _overlap;

                            _position1.x += _velocity1.x / _absoluteVelocity * _overlap;


                        // ROTATE POSITIONS BACK
                        let _position0Final = _rotate ( _position0.x, _position0.y, _sin, _cos, false );

                        let _position1Final = _rotate ( _position1.x, _position1.y, _sin, _cos, false );


                        // ADJUST POSITIONS TO ACTUAL SCREEN POSITIONS
                        object1.x = object0.x + _position1Final.x;

                        object1.y = object0.y + _position1Final.y;


                        object0.x = object0.x + _position0Final.x;

                        object0.y = object0.y + _position0Final.y;


                        // ROTATE VELOCITIES BACK
                        let _velocity0Final = _rotate ( _velocity0.x, _velocity0.y, _sin, _cos, false );

                        let _velocity1Final = _rotate ( _velocity1.x, _velocity1.y, _sin, _cos, false );


                        object0.velocity.x = _velocity0Final.x;

                        object0.velocity.y = _velocity0Final.y;


                        object1.velocity.x = _velocity1Final.x;

                        object1.velocity.y = _velocity1Final.y;
                    }
                }

                function _gravitate ( objectA, objectB )
                {
                    let _distance = new Point;

                    let _acceleration = new Point;


                        _distance.x = objectB.x - objectA.x;

                        _distance.y = objectB.y - objectA.y;


                        _distance.squared = _distance.x * _distance.x + _distance.y * _distance.y;


                        _distance.total = Math.sqrt ( _distance.squared );


                    let _force = objectA.mass * objectB.mass / _distance.squared;


                        _acceleration.x = _force * _distance.x / _distance.total;

                        _acceleration.y = _force * _distance.y / _distance.total;


                    objectA.velocity.x += _acceleration.x / objectA.mass;

                    objectA.velocity.y += _acceleration.y / objectA.mass;


                    objectB.velocity.x -= _acceleration.x / objectB.mass;

                    objectB.velocity.y -= _acceleration.y / objectB.mass;
                }

                function _move ( objectA, iter )
                {
                    objectA.x += objectA.velocity.x;

                    objectA.y += objectA.velocity.y;


                    for ( let _objectB, _j = iter + 1; _j < _amount; _j++ )
                    {
                        _objectB = _particles [ _j ];


                        _checkCollision ( objectA, _objectB );


                        _gravitate ( objectA, _objectB );
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( particle )
                {
                    particle.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _particles.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _particles.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 12:4
        objectInOrbit: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _sun = new Circle;


                    _sun.radius = 100;


                    _sun.x = canvas.width  / 2;

                    _sun.y = canvas.height / 2;


                    _sun.mass = 10000;


                let _planet = new Circle;


                    _planet.radius = 10;


                    _planet.x = canvas.width  / 2 + 200;

                    _planet.y = canvas.height / 2;


                    _planet.velocity.y = 7;


                    _planet.mass = 1;


                let _particles = new Array;


                    _particles.push ( _sun );

                    _particles.push ( _planet );

            ////    FUNCTIONS    ///////////////////////////

                function _rotate ( x, y, sin, cos, reverse )
                {
                    return {
                               x: ( reverse ) ? ( x * cos + y * sin ) : ( x * cos - y * sin ),

                               y: ( reverse ) ? ( y * cos - x * sin ) : ( y * cos + x * sin )
                           };
                }

                function _checkCollision ( ball0, ball1 )
                {
                    let _distance = new Point;


                        _distance.x = ball1.x - ball0.x;

                        _distance.y = ball1.y - ball0.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    // COLLISION HANDLING CODE HERE
                    if ( _distance.total < ball0.radius + ball1.radius )
                    {
                        // CALCULATE ANGLE, SINE, AND COSINE
                        let _angle = Math.atan2 ( _distance.y, _distance.x );


                        let _sin = Math.sin ( _angle );

                        let _cos = Math.cos ( _angle );


                        // ROTATE BALL0'S POSITION
                        let _position0 = new Point;


                        // ROTATE BALL1'S POSITION
                        let _position1 = _rotate ( _distance.x, _distance.y, _sin, _cos, true );


                        // ROTATE BALL0'S VELOCITY
                        let _velocity0 = _rotate ( ball0.velocity.x, ball0.velocity.y, _sin, _cos, true );


                        // ROTATE BALL1'S VELOCITY
                        let _velocity1 = _rotate ( ball1.velocity.x, ball1.velocity.y, _sin, _cos, true );


                        // COLLISION REACTION
                        let _vxTotal = _velocity0.x - _velocity1.x;


                            _velocity0.x = ( ( ball0.mass - ball1.mass ) * _velocity0.x + 2 * ball1.mass * _velocity1.x ) / ( ball0.mass + ball1.mass );

                            _velocity1.x = _vxTotal + _velocity0.x;


                        // UPDATE POSITION - TO AVOID OBJECTS BECOMING STUCK TOGETHER
                        let _absoluteVelocity = Math.abs ( _velocity0.x ) + Math.abs ( _velocity1.x );


                        let _overlap = ( ball0.radius + ball1.radius ) - Math.abs ( _position0.x - _position1.x );


                            _position0.x += _velocity0.x / _absoluteVelocity * _overlap;

                            _position1.x += _velocity1.x / _absoluteVelocity * _overlap;


                        // ROTATE POSITIONS BACK
                        let _position0Final = _rotate ( _position0.x, _position0.y, _sin, _cos, false );

                        let _position1Final = _rotate ( _position1.x, _position1.y, _sin, _cos, false );


                        // ADJUST POSITIONS TO ACTUAL SCREEN POSITIONS
                        ball1.x = ball0.x + _position1Final.x;

                        ball1.y = ball0.y + _position1Final.y;


                        ball0.x = ball0.x + _position0Final.x;

                        ball0.y = ball0.y + _position0Final.y;


                        // ROTATE VELOCITIES BACK
                        let _velocity0Final = _rotate ( _velocity0.x, _velocity0.y, _sin, _cos, false );

                        let _velocity1Final = _rotate ( _velocity1.x, _velocity1.y, _sin, _cos, false );


                        ball0.velocity.x = _velocity0Final.x;

                        ball0.velocity.y = _velocity0Final.y;


                        ball1.velocity.x = _velocity1Final.x;

                        ball1.velocity.y = _velocity1Final.y;
                    }
                }

                function _gravitate ( objectA, objectB )
                {
                    let _distance     = new Point;

                    let _acceleration = new Point;


                        _distance.x = objectB.x - objectA.x;

                        _distance.y = objectB.y - objectA.y;


                        _distance.squared = _distance.x * _distance.x + _distance.y * _distance.y;


                        _distance.total = Math.sqrt ( _distance.squared );


                    let _force = objectA.mass * objectB.mass / _distance.squared;


                        _acceleration.x = _force * _distance.x / _distance.total;

                        _acceleration.y = _force * _distance.y / _distance.total;


                    objectA.velocity.x += _acceleration.x / objectA.mass;

                    objectA.velocity.y += _acceleration.y / objectA.mass;


                    objectB.velocity.x -= _acceleration.x / objectB.mass;

                    objectB.velocity.y -= _acceleration.y / objectB.mass;
                }

                function _move ( objectA, iter )
                {
                    objectA.x += objectA.velocity.x;

                    objectA.y += objectA.velocity.y;


                    for ( let _objectB, _j = iter + 1; _j < _particles.length; _j++ )
                    {
                        _objectB = _particles [ _j ];


                        _checkCollision ( objectA, _objectB );

                        _gravitate ( objectA, _objectB );
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( particle )
                {
                    particle.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _particles.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _particles.forEach ( _draw );
                }

                _drawFrame ( );
        },
        // 12:5
        drawingAlongTheOrbitalPath: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _sun = new Circle;


                    _sun.radius = 100;


                    _sun.x = canvas.width  / 2;

                    _sun.y = canvas.height / 2;


                    _sun.mass = 10000;


                let _planet = new Circle;


                    _planet.radius = 10;


                    _planet.x = canvas.width  / 2 + 200;

                    _planet.y = canvas.height / 2;


                    _planet.velocity.y = 7;


                    _planet.mass = 1;


                let _particles = new Array;


                    _particles.push ( _sun );

                    _particles.push ( _planet );

            ////    FUNCTIONS    ///////////////////////////

                function _rotate ( x, y, sin, cos, reverse )
                {
                    return {
                               x: ( reverse ) ? ( x * cos + y * sin ) : ( x * cos - y * sin ),

                               y: ( reverse ) ? ( y * cos - x * sin ) : ( y * cos + x * sin )
                           };
                }

                function _checkCollision ( ball0, ball1 )
                {
                    let _distance = new Point;


                        _distance.x = ball1.x - ball0.x;

                        _distance.y = ball1.y - ball0.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    // COLLISION HANDLING CODE HERE
                    if ( _distance.total < ball0.radius + ball1.radius )
                    {
                        // CALCULATE ANGLE, SINE, AND COSINE
                        let _angle = Math.atan2 ( _distance.y, _distance.x );


                        let _sin = Math.sin ( _angle );

                        let _cos = Math.cos ( _angle );


                        // ROTATE BALL0'S POSITION
                        let _position0 = new Point;


                        // ROTATE BALL1'S POSITION
                        let _position1 = _rotate ( _distance.x, _distance.y, _sin, _cos, true );


                        // ROTATE BALL0'S VELOCITY
                        let _velocity0 = _rotate ( ball0.velocity.x, ball0.velocity.y, _sin, _cos, true );


                        // ROTATE BALL1'S VELOCITY
                        let _velocity1 = _rotate ( ball1.velocity.x, ball1.velocity.y, _sin, _cos, true );


                        // COLLISION REACTION
                        let _vxTotal = _velocity0.x - _velocity1.x;


                            _velocity0.x = ( ( ball0.mass - ball1.mass ) * _velocity0.x + 2 * ball1.mass * _velocity1.x ) / ( ball0.mass + ball1.mass );

                            _velocity1.x = _vxTotal + _velocity0.x;


                        // UPDATE POSITION - TO AVOID OBJECTS BECOMING STUCK TOGETHER
                        let _absoluteVelocity = Math.abs ( _velocity0.x ) + Math.abs ( _velocity1.x );


                        let _overlap = ( ball0.radius + ball1.radius ) - Math.abs ( _position0.x - _position1.x );


                            _position0.x += _velocity0.x / _absoluteVelocity * _overlap;

                            _position1.x += _velocity1.x / _absoluteVelocity * _overlap;


                        // ROTATE POSITIONS BACK
                        let _position0Final = _rotate ( _position0.x, _position0.y, _sin, _cos, false );

                        let _position1Final = _rotate ( _position1.x, _position1.y, _sin, _cos, false );


                        // ADJUST POSITIONS TO ACTUAL SCREEN POSITIONS
                        ball1.x = ball0.x + _position1Final.x;

                        ball1.y = ball0.y + _position1Final.y;


                        ball0.x = ball0.x + _position0Final.x;

                        ball0.y = ball0.y + _position0Final.y;


                        // ROTATE VELOCITIES BACK
                        let _velocity0Final = _rotate ( _velocity0.x, _velocity0.y, _sin, _cos, false );

                        let _velocity1Final = _rotate ( _velocity1.x, _velocity1.y, _sin, _cos, false );


                        ball0.velocity.x = _velocity0Final.x;

                        ball0.velocity.y = _velocity0Final.y;


                        ball1.velocity.x = _velocity1Final.x;

                        ball1.velocity.y = _velocity1Final.y;
                    }
                }

                function _gravitate ( objectA, objectB )
                {
                    let _distance     = new Point;

                    let _acceleration = new Point;


                        _distance.x = objectB.x - objectA.x;

                        _distance.y = objectB.y - objectA.y;


                        _distance.squared = _distance.x * _distance.x + _distance.y * _distance.y;


                        _distance.total = Math.sqrt ( _distance.squared );


                    let _force = objectA.mass * objectB.mass / _distance.squared;


                        _acceleration.x = _force * _distance.x / _distance.total;

                        _acceleration.y = _force * _distance.y / _distance.total;


                    objectA.velocity.x += _acceleration.x / objectA.mass;

                    objectA.velocity.y += _acceleration.y / objectA.mass;


                    objectB.velocity.x -= _acceleration.x / objectB.mass;

                    objectB.velocity.y -= _acceleration.y / objectB.mass;
                }

                function _move ( objectA, iter )
                {
                    objectA.x += objectA.velocity.x;

                    objectA.y += objectA.velocity.y;


                    for ( let _objectB, _j = iter + 1; _j < _particles.length; _j++ )
                    {
                        _objectB = _particles [ _j ];


                        _checkCollision ( objectA, _objectB );

                        _gravitate ( objectA, _objectB );
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( particle )
                {
                    particle.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        // _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _particles.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _particles.forEach ( _draw );
                }

                _drawFrame ( );
        },
        // 12:6
        connectingParticlesWithSprings: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _particles = new Array;

            ////   SET DEFAULTS    /////////////////////////

                let _amount       = 30;

                let _minDistance  = 100;

                let _springAmount = 0.001;

            ////    POPULATION    //////////////////////////

                for ( let _particle, _i = 0; _i < _amount; _i++ )
                {
                    _particle = new Circle;


                    _particle.radius = 5;


                    _particle.x = Math.random ( ) * _canvas.width;

                    _particle.y = Math.random ( ) * _canvas.height;


                    _particle.velocity.x = Math.random ( ) * 6 - 3;

                    _particle.velocity.y = Math.random ( ) * 6 - 3;


                    _particles.push ( _particle );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _spring ( objectA, objectB )
                {
                    let _distance     = new Point;

                    let _acceleration = new Point;


                        _distance.x = objectB.x - objectA.x;

                        _distance.y = objectB.y - objectA.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    if ( _distance.total < _minDistance )
                    {
                        _acceleration.x = _distance.x * _springAmount;

                        _acceleration.y = _distance.y * _springAmount;


                        objectA.velocity.x += _acceleration.x;

                        objectA.velocity.y += _acceleration.y;


                        objectB.velocity.x -= _acceleration.x;

                        objectB.velocity.y -= _acceleration.y;
                    }
                }

                function _move ( objectA, iter )
                {
                    objectA.x += objectA.velocity.x;

                    objectA.y += objectA.velocity.y;


                    if ( objectA.x > _canvas.width )

                        objectA.x = 0;


                    if ( objectA.x < 0 )

                        objectA.x = _canvas.width;


                    if ( objectA.y > _canvas.height )

                        objectA.y = 0;


                    if ( objectA.y < 0 )

                        objectA.y = _canvas.height;


                    for ( let _objectB, _j = iter + 1; _j < _amount; _j++ )
                    {
                        _objectB = _particles [ _j ];


                        _spring ( objectA, _objectB );
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( particle )
                {
                    particle.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _particles.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _particles.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 12:7
        drawingLinesBetweenConnectedParticles: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _particles = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount       = 30;

                let _minDistance  = 100;

                let _springAmount = 0.001;

            ////    POPULATION    //////////////////////////

                for ( let _particle, _i = 0; _i < _amount; _i++ )
                {
                    _particle = new Circle;


                    _particle.radius = 5;


                    _particle.x = Math.random ( ) * _canvas.width;

                    _particle.y = Math.random ( ) * _canvas.height;


                    _particle.velocity.x = Math.random ( ) * 6 - 3;

                    _particle.velocity.y = Math.random ( ) * 6 - 3;


                    _particles.push ( _particle );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _drawLine ( objectA, objectB )
                {
                    let _distance     = new Point;

                    let _acceleration = new Point;


                        _distance.x = objectB.x - objectA.x;

                        _distance.y = objectB.y - objectA.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    if ( _distance.total < _minDistance )
                    {
                        let _alpha = 1 - _distance.total / _minDistance;


                        _context.strokeStyle = utils.colorToRGB ( "#000000", _alpha );


                        _context.beginPath ( );


                        _context.moveTo ( objectA.x, objectA.y );

                        _context.lineTo ( objectB.x, objectB.y );


                        _context.stroke ( );


                        _acceleration.x = _distance.x * _springAmount;

                        _acceleration.y = _distance.y * _springAmount;


                        objectA.velocity.x += _acceleration.x;

                        objectA.velocity.y += _acceleration.y;


                        objectB.velocity.x -= _acceleration.x;

                        objectB.velocity.y -= _acceleration.y;
                    }
                }

                function _move ( objectA, iter )
                {
                    objectA.x += objectA.velocity.x;

                    objectA.y += objectA.velocity.y;


                    if ( objectA.x > _canvas.width )

                        objectA.x = 0;


                    if ( objectA.x < 0 )

                        objectA.x = _canvas.width;


                    if ( objectA.y > _canvas.height )

                        objectA.y = 0;


                    if ( objectA.y < 0 )

                        objectA.y = _canvas.height;


                    for ( let _objectB, _j = iter + 1; _j < _amount; _j++ )
                    {
                        _objectB = _particles [ _j ];

                        _drawLine ( objectA, _objectB );
                    }
                }

                isPoint ( circle )
                {
                    console.log ( 'circle:', circle );
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( particle )
                {
                    particle.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _particles.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _particles.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 12:8
        applyingMassToConnectedParticles: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _particles = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount       = 30;

                let _minDistance  = 100;

                let _springAmount = 0.005;

            ////    POPULATION    //////////////////////////

                for ( let _size, _particle, _i = 0; _i < _amount; _i++ )
                {
                    _particle = new Circle;


                    _size = Math.random ( ) * 10 + 2;


                    _particle.radius = _size;

                    _particle.mass   = _size;


                    _particle.x = Math.random ( ) * _canvas.width;

                    _particle.y = Math.random ( ) * _canvas.height;


                    _particle.velocity.x = Math.random ( ) * 6 - 3;

                    _particle.velocity.y = Math.random ( ) * 6 - 3;


                    _particles.push ( _particle );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _spring ( objectA, objectB )
                {
                    let _distance     = new Point;

                    let _acceleration = new Point;


                        _distance.x = objectB.x - objectA.x;

                        _distance.y = objectB.y - objectA.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    if ( _distance.total < _minDistance )
                    {
                        let _alpha = 1 - _distance.total / _minDistance;


                        _context.strokeStyle = utils.colorToRGB ( "#000000", _alpha );


                        _context.beginPath ( );


                        _context.moveTo ( objectA.x, objectA.y );

                        _context.lineTo ( objectB.x, objectB.y );


                        _context.stroke ( );


                        _acceleration.x = _distance.x * _springAmount;

                        _acceleration.y = _distance.y * _springAmount;


                        objectA.velocity.x += _acceleration.x / objectA.mass;

                        objectA.velocity.y += _acceleration.y / objectA.mass;


                        objectB.velocity.x -= _acceleration.x / objectB.mass;

                        objectB.velocity.y -= _acceleration.y / objectB.mass;
                    }
                }

                function _move ( objectA, iter )
                {
                    objectA.x += objectA.velocity.x;

                    objectA.y += objectA.velocity.y;


                    if ( objectA.x > _canvas.width )

                        objectA.x = 0;


                    if ( objectA.x < 0 )

                        objectA.x = _canvas.width;


                    if ( objectA.y > _canvas.height )

                        objectA.y = 0;


                    if ( objectA.y < 0 )

                        objectA.y = _canvas.height;


                    for ( let _objectB, _j = iter + 1; _j < _amount; _j++ )
                    {
                        _objectB = _particles [ _j ];

                        _spring ( objectA, _objectB );
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( particle )
                {
                    particle.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _particles.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _particles.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 13:2
        singleSegmentAndSlider: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _segment = new Segment ( new Point ( 100, 100 ), new Aspect ( 100, 20 ) );

                let _slider  = new Slider ( new Point ( 300, 20 ), undefined, new Range ( - 90, 90, 0 ) );

                    _slider.captureMouse ( _canvas );

                    _slider.onchange = _drawFrame;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _segment.position.rotation = _slider.value * Math.PI / 180;

                    ////    DRAW    ////////////////////////

                        _segment.draw ( );

                        _slider.draw ( );
                }


                _drawFrame ( );
        },
        // 13:3
        movingTwoSegmentsIndependent: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( new Point ( 100, 100 ), new Aspect ( 100, 20 ) );

                let _segment1 = new Segment ( undefined, new Aspect ( 100, 20 ) );


                let _slider0 = new Slider ( new Point ( 320, 20 ), undefined, new Range ( - 90, 90, 0 ) );

                    _slider0.captureMouse ( _canvas );

                    _slider0.onchange = _drawFrame;


                let _slider1 = new Slider ( new Point ( 340, 20 ), undefined, new Range ( - 90, 90, 0 ) );

                    _slider1.captureMouse ( _canvas );

                    _slider1.onchange = _drawFrame;

            ////    DRAW    ////////////////////////////////

            function _drawFrame ( )
            {
                ////    LOOP DATA    ///////////////////

                    _timeCurrent = LAB.getFps ( _timeCurrent );

                ////    CLEAR SCREEN    ////////////////

                    _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                ////    TRANSITIONS    /////////////////

                    _segment0.rotation = _slider0.value * Math.PI / 180;

                    _segment1.rotation = _slider1.value * Math.PI / 180;


                    _segment1.x = _segment0.pin.x;

                    _segment1.y = _segment0.pin.y;

                ////    DRAW    ///////////////////////

                _segment0.draw ( );

                _segment1.draw ( );


                _slider0.draw ( );

                _slider1.draw ( );
            }


            _drawFrame (  );
        },
        // 13:4
        movingTwoSegmentsJoined: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( new Point ( 100, 100 ), new Aspect ( 100, 20 ) );

                let _segment1 = new Segment ( undefined,              new Aspect ( 100, 20 ) );


                let _slider0 = new Slider ( new Point ( 320, 20 ), undefined, new Range ( - 90, 90, 0 ) );

                    _slider0.captureMouse ( _canvas );

                    _slider0.onchange = _drawFrame;


                let _slider1 = new Slider ( new Point ( 340, 20 ), undefined, new Range ( - 160, 90, 0 ) );

                    _slider1.captureMouse ( _canvas );

                    _slider1.onchange = _drawFrame;

            ////    DRAW    ////////////////////////////////

            function _drawFrame ( )
            {
                ////    LOOP DATA    ///////////////////

                    _timeCurrent = LAB.getFps ( _timeCurrent );

                ////    CLEAR SCREEN    ////////////////

                    _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                ////    TRANSITIONS    /////////////////

                    _segment0.rotation = _slider0.value * Math.PI / 180;

                    _segment1.rotation = _segment0.rotation + ( _slider1.value * Math.PI / 180 );


                    _segment1.x = _segment0.pin.x;

                    _segment1.y = _segment0.pin.y;

                ////    DRAW    ///////////////////////

                _segment0.draw ( );

                _segment1.draw ( );


                _slider0.draw ( );

                _slider1.draw ( );
            }


            _drawFrame (  );
        },
        // 13:5
        automateWalk: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( new Point ( 200, 200 ), new Aspect ( 100, 20 ) );

                let _segment1 = new Segment ( undefined, new Aspect ( 100, 20 ) );

                    _segment1.x = _segment0.pin.x;

                    _segment1.y = _segment0.pin.y;

            ////    SET DEFAULTS    ////////////////////////

                let _cycle = 0;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _cycle += 0.02;


                        let _angle = ( Math.sin ( _cycle ) * 90 ) * Math.PI / 180;


                        _segment0.rotation = _angle;

                        _segment1.rotation = _segment0.rotation + _angle;


                        _segment1.x = _segment0.pin.x;

                        _segment1.y = _segment0.pin.y;

                    ////    DRAW    ////////////////////////

                        _segment0.draw ( );

                        _segment1.draw ( );
                }


                _drawFrame ( );
        },
        // 13:6
        naturalWalk: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( new Point ( 200, 200 ), new Aspect ( 100, 20 ) );

                let _segment1 = new Segment ( undefined, new Aspect ( 100, 20 ) );

                    _segment1.x = _segment0.pin.x;

                    _segment1.y = _segment0.pin.y;

            ////    SET DEFAUlTS    ////////////////////////

                let _cycle = 0;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _cycle += 0.02;


                        let _angle0 = ( Math.sin ( _cycle ) * 45 + 90 ) * Math.PI / 180;

                        let _angle1 = ( Math.sin ( _cycle ) * 45 + 45 ) * Math.PI / 180;


                        _segment0.rotation = _angle0;

                        _segment1.rotation = _segment0.rotation + _angle1;


                        _segment1.x = _segment0.pin.x;

                        _segment1.y = _segment0.pin.y;

                    ////    DRAW    ////////////////////////

                        _segment0.draw ( );

                        _segment1.draw ( );
                }


                _drawFrame ( );
        },
        // 13:7
        naturalWalkWithTwoLegs: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( new Point ( 200, 200 ), new Aspect ( 100, 20 ) );


                let _segment1 = new Segment ( undefined, new Aspect ( 100, 20 ) );

                    _segment1.x = _segment0.pin.x;

                    _segment1.y = _segment0.pin.y;


                let _segment2 = new Segment ( new Point ( 200, 200 ), new Aspect ( 100, 20 ) );


                let _segment3 = new Segment ( undefined, new Aspect ( 100, 20 ) );

                    _segment3.x = _segment2.pin.x;

                    _segment3.y = _segment2.pin.y;

            ////    SET DEFAULTS    ////////////////////////

                let _cycle = 0;

                let _offset = - Math.PI / 2; //should be between PI and -PI

            ////    FUNCTIONS    ///////////////////////////

                function _walk ( segmentA, segmentB, cycle )
                {
                    let _angle0 = ( Math.sin ( cycle ) * 45 + 90 ) * Math.PI / 180;

                    let _angle1 = ( Math.sin ( cycle + _offset ) * 45 + 45 ) * Math.PI / 180;


                    segmentA.rotation = _angle0;

                    segmentB.rotation = segmentA.rotation + _angle1;


                    segmentB.x = segmentA.pin.x;

                    segmentB.y = segmentA.pin.y;
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _cycle += 0.02;


                        _walk ( _segment0, _segment1, _cycle );

                        _walk ( _segment2, _segment3, _cycle );

                    ////    DRAW    ////////////////////////

                        _segment0.draw ( );

                        _segment1.draw ( );

                        _segment2.draw ( );

                        _segment3.draw ( );
                }


                _drawFrame ( );
        },
        // 13:8
        naturalWalkWithTwoVisibleLegs: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( new Point ( 200, 200 ), new Aspect ( 100, 30 ) );


                let _segment1 = new Segment ( undefined, new Aspect ( 100, 20 ) );

                    _segment1.x = _segment0.pin.x;

                    _segment1.y = _segment0.pin.y;


                let _segment2 = new Segment ( new Point ( 200, 200 ), new Aspect ( 100, 30 ) );


                let _segment3 = new Segment ( undefined, new Aspect ( 100, 20 ) );

                    _segment3.x = _segment2.pin.x;

                    _segment3.y = _segment2.pin.y;

            ////    SET DEFAULTS    ////////////////////////

                let _cycle  = 0;

                let _offset = - Math.PI / 2;      // SHOULD BE BETWEEN PI AND -PI

            ////    FUNCTIONS    ///////////////////////////

                function _walk ( segmentA, segmentB, cycle )
                {
                    let _angle0 = ( Math.sin ( cycle ) * 45 + 90 ) * Math.PI / 180;
                    let _angle1 = ( Math.sin ( cycle + _offset ) * 45 + 45 ) * Math.PI / 180;

                    segmentA.rotation = _angle0;
                    segmentB.rotation = segmentA.rotation + _angle1;

                    segmentB.x = segmentA.pin.x;
                    segmentB.y = segmentA.pin.y;
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _cycle += 0.02;

                        _walk ( _segment0, _segment1, _cycle );

                        _walk ( _segment2, _segment3, _cycle + Math.PI );

                    ////    DRAW    ////////////////////////

                        _segment0.draw ( );

                        _segment1.draw ( );

                        _segment2.draw ( );

                        _segment3.draw ( );
                }


                _drawFrame ( );
        },
        // 13:9
        dynamicWalkControls: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( new Point ( 200, 200 ), new Aspect ( 100, 30 ) );


                let _segment1 = new Segment ( undefined, new Aspect ( 100, 20 ) );

                    _segment1.x = _segment0.pin.x;

                    _segment1.y = _segment0.pin.y;


                let _segment2 = new Segment ( new Point ( 200, 200 ), new Aspect ( 100, 30 ) );


                let _segment3 = new Segment ( undefined, new Aspect ( 100, 20 ) );

                    _segment3.x = _segment2.pin.x;

                    _segment3.y = _segment2.pin.y;


                let _speedSlider = new Slider ( new Point ( 310, 10 ), undefined, new Range ( 0, 0.2, 0.08 ) );

                    _speedSlider.captureMouse ( _canvas );


                let _thighRangeSlider = new Slider ( new Point ( 330, 10 ), undefined, new Range ( 0, 90, 45 ) );

                    _thighRangeSlider.captureMouse ( _canvas );


                let _thighBaseSlider = new Slider ( new Point ( 350, 10 ), undefined, new Range ( 0, 180, 90 ) );

                    _thighBaseSlider.captureMouse ( _canvas );


                let _calfRangeSlider = new Slider ( new Point ( 370, 10 ), undefined, new Range ( 0, 90, 45 ) );

                    _calfRangeSlider.captureMouse ( _canvas );


                let _calfOffsetSlider = new Slider ( new Point ( 390, 10 ), undefined, new Range ( -3.14, 3.14, -1.57 ) );

                    _calfOffsetSlider.captureMouse ( _canvas );


                let _cycle = 0;

            ////    FUNCTIONS    ///////////////////////////////////

                function _walk ( segmentA, segmentB, cycle )
                {
                    let _angle0 = ( Math.sin ( cycle ) * _thighRangeSlider.value + _thighBaseSlider.value ) * Math.PI / 180;

                    let _angle1 = ( Math.sin ( cycle + _calfOffsetSlider.value ) * _calfRangeSlider.value + _calfRangeSlider.value ) * Math.PI / 180;


                    segmentA.rotation = _angle0;

                    segmentB.rotation = segmentA.rotation + _angle1;


                    segmentB.x = segmentA.pin.x;

                    segmentB.y = segmentA.pin.y;
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _cycle += _speedSlider.value;


                        _walk ( _segment0, _segment1, _cycle );

                        _walk ( _segment2, _segment3, _cycle + Math.PI );

                    ////    DRAW    ////////////////////////////////////

                        _segment0.draw ( );

                        _segment1.draw ( );

                        _segment2.draw ( );

                        _segment3.draw ( );


                        _speedSlider.draw ( );

                        _thighRangeSlider.draw ( );

                        _thighBaseSlider.draw ( );

                        _calfRangeSlider.draw ( );

                        _calfOffsetSlider.draw ( );
                }


                _drawFrame ( );
        },
        // 13:10
        realWalkOnTheGround: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( new Point ( 200, 200 ), new Aspect ( 50, 15 ) );


                let _segment1 = new Segment ( new Point, new Aspect ( 50, 10 ) );

                    _segment1.x = _segment0.pin.x;

                    _segment1.y = _segment0.pin.y;


                let _segment2 = new Segment ( new Point ( 200, 200 ), new Aspect ( 50, 15 ) );


                let _segment3 = new Segment ( new Point, new Aspect ( 50, 10 ) );

                    _segment3.x = _segment2.pin.x;

                    _segment3.y = _segment2.pin.y;


                let _speedSlider = new Slider ( new Point ( 310, 10 ), undefined, new Range ( 0, 0.2, 0.08 ) );

                    _speedSlider.captureMouse ( _canvas );


                let _thighRangeSlider = new Slider ( new Point ( 330, 10 ), undefined, new Range ( 0, 90, 45 ) );

                    _thighRangeSlider.captureMouse ( _canvas );


                let _thighBaseSlider = new Slider ( new Point ( 350, 10 ), undefined, new Range ( 0, 180, 90 ) );

                    _thighBaseSlider.captureMouse ( _canvas );


                let _calfRangeSlider = new Slider ( new Point ( 370, 10 ), undefined, new Range ( 0, 90, 45 ) );

                    _calfRangeSlider.captureMouse ( _canvas );


                let _calfOffsetSlider = new Slider ( new Point ( 390, 10 ), undefined, new Range ( - 3.14, 3.14, - 1.57 ) );

                    _calfOffsetSlider.captureMouse ( _canvas );


                let _gravitySlider = new Slider ( new Point ( 410, 10 ), undefined, new Range ( 0, 1, 0.2 ) );

                    _gravitySlider.captureMouse ( _canvas );

            ////    SET DEFAULTS    ////////////////////////

                let _cycle    = 0;

                let _velocity = new Point;

            ////    FUNCTIONS    ///////////////////////////

                function _setVelocity (  )
                {
                    _velocity.y += _gravitySlider.value;


                    _segment0.x += _velocity.x;

                    _segment0.y += _velocity.y;


                    _segment2.x += _velocity.x;

                    _segment2.y += _velocity.y;
                }

                function _walk ( segmentA, segmentB, cycle )
                {
                    let _angle0 = ( Math.sin ( cycle ) * _thighRangeSlider.value + _thighBaseSlider.value ) * Math.PI / 180;

                    let _angle1 = ( Math.sin ( cycle + _calfOffsetSlider.value ) * _calfRangeSlider.value + _calfRangeSlider.value ) * Math.PI / 180;


                    let _foot = segmentB.pin;


                    segmentA.rotation = _angle0;

                    segmentB.rotation = segmentA.rotation + _angle1;


                    segmentB.x = segmentA.pin.x;

                    segmentB.y = segmentA.pin.y;


                    segmentB.velocity.x = segmentB.pin.x - _foot.x;

                    segmentB.velocity.y = segmentB.pin.y - _foot.y;
                }

                function _checkFloor ( segment )
                {
                    let _yMax = segment.pin.y + ( segment.height / 2 );


                    if ( _yMax > _canvas.height )
                    {
                        let _dy = _yMax - _canvas.height;


                        _segment0.y -= _dy;

                        _segment1.y -= _dy;

                        _segment2.y -= _dy;

                        _segment3.y -= _dy;


                        _velocity.x -= segment.velocity.x;

                        _velocity.y -= segment.velocity.y;
                    }
                }

                function _checkWalls ( )
                {
                    let _width = _canvas.width + 200;


                    if ( _segment0.x > _canvas.width + 100 )
                    {
                        _segment0.x -= _width;

                        _segment1.x -= _width;

                        _segment2.x -= _width;

                        _segment3.x -= _width;
                    }


                    if  ( _segment0.x < - 100 )
                    {
                        _segment0.x += _width;

                        _segment1.x += _width;

                        _segment2.x += _width;

                        _segment3.x += _width;
                    }
                }

            ////    DRAW    ////////////////////////////////

            function _drawFrame ( )
            {
                window.requestAnimationFrame ( _drawFrame, _canvas );

                ////    LOOP DATA    ///////////////////

                    _timeCurrent = LAB.getFps ( _timeCurrent );

                ////    CLEAR SCREEN    ////////////////

                    _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                ////    TRANSITIONS    /////////////////

                    _cycle += _speedSlider.value;

                    _setVelocity (  );


                    _walk ( _segment0, _segment1, _cycle );

                    _walk ( _segment2, _segment3, _cycle + Math.PI );


                    _checkFloor ( _segment1 );

                    _checkFloor ( _segment3 );


                    _checkWalls ( );

                ////    DRAW    ////////////////////////////

                _segment0.draw ( );

                _segment1.draw ( );

                _segment2.draw ( );

                _segment3.draw ( );


                _speedSlider.draw ( );

                _thighRangeSlider.draw ( );

                _thighBaseSlider.draw ( );

                _calfRangeSlider.draw ( );

                _calfOffsetSlider.draw ( );

                _gravitySlider.draw ( );
            }


            _drawFrame ( );
        },
        // 14:1
        reachingWithASingleSegment: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segment = new Segment;


                    _segment.width  = 100;

                    _segment.height = 20;


                    _segment.x = _canvas.width  / 2;

                    _segment.y = _canvas.height / 2;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        let _distance = new Point;


                        _distance.x = _mouse.x - _segment.x;

                        _distance.y = _mouse.y - _segment.y;


                        _segment.position.rotation = Math.atan2 ( _distance.y, _distance.x );

                    ////    DRAW    ////////////////////////

                        _segment.draw ( );
                }


                _drawFrame ( );
        },
        // 14:2
        draggingASingleSegment: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segment = new Segment;

                    _segment.width  = 100;

                    _segment.height = 20;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        let _distance = new Point;

                            _distance.x = _mouse.x - _segment.x;

                            _distance.y = _mouse.y - _segment.y;


                        _segment.position.rotation = Math.atan2 ( _distance.y, _distance.x );


                        let _width  = _segment.pin.x - _segment.x;

                        let _height = _segment.pin.y - _segment.y;


                        _segment.x = _mouse.x - _width;

                        _segment.y = _mouse.y - _height;

                    ////    DRAW    ////////////////////////

                        _segment.draw ( );
                }


                _drawFrame ( );
        },
        // 14:3
        draggingTwoSegments: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( 100, 20 );

                    _segment0.width  = 100;

                    _segment0.height = 20;

                let _segment1 = new Segment ( 100, 20 );

                    _segment1.width  = 100;

                    _segment1.height = 20;

            ////    FUNCTIONS    ///////////////////////////

                function _drag ( segment, x, y )
                {
                    let _distance = new Point;

                        _distance.x = x - segment.x;

                        _distance.y = y - segment.y;


                    segment.position.rotation = Math.atan2(_distance.y, _distance.x);


                    let _width  = segment.pin.x - segment.x;

                    let _height = segment.pin.y - segment.y;


                    segment.x = x - _width;

                    segment.y = y - _height;
                }

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _drag ( _segment0, _mouse.x, _mouse.y );

                        _drag ( _segment1, _segment0.x, _segment0.y );

                    ////    DRAW    ////////////////////////

                        _segment0.draw ( );

                        _segment1.draw ( );
                }


                _drawFrame ( );
        },
        // 14:4
        draggingManySegments: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segments = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount = 5;

            ////    POPULATION    //////////////////////////

                while ( _amount-- )
                {
                    let _segment = new Segment;

                        _segment.width  = 50;

                        _segment.height = 10;


                    _segments.push ( _segment );
                }

            ////    FUNCTIONS    ///////////////////////////

                function _drag ( segment, x, y )
                {
                    let _distance = new Point;

                        _distance.x = x - segment.x;

                        _distance.y = y - segment.y;


                    segment.position.rotation = Math.atan2 ( _distance.y, _distance.x );


                    let _width  = segment.pin.x - segment.x;

                    let _height = segment.pin.y - segment.y;


                    segment.x = x - _width;

                    segment.y = y - _height;
                }

                function _move ( segment, iter )
                {
                    if ( iter !== 0 )

                        _drag ( segment, _segments [ iter - 1 ].x, _segments [ iter - 1 ].y );
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( segment )
                {
                    segment.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _drag ( _segments [ 0 ], _mouse.x, _mouse.y );

                        _segments.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _segments.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 14:5
        reachingWithTwoSegments: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( undefined, { width: 100, height: 20 } );

                let _segment1 = new Segment ( undefined, { width: 100, height: 20 } );

                    _segment1.x = _canvas.width  / 2;

                    _segment1.y = _canvas.height / 2;

            ////    FUNCTIONS    ///////////////////////////

                function _reach ( segment, x, y )
                {
                    let _distance = new Point;

                        _distance.x = x - segment.x;

                        _distance.y = y - segment.y;


                    segment.position.rotation = Math.atan2 ( _distance.y, _distance.x );


                    let _width  = segment.pin.x - segment.x;

                    let _height = segment.pin.y - segment.y;


                    return {
                               x: x - _width,
                               y: y - _height
                           };
                }

                function _position ( segmentA, segmentB )
                {
                    segmentA.x = segmentB.pin.x;

                    segmentA.y = segmentB.pin.y;
                }

            ////    DRAW    ////////////////////////////////

            function _drawFrame ( )
            {
                window.requestAnimationFrame ( _drawFrame, _canvas );

                ////    LOOP DATA    ///////////////////

                    _timeCurrent = LAB.getFps ( _timeCurrent );

                ////    CLEAR SCREEN    ////////////////

                    _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                ////    TRANSITIONS    /////////////////

                    let _target = _reach ( _segment0, _mouse.x, _mouse.y );


                    _reach ( _segment1, _target.x, _target.y );

                    _position ( _segment0, _segment1 );

                ////    DRAW    ////////////////////////

                    _segment0.draw ( );

                    _segment1.draw ( );
            }


            _drawFrame  (  )
        },
        // 14:6
        reachingWithManySegments: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segments = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount = 5;

                let _target = undefined;

            ////    POPULATION    //////////////////////////

                while ( _amount-- )
                {
                    _segments.push ( new Segment ( undefined, { width: 50, height: 10 } ) );
                }


                // CENTER THE LAST ONE
                _segments [ _segments.length - 1 ].x = _canvas.width  / 2;

                _segments [ _segments.length - 1 ].y = _canvas.height / 2;

            ////    FUNCTIONS    /////////////////

                function _reach ( segment, x, y )
                {
                    let _distance = new Point;

                        _distance.x = x - segment.x;

                        _distance.y = y - segment.y;


                    segment.position.rotation = Math.atan2 ( _distance.y, _distance.x );


                    let _width  = segment.pin.x - segment.x;

                    let _height = segment.pin.y - segment.y;


                    return {
                               x: x - _width,

                               y: y - _height
                           };
                }

                function _position ( segmentA, segmentB )
                {
                    segmentA.x = segmentB.pin.x;

                    segmentA.y = segmentB.pin.y;
                }

                function _move ( segment, iter )
                {
                    if ( iter !== 0 )
                    {
                        _target = _reach ( segment, _target.x, _target.y );

                        _position ( _segments [ iter - 1 ], segment );
                    }
                }

            ////    DRAW    //////////////////////

                function _draw ( segment )
                {
                    segment.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _target = _reach ( _segments [ 0 ], _mouse.x, _mouse.y );

                        _segments.forEach ( _move );

                    ////    DRAW    ////////////////////////

                        _segments.forEach ( _draw );
                }


                _drawFrame ( );
        },
        // 14:7
        reachingForAnObject: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    OBJECTS    /////////////////////////////

                let _circle = new Circle;

                    _circle.radius = 20;

                    _circle.velocity.x = 10;


                let _segments = new Array;

            ////    SET DEFAULTS    ////////////////////////

                let _amount  = 5;

                let _gravity = 0.5;

                let _bounce = -0.9;

                let _target = undefined;

            ////    POPULATION    //////////////////////////

                while ( _amount-- )
                {
                    _segments.push ( new Segment ( undefined, { width: 20, height: 10 } ) );
                }


                // CENTER THE LAST ONE
                _segments [ _segments.length - 1 ].x = _canvas.width  / 2;

                _segments [ _segments.length - 1 ].y = _canvas.height / 2;

            ////    FUNCTIONS    ///////////////////////////

                function _moveBall ( )
                {
                    _circle.velocity.y += _gravity;


                    _circle.x += _circle.velocity.x;

                    _circle.y += _circle.velocity.y;


                    if ( _circle.x + _circle.radius > _canvas.width )
                    {
                        _circle.x           = _canvas.width - _circle.radius;
                        _circle.velocity.x *= _bounce;
                    }


                    if ( _circle.x - _circle.radius < 0 )
                    {
                        _circle.x           = _circle.radius;
                        _circle.velocity.x *= _bounce;
                    }


                    if ( _circle.y + _circle.radius > _canvas.height )
                    {
                        _circle.y           = _canvas.height - _circle.radius;
                        _circle.velocity.y *= _bounce;
                    }


                    if ( _circle.y - _circle.radius < 0 )
                    {
                        _circle.y           = _circle.radius;
                        _circle.velocity.y *= _bounce;
                    }
                }

                function _reach ( segment, x, y )
                {
                    let _distance = new Point;

                        _distance.x = x - segment.x,

                        _distance.y = y - segment.y;


                    segment.position.rotation = Math.atan2 ( _distance.y, _distance.x );


                    let _width  = segment.pin.x - segment.x;

                    let _height = segment.pin.y - segment.y;


                    return {
                               x: x - _width,
                               y: y - _height
                           };
                }

                function _position ( segmentA, segmentB )
                {
                    segmentA.x = segmentB.pin.x;

                    segmentA.y = segmentB.pin.y;
                }

                function _checkHit ( )
                {
                    let _segment  = _segments [ 0 ];


                    let _distance = new Point;


                        _distance.x = _segment.pin.x - _circle.x;

                        _distance.y = _segment.pin.y - _circle.y;


                        _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                    if ( _distance.total < _circle.radius )
                    {
                        _circle.velocity.x += Math.random (  ) * 2 - 1;

                        _circle.velocity.y -= 1;
                    }
                }

                function _move ( segment, iter )
                {
                    if  ( iter !== 0 )
                    {
                        _target = _reach ( segment, _target.x, _target.y );

                        _position ( _segments [ iter - 1 ], segment );
                    }
                }

            ////    DRAW    ////////////////////////////////

                function _draw ( segment )
                {
                    segment.draw ( );
                }

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        _moveBall ( );

                        _target = _reach ( _segments [ 0 ], _circle.x, _circle.y );

                        _segments.forEach ( _move );

                        _checkHit (  );

                    ////    DRAW    ////////////////////////

                        _segments.forEach ( _draw );

                        _circle.draw ( );
                }


                _drawFrame ( );
        },
        // 14:8
        reachingWithTheLawOfCosines: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( undefined, { width: 100, height: 20 } );

                let _segment1 = new Segment ( undefined, { width: 100, height: 20 } );

                    _segment1.x = _canvas.width  / 2;

                    _segment1.y = _canvas.height / 2;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        let _distance = new Point;

                            _distance.x = _mouse.x - _segment1.x;

                            _distance.y = _mouse.y - _segment1.y;


                            _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                        let _a = 100;

                        let _b = 100;


                        let _c = Math.min ( _distance.total, _a + _b );


                        let _B = Math.acos ( ( _b * _b - _a * _a - _c * _c ) / ( - 2 * _a * _c ) );

                        let _C = Math.acos ( ( _c * _c - _a * _a - _b * _b ) / ( - 2 * _a * _b ) );


                        let _D = Math.atan2 ( _distance.y, _distance.x );


                        let _E = _D + _B + Math.PI + _C;


                        _segment1.position.rotation = ( _D + _B );


                        _segment0.x = _segment1.pin.x;

                        _segment0.y = _segment1.pin.y;


                        _segment0.position.rotation = _E;

                    ////    DRAW    ////////////////////////

                        _segment0.draw ( );

                        _segment1.draw ( );
                }


                _drawFrame ( );
        },
        // 14:9
        reachingWithTheLawOfCosinesReverse: ( ) =>
        {
            ////    CONTEXT    /////////////////////////////

                let _canvas  = document.getElementById ( 'canvas' );

                let _context = _canvas.getContext ( '2d' );

            ////    LOOP DATA    ///////////////////////////

                let _timeCurrent = new Date ( );

            ////    INPUT    ///////////////////////////////

                let _mouse   = utils.captureMouse ( _canvas );

            ////    OBJECTS    /////////////////////////////

                let _segment0 = new Segment ( undefined, { width: 100, height: 20 } );

                let _segment1 = new Segment ( undefined, { width: 100, height: 20 } );

                    _segment1.x = _canvas.width  / 2;

                    _segment1.y = _canvas.height / 2;

            ////    DRAW    ////////////////////////////////

                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );

                    ////    LOOP DATA    ///////////////////

                        _timeCurrent = LAB.getFps ( _timeCurrent );

                    ////    CLEAR SCREEN    ////////////////

                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                    ////    TRANSITIONS    /////////////////

                        let _distance = new Point;

                            _distance.x = _mouse.x - _segment1.x;

                            _distance.y = _mouse.y - _segment1.y;

                            _distance.total = Math.sqrt ( _distance.x * _distance.x + _distance.y * _distance.y );


                        let _a = 100;

                        let _b = 100;


                        let _c = Math.min ( _distance.total, _a + _b );


                        let _B = Math.acos ( ( _b * _b - _a * _a - _c * _c ) / ( - 2 * _a * _c ) );

                        let _C = Math.acos ( ( _c * _c - _a * _a - _b * _b ) / ( - 2 * _a * _b ) );


                        let _D = Math.atan2 ( _distance.y, _distance.x );


                        let _E = _D - _B + Math.PI - _C;


                        _segment1.position.rotation = ( _D - _B );


                        _segment0.x = _segment1.pin.x;

                        _segment0.y = _segment1.pin.y;


                        _segment0.position.rotation = _E;

                    ////    DRAW    ////////////////////////

                        _segment0.draw ( );

                        _segment1.draw ( );
                }


                _drawFrame ( );
        },
        // Extra - Web-Workers
        EXTRA_WebWorkers: ( ) =>
        {
            /**
             * test browser support for Web Workers
             */
            if ( typeof Worker !== 'function' )
            {
                let _error = new ReferenceError ( "Sorry, Web Workers are not supported in your browser." );

                let _aside = document.getElementsByTagName ( 'aside' ) [ 0 ];

                    _aside.innerHTML = "<p><em>" + _error.message + " Check the <a href='http://caniuse.com/webworkers'>browser compatibility table</a>.</em></p>" + _aside.innerHTML;


                throw _error;
            }

            window.onload = function ( )
            {
                let _canvas      = document.getElementById('canvas');

                let _context     = canvas.getContext('2d');

                let _worker      = new Worker ( './workers/collision-worker.js' );

                let _balls       = new Array;

                let _numBalls    = 15;

                let _renderFrame = true;


                // INITIALIZE THE BALL POSITIONS AS IN PRIOR EXAMPLE
                for ( let _radius, _ball, _i = 0; _i < _numBalls; _i++ )
                {
                    _radius = Math.random ( ) * 20 + 15;


                    _ball = new Circle;


                    _ball.radius       = _radius;

                    _ball.stroke.color = Math.random ( ) * 0xffffff;

                    _ball.mass         = _radius;


                    _ball.x = Math.random ( ) * _canvas.width;

                    _ball.y = Math.random ( ) * _canvas.height;


                    _ball.velocity.x = Math.random ( ) * 10 - 5;

                    _ball.velocity.y = Math.random ( ) * 10 - 5;


                    _balls.push ( _ball );
                }

                // WORKERS CANNOT ACCESS THE DOM SO WE NEED TO INITIALIZE THE BOUNDARIES
                _worker.postMessage ( { width: _canvas.width, height: _canvas.height } );

                // SENDS A COPY OF THE BALLS ARRAY TO THE WORKER, COLLISION DETECTION WILL OPERATE ON THAT ARRAY COPY
                _worker.postMessage ( _balls );

                /**
                 * After the _worker has finished calculating a frame of collision detection, it sends a message
                 * containing a copy of THAT _balls array with the updated positions. The _worker loop is running
                 * at 30 fps, while the render loop is running at 60 fps.
                 * Update THIS _balls array in the main script using THOSE positions. THESE _balls are rendered in drawFrame.
                 */
                _worker.addEventListener ( 'message', function ( event )
                {
                    for ( let _i = 0, _balls_copy = event.data, _len = _balls_copy.length; _i < _len; _i++ )
                    {
                        _balls [ _i ].x = _balls_copy [ _i ].x;

                        _balls [ _i ].y = _balls_copy [ _i ].y;
                    }

                    _renderFrame = true; // USED TO AVOID EXCESSIVE REPAINTS
                } );


                function _draw ( ball )
                {
                    ball.draw ( );
                }


                function _drawFrame ( )
                {
                    window.requestAnimationFrame ( _drawFrame, _canvas );


                    if ( _renderFrame )
                    {
                        _context.clearRect ( 0, 0, _canvas.width, _canvas.height );

                        _balls.forEach ( _draw );

                        _renderFrame = false;
                    }
                };

                _drawFrame ( );
            };
        }
    }

    ////    SETTERS    /////////////////////////////////////////////////////////////////////////////

        /**
         * Initializes classes for application use
         * @private
         * @function
         */
        function _setClasses ( )
        {
            for ( let _class of _classes )

                ( typeof ( window [ _class.toUpperCase ( ) ] ) === 'undefined' )

                    ? eval ( `window.${_class.toUpperCase ( )} = new ${_class};` )

                    : console.error ( `[ ERROR ]: window.${_class.toUpperCase ( )} already exists !` );
        }

        /**
         * Sets windows global variable space with this wrapper's declared classes
         * @private
         * @function
         */
        function _setEnvironment ( )
        {
            let _navList = document.querySelector ( '#nav-links' );


            _setClasses ( );

            UI.setNavLinks ( _navList, _navLinks );


            if ( typeof ( window.cardObjects ) === 'undefined' )

                window.cardObjects = _cardObjects;
        }

        /***
         * Sets lab mode as the startup mode
         * @private
         * @function
         */
        function _setLabMode ( )
        {
            UI.clearScreen ( false, true );


            LAB.setCanvasSize ( );

            LAB.setLabDefaults ( [ 'sidebar', 'full-screen' ] );


            window.addEventListener ( 'resize', LAB.setCanvasSize );
        }

    ////    LIBRARY WRAPPER    /////////////////////////////////////////////////////////////////////

        /**
         * Returns library object
         * @private
         * @function
         * @return          {Object}                            Library object
         */
        function _library ( )
        {
            let _lib = { }

            ////    CONFIG    //////////////////////////////////////////////////

            _lib.config =
            {
                boostrapOffcanvas: undefined,
            }

            ////    FUNCTIONS    ///////////////////////////////////////////////

                /**
                 * Returns internal scripts object
                 * @public
                 * @function
                 * @return          {Object}                            Scripts object
                 */
                _lib.getScripts            = ( )                       => _scripts;

                /**
                 * Runs easing animation for an animation card
                 * @public
                 * @function
                 * @param           {string} easingFunction             Easing function; as a string
                 * @param           {number} index                      Index of animation card
                 */
                _lib.runEasingAnimation    = ( easingFunction, index ) => UI.runEasingAnimation ( easingFunction, index );

                /**
                 * Runs lab-station code from editor
                 * @public
                 * @function
                 */
                _lib.runLabStationCode     = ( )                       => LAB.runCode ( );

                /**
                 * Toggles individual card buttons using their 'suite-data' attributes
                 * @public
                 * @function
                 * @param           {HTMLElement} element               HTML DOM Element
                 */
                _lib.toggleCardButton      = ( element )               => UI.toggle.cardButton ( element );

                /**
                 * Toggles lab from each card-object
                 * @public
                 * @function
                 * @param           {HTMLElement} element               HTML DOM Element
                 */
                _lib.toggleLab             = ( element )               => UI.toggle.lab ( element );


            return _lib;
        }

    ////    INITIALIZE    //////////////////////////////////////////////////////////////////////////

        /**
         * Initiates devSuite
         * @private
         * @function
         */
        function _init ( )
        {
            window.devSuite = _library ( );


            _setEnvironment ( );


            if ( window.cardObjects )
            {
                UI.init  ( );

                LAB.init ( _scripts.draggingAndEasingDemo11 );


                if ( true )

                    _setLabMode ( );
            }
            else

                console.error ( '[ ERROR ]: window.cardObjects is not available !' );
        }


        if ( typeof ( window.devSuite ) === 'undefined' )

            _init ( );

} ) ( window );
